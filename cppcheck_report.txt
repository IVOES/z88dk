doc/target/gl/vtech.h:817:12: error: syntax error [syntaxError]
   ; Check if zero (end of string)
           ^
examples/ace/dstar.h:53:20: error: syntax error: 1 = [syntaxError]
 defb    @01111111 ;1=edge, (left)
                   ^
examples/aquarius/dstar.c:94:5: style: Unused variable: i [unusedVariable]
int i;
    ^
examples/c128/dstar.h:67:20: error: syntax error: 1 = [syntaxError]
 defb    @01111111 ;1=edge, (left)
                   ^
examples/c128/sgdemo.c:48:1: error: syntax error: ; . _rawsound [syntaxError]
._rawsound
^
examples/clisp/clisp.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 26 configurations. Use --force to check all configurations. [toomanyconfigs]

^
examples/clisp/clisp.c:1309:9: style: Variable 'r' is reassigned a value before the old one has been used. [redundantAssignment]
      r = 1 / d;
        ^
examples/clisp/clisp.c:1303:9: note: r is assigned
      r = 1;
        ^
examples/clisp/clisp.c:1309:9: note: r is overwritten
      r = 1 / d;
        ^
examples/clisp/clisp.c:667:9: style: The scope of the variable 's' can be reduced. [variableScope]
  long  s, v;
        ^
examples/clisp/clisp.c:1091:9: style: The scope of the variable 'x' can be reduced. [variableScope]
  long  x, y;
        ^
examples/clisp/clisp.c:1091:12: style: The scope of the variable 'y' can be reduced. [variableScope]
  long  x, y;
           ^
examples/clisp/clisp.c:1089:27: style:inconclusive: Function 'eval_args' argument 2 names different: declaration 'a' definition 'arg'. [funcArgNamesDifferent]
eval_args(long func, long arg, long av[2], int n)
                          ^
examples/clisp/clisp.c:440:33: note: Function 'eval_args' argument 2 names different: declaration 'a' definition 'arg'.
long  eval_args(long func, long a, long av[2], int n);
                                ^
examples/clisp/clisp.c:1089:27: note: Function 'eval_args' argument 2 names different: declaration 'a' definition 'arg'.
eval_args(long func, long arg, long av[2], int n)
                          ^
examples/clisp/clisp.c:1416:12: style:inconclusive: Function 'apply' argument 1 names different: declaration 'f' definition 'func'. [funcArgNamesDifferent]
apply(long func, long aparams, int n)
           ^
examples/clisp/clisp.c:443:18: note: Function 'apply' argument 1 names different: declaration 'f' definition 'func'.
long  apply(long f, long args, int n);
                 ^
examples/clisp/clisp.c:1416:12: note: Function 'apply' argument 1 names different: declaration 'f' definition 'func'.
apply(long func, long aparams, int n)
           ^
examples/clisp/clisp.c:1416:23: style:inconclusive: Function 'apply' argument 2 names different: declaration 'args' definition 'aparams'. [funcArgNamesDifferent]
apply(long func, long aparams, int n)
                      ^
examples/clisp/clisp.c:443:26: note: Function 'apply' argument 2 names different: declaration 'args' definition 'aparams'.
long  apply(long f, long args, int n);
                         ^
examples/clisp/clisp.c:1416:23: note: Function 'apply' argument 2 names different: declaration 'args' definition 'aparams'.
apply(long func, long aparams, int n)
                      ^
examples/clisp/clisp.c:1444:13: error: Uninitialized variable: fdef [uninitvar]
  f = l_car(fdef);  /* formal parameters */
            ^
examples/clisp/clisp.c:810:11: style: Variable 'd1' is assigned a value that is never used. [unreadVariable]
  int  d1 = s1 & D_MASK_DATA;
          ^
examples/clisp/clisp.c:811:11: style: Variable 'd2' is assigned a value that is never used. [unreadVariable]
  int  d2 = s2 & D_MASK_DATA;
          ^
examples/clisp/clisp.c:502:15: warning: Obsolete function 'gets' called. It is recommended to use 'fgets' or 'gets_s' instead. [getsCalled]
      while (!gets(buf)) {};
              ^
examples/clisp/clisp_opt.c:127:32: error: syntax error [syntaxError]
;  Common optimizations (valid for both SHORT and default options)
                               ^
examples/clisp/clisp_opt.c:127:0: information: Skipping configuration 'SHORT' since the value of 'SHORT' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
;  Common optimizations (valid for both SHORT and default options)
^
examples/collider.c:293:19: error: Array 'corners[144]' accessed at index 144, which is out of bounds. [arrayIndexOutOfBounds]
      if ( corners[x]==the_player->direction &&
                  ^
examples/collider.c:186:5: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
    sprintf (scoretxt,"%06u",sc);
    ^
examples/collider.c:341:3: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
  printf("%u - %s\n",x+1,joystick_type[x]);
  ^
examples/console/adv_a.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 19 configurations. Use --force to check all configurations. [toomanyconfigs]

^
examples/console/adv_a.c:3079:9: error: Array 'GVARS[30]' accessed at index 30, which is out of bounds. [arrayIndexOutOfBounds]
   GVARS[n] = 0;
        ^
examples/console/adv_a.c:2898:2: warning:inconclusive: The buffer 'strTokenBuf' may not be null-terminated after the call to strncpy(). [terminateStrncpy]
 strncpy(strTokenBuf, "    ", 4); /* clear the token buffer to spaces */
 ^
examples/console/adv_a.c:1742:16: style: The scope of the variable 'ch' can be reduced. [variableScope]
 unsigned char ch;
               ^
examples/console/adv_a.c:2390:6: style: The scope of the variable 'nLoc' can be reduced. [variableScope]
 int nLoc;
     ^
examples/console/adv_a.c:2847:0: information: Skipping configuration 'COMPUTE_SCORE;printn' since the value of 'printn' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 printn(nScore,16,stdout);
^
examples/console/ansitest.c:36:9: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        printf("%c[%umFore text color %u.\n", 27, x, x);
        ^
examples/console/ansitest.c:36:9: warning: %u in format string (no. 3) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        printf("%c[%umFore text color %u.\n", 27, x, x);
        ^
examples/console/ansitest.c:40:9: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        printf("%c[%umBack text color %u.\n", 27, x, x);
        ^
examples/console/ansitest.c:40:9: warning: %u in format string (no. 3) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        printf("%c[%umBack text color %u.\n", 27, x, x);
        ^
examples/console/ansitest.c:54:9: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        printf("%c[%u;%uH*\n", 27, 10 + x, 25 + x);
        ^
examples/console/ansitest.c:54:9: warning: %u in format string (no. 3) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        printf("%c[%u;%uH*\n", 27, 10 + x, 25 + x);
        ^
examples/console/ansitest.c:55:9: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        printf("%c[%u;%uH*\n", 27, 20 - x, 25 + x);
        ^
examples/console/ansitest.c:55:9: warning: %u in format string (no. 3) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        printf("%c[%u;%uH*\n", 27, 20 - x, 25 + x);
        ^
examples/console/ansivt52.c:33:9: warning: %u in format string (no. 3) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        printf("%cb%cFore text color %u.\n", 27, x + 32,x);
        ^
examples/console/ansivt52.c:37:9: warning: %u in format string (no. 3) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        printf("%cc%cBack text color %u.\n", 27, x + 32,x);
        ^
examples/console/dstar_gencon.c:576:18: style: The scope of the variable 'locn' can be reduced. [variableScope]
  unsigned char *locn;
                 ^
examples/console/dstar_gencon.c:591:18: style: The scope of the variable 'locn' can be reduced. [variableScope]
  unsigned char* locn;
                 ^
examples/console/dstar_gencon.c:606:18: style: The scope of the variable 'locn' can be reduced. [variableScope]
  unsigned char *locn;
                 ^
examples/console/dstar_gencon.c:621:18: style: The scope of the variable 'locn' can be reduced. [variableScope]
  unsigned char *locn;
                 ^
examples/console/dstar_gencon.c:457:0: information: Skipping configuration 'SWITCH_MODE' since the value of 'SWITCH_MODE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
   maxy = SWITCH_MODE;
^
examples/console/fib.c:19:3: warning: %d in format string (no. 2) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
  printf("fib(%d) = %d\n",loop,results[loop]);
  ^
examples/console/mm.c:187:13: warning: Obsolete function 'gets' called. It is recommended to use 'fgets' or 'gets_s' instead. [getsCalled]
 i = strlen(gets(where));
            ^
examples/console/mm.c:176:10: warning: Redundant assignment of 'i' to itself. [selfAssignment]
nope:  i = i;
         ^
examples/console/rpn.c:74:5: warning: Obsolete function 'gets' called. It is recommended to use 'fgets' or 'gets_s' instead. [getsCalled]
    gets(s);
    ^
examples/console/samegame.c:428:30: style:inconclusive: Function 'copy_columns' argument 1 names different: declaration 'd' definition 'dx'. [funcArgNamesDifferent]
static void copy_columns(int dx, int sx)
                             ^
examples/console/samegame.c:240:30: note: Function 'copy_columns' argument 1 names different: declaration 'd' definition 'dx'.
static void copy_columns(int d, int s);
                             ^
examples/console/samegame.c:428:30: note: Function 'copy_columns' argument 1 names different: declaration 'd' definition 'dx'.
static void copy_columns(int dx, int sx)
                             ^
examples/console/samegame.c:428:38: style:inconclusive: Function 'copy_columns' argument 2 names different: declaration 's' definition 'sx'. [funcArgNamesDifferent]
static void copy_columns(int dx, int sx)
                                     ^
examples/console/samegame.c:240:37: note: Function 'copy_columns' argument 2 names different: declaration 's' definition 'sx'.
static void copy_columns(int d, int s);
                                    ^
examples/console/samegame.c:428:38: note: Function 'copy_columns' argument 2 names different: declaration 's' definition 'sx'.
static void copy_columns(int dx, int sx)
                                     ^
examples/console/samegame.c:254:9: style: Unused variable: mode [unusedVariable]
  int   mode;
        ^
examples/console/sorter.c:19:18: warning: Either the condition 'i<100' is redundant or the array 'A[100]' is accessed at index 100, which is out of bounds. [arrayIndexOutOfBoundsCond]
                A[i] = SIZE-i++;
                 ^
examples/console/sorter.c:18:17: note: Assuming that condition 'i<100' is not redundant
        while (i<SIZE)
                ^
examples/console/sorter.c:19:29: note: i is incremented', new value is 100
                A[i] = SIZE-i++;
                            ^
examples/console/sorter.c:19:18: note: Array index out of bounds
                A[i] = SIZE-i++;
                 ^
examples/console/sorter.c:14:25: style: The scope of the variable 'j' can be reduced. [variableScope]
        int A[SIZE], i, j, tmp;
                        ^
examples/console/sorter.c:14:28: style: The scope of the variable 'tmp' can be reduced. [variableScope]
        int A[SIZE], i, j, tmp;
                           ^
examples/console/sorter.c:19:22: error: Expression 'A[i]=100-i++' depends on order of evaluation of side effects [unknownEvaluationOrder]
                A[i] = SIZE-i++;
                     ^
examples/console/sorter.c:31:29: error: Expression 'A[j]=A[--j]' depends on order of evaluation of side effects [unknownEvaluationOrder]
                        A[j]=A[--j];
                            ^
examples/console/tic.c:106:18: warning: Either the condition 'c>9' is redundant or the array 'board[9]' is accessed at index 10, which is out of bounds. [arrayIndexOutOfBoundsCond]
        if (board[c] != player && board[c] != opponent) {
                 ^
examples/console/tic.c:102:27: note: Assuming that condition 'c>9' is not redundant
        while (c < 0 || c > 9)
                          ^
examples/console/tic.c:106:18: note: Array index out of bounds
        if (board[c] != player && board[c] != opponent) {
                 ^
examples/console/tic.c:106:18: warning: Either the condition 'c<0' is redundant or the array 'board[9]' is accessed at index -1, which is out of bounds. [negativeIndex]
        if (board[c] != player && board[c] != opponent) {
                 ^
examples/console/tic.c:102:18: note: Assuming that condition 'c<0' is not redundant
        while (c < 0 || c > 9)
                 ^
examples/console/tic.c:106:18: note: Negative array index
        if (board[c] != player && board[c] != opponent) {
                 ^
examples/console/tic.c:98:17: style: The scope of the variable 'c' can be reduced. [variableScope]
    signed char c;
                ^
examples/console/today.c:383:27: warning: Either the condition 'value==0' is redundant or the array 'twenties[8]' is accessed at index -2, which is out of bounds. [negativeIndex]
  op = copyst(op, twenties[(value-20) / 10]);
                          ^
examples/console/today.c:385:13: note: Assuming that condition 'value==0' is not redundant
  if (value == 0) {
            ^
examples/console/today.c:383:27: note: Negative array index
  op = copyst(op, twenties[(value-20) / 10]);
                          ^
examples/console/today.c:893:10: warning: Obsolete function 'gets' called. It is recommended to use 'fgets' or 'gets_s' instead. [getsCalled]
 return (gets(line) == NULL);
         ^
examples/console/today.c:361:13: style: Condition 'value<0' is always false [knownConditionTrueFalse]
  if (value < 0) {                /* Hack -32768          */
            ^
examples/console/today.c:358:12: note: Assuming that condition 'value<0' is not redundant
 if (value < 0) {
           ^
examples/console/today.c:360:12: note: Assignment 'value=-value', assigned value is 0
  value = (-value);
           ^
examples/console/today.c:361:13: note: Condition 'value<0' is always false
  if (value < 0) {                /* Hack -32768          */
            ^
examples/console/today.c:909:15: style: The scope of the variable 'temp' can be reduced. [variableScope]
 register int temp;
              ^
examples/console/today.c:912:61: warning: In expression like '*A++' the result of '*' is unused. Did you intend to write '(*A)++;'? [clarifyStatement]
 while (*valptr && (*valptr < '0' || *valptr > '9')) *valptr++;
                                                            ^
examples/console/today.c:506:6: error: Uninitialized variable: late [uninitvar]
 if (late && second > 0) {       /* Respectfully dedicated to    */
     ^
examples/console/today.c:737:7: error: Uninitialized variable: tvec [uninitvar]
 time(tvec);                     /* Get the time of day          */
      ^
examples/console/today.c:891:17: style: Unused variable: t [unusedVariable]
 register char *t;
                ^
examples/console/today.c:610:33: error: syntax error [syntaxError]
 .s.i -8;date Print information for the indicated date.
                                ^
examples/console/vtstone.c:382:39: error: Array 'stonex[48]' accessed at index 999, which is out of bounds. [arrayIndexOutOfBounds]
 for (y=0; y<1000; y++) Seed += stonex[y];
                                      ^
examples/console/vtstone.c:388:13: warning: Obsolete function 'gets' called. It is recommended to use 'fgets' or 'gets_s' instead. [getsCalled]
 inp = atoi(gets(string));
            ^
examples/console/vtstone.c:392:13: warning: Obsolete function 'gets' called. It is recommended to use 'fgets' or 'gets_s' instead. [getsCalled]
 NUM = atoi(gets(string));
            ^
examples/console/vtstone.c:159:2: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
 printf ("\033[%u;%uH",x+1,y+1);
 ^
examples/console/vtstone.c:159:2: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
 printf ("\033[%u;%uH",x+1,y+1);
 ^
examples/console/vtstone.c:197:17: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
                printf("Bad arg to mmove: %u",move);
                ^
examples/console/vtstone.c:356:3: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
  printf("Bad arg to mmove: %u",move);
  ^
examples/console/vtstone.c:396:18: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
 display(21,50); printf("\033[7m Difficulty: %u \033[27m", inp);
                 ^
examples/console/vtstone.c:427:25: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
                        printf("%u \033[27m",inp-7);
                        ^
examples/console/vtstone.c:441:9: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        printf("\033[7m Score:   me %u  you %u . . . ",com,hum);
        ^
examples/console/vtstone.c:441:9: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        printf("\033[7m Score:   me %u  you %u . . . ",com,hum);
        ^
examples/console/zxterminal.c:33:9: warning: %u in format string (no. 3) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        printf("%c%cFore text color %u.\n", 16, x + 32,x);
        ^
examples/console/zxterminal.c:37:9: warning: %u in format string (no. 3) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        printf("%c%cBack text color %u.\n", 17, x + 32,x);
        ^
examples/cpc/rs001.c:29:9: error: Uninitialized variable: z [uninitvar]
    if (z) {
        ^
examples/cpc/rs006.c:11:1: error: syntax error: ; . _binary_data [syntaxError]
._binary_data
^
examples/cpc/rs007.c:11:1: error: syntax error: ; . _binary_data [syntaxError]
._binary_data
^
examples/cpc/rs009.c:33:2: error: syntax error: ; . _kkk [syntaxError]
 ._kkk
 ^
examples/cpc/rs010.c:13:1: error: syntax error: ; . _sprite [syntaxError]
._sprite
^
examples/cpc/rs013.c:140:3: error: syntax error: 20. .. if [syntaxError]
  if (i0!=i || j0!=j) {
  ^
examples/cpm/dpb.c:33:18: error: syntax error: 1 = [syntaxError]
 ld hl,(1) ; base+1 = addr of jump table + 3
                 ^
examples/dstar.c:221:6: style: Unused variable: k [unusedVariable]
 int k;
     ^
examples/eg2000/dstar.h:54:20: error: syntax error: 1 = [syntaxError]
 defb    @01111111 ;1=edge, (left)
                   ^
examples/g800/box.c:13:7: style: The scope of the variable 'x' can be reduced. [variableScope]
  int x, y, w, h;
      ^
examples/g800/box.c:13:10: style: The scope of the variable 'y' can be reduced. [variableScope]
  int x, y, w, h;
         ^
examples/g800/box.c:13:13: style: The scope of the variable 'w' can be reduced. [variableScope]
  int x, y, w, h;
            ^
examples/g800/box.c:13:16: style: The scope of the variable 'h' can be reduced. [variableScope]
  int x, y, w, h;
               ^
examples/g800/physics.c:9:5: error: Uninitialized variable: a [uninitvar]
    a += 1;
    ^
examples/g800/physics.c:9:7: style: Variable 'a' is assigned a value that is never used. [unreadVariable]
    a += 1;
      ^
examples/graphics/chessboard.c:57:28: style:inconclusive: Boolean expression 'p>2' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
                while(r=p>2&r<0?-r:64-"01/@AP@ABPOQ@NR_a@"[++j])
                           ^
examples/graphics/chessboard.c:61:33: style:inconclusive: Boolean expression 'p==7' is used in bitwise operation. Did you mean '||'? [bitwiseOnBoolean]
                        if((p==7|!x)&&j==8||!(r&7)-!t&p<3|t&k||y&M)break;
                                ^
examples/graphics/chessboard.c:61:54: style:inconclusive: Boolean expression 'p<3' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
                        if((p==7|!x)&&j==8||!(r&7)-!t&p<3|t&k||y&M)break;
                                                     ^
examples/graphics/chessboard.c:67:48: style:inconclusive: Boolean expression 'i==X' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
                            if(x&1&&v>-64&&i==X&y==Y)
                                               ^
examples/graphics/chessboard.c:75:49: style:inconclusive: Boolean expression '(y&112)+6*k==128' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
                        if(x&1&&(y&112)+6*k==128&p<3)t--; }
                                                ^
examples/graphics/chessboard.c:122:13: warning: Obsolete function 'gets' called. It is recommended to use 'fgets' or 'gets_s' instead. [getsCalled]
            gets(c);
            ^
examples/graphics/chessboard.c:57:22: style: Suspicious condition (assignment + comparison); Clarify expression with parentheses. [clarifyCondition]
                while(r=p>2&r<0?-r:64-"01/@AP@ABPOQ@NR_a@"[++j])
                     ^
examples/graphics/chessboard.c:57:28: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
                while(r=p>2&r<0?-r:64-"01/@AP@ABPOQ@NR_a@"[++j])
                           ^
examples/graphics/chessboard.c:61:33: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
                        if((p==7|!x)&&j==8||!(r&7)-!t&p<3|t&k||y&M)break;
                                ^
examples/graphics/chessboard.c:67:48: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
                            if(x&1&&v>-64&&i==X&y==Y)
                                               ^
examples/graphics/chessboard.c:75:49: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
                        if(x&1&&(y&112)+6*k==128&p<3)t--; }
                                                ^
examples/graphics/chessboard.c:53:23: style: The scope of the variable 'u' can be reduced. [variableScope]
    {   int i=0,j,t,p,u,r,y,m=-C,v;
                      ^
examples/graphics/chessboard.h:231:19: style: Local variable 'b' shadows outer variable [shadowVariable]
  int     x,y,z,a,b;
                  ^
examples/graphics/chessboard.c:51:15: note: Shadowed declaration
    char c[9],b[128]="VSUWTUSV";
              ^
examples/graphics/chessboard.h:231:19: note: Shadow variable
  int     x,y,z,a,b;
                  ^
examples/graphics/chessboard.c:57:32: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
                while(r=p>2&r<0?-r:64-"01/@AP@ABPOQ@NR_a@"[++j])
                               ^
examples/graphics/chessboard.c:62:30: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
                        v=t&k?1:" !!#~#%)"[t&7]-32;
                             ^
examples/graphics/fancychess.h:404:19: style: Local variable 'b' shadows outer variable [shadowVariable]
  int     x,y,z,a,b;
                  ^
examples/graphics/chessboard.c:51:15: note: Shadowed declaration
    char c[9],b[128]="VSUWTUSV";
              ^
examples/graphics/fancychess.h:404:19: note: Shadow variable
  int     x,y,z,a,b;
                  ^
examples/graphics/chessb16.h:107:19: style: Local variable 'b' shadows outer variable [shadowVariable]
  int     x,y,z,a,b;
                  ^
examples/graphics/chessboard.c:51:15: note: Shadowed declaration
    char c[9],b[128]="VSUWTUSV";
              ^
examples/graphics/chessb16.h:107:19: note: Shadow variable
  int     x,y,z,a,b;
                  ^
examples/graphics/ti_chessboard.h:23:1: error: syntax error: ; . _pieces [syntaxError]
._pieces
^
examples/graphics/clock.c:96:2: warning: Obsolete function 'gets' called. It is recommended to use 'fgets' or 'gets_s' instead. [getsCalled]
 gets(hr);
 ^
examples/graphics/clock.c:99:2: warning: scanf() without field width limits can crash with huge input data. [invalidscanf]
 scanf("%s",hr);
 ^
examples/graphics/coswave.c:28:7: style: The scope of the variable 'buf' can be reduced. [variableScope]
int z,buf;
      ^
examples/graphics/csnakes.c:131:9: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        printf("%u - %s\n", x + 1, joystick_type[x]);
        ^
examples/graphics/csnakes.c:143:9: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        printf("%u - %s\n", x + 1, joystick_type[x]);
        ^
examples/graphics/globe.c:280:0: information: Skipping configuration 'VIEW' since the value of 'VIEW' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 view='0'+VIEW;
^
examples/graphics/hangman.c:166:5: warning: scanf() without field width limits can crash with huge input data. [invalidscanf]
    scanf("%s",w);
    ^
examples/graphics/hangman.c:50:5: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
    printf("%c[%u;%uH", 27, xx, yy);
    ^
examples/graphics/hangman.c:50:5: warning: %u in format string (no. 3) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
    printf("%c[%u;%uH", 27, xx, yy);
    ^
examples/graphics/showlib3d.c:111:13: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
            sprintf(buf,"%d frames in 10 seconds",frames);
            ^
examples/graphics/sinwave.c:28:7: style: The scope of the variable 'buf' can be reduced. [variableScope]
int z,buf;
      ^
examples/graphics/smallgfx2.c:8:12: style: The scope of the variable 'a' can be reduced. [variableScope]
    int x, a;
           ^
examples/graphics/snakes.c:148:9: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        printf("%u - %s\n", x + 1, joystick_type[x]);
        ^
examples/graphics/snakes.c:160:9: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        printf("%u - %s\n", x + 1, joystick_type[x]);
        ^
examples/graphics/spritest.c:71:9: style: Unused variable: z [unusedVariable]
int x,y,z;
        ^
examples/graphics/spritest.c:74:7: style: Unused variable: ptr [unusedVariable]
char *ptr;
      ^
examples/graphics/thuemorse.c:30:14: style: Local variable 'i' shadows outer variable [shadowVariable]
    for (int i = 7; i >= 0; i--) {
             ^
examples/graphics/thuemorse.c:24:9: note: Shadowed declaration
int c,d,i;
        ^
examples/graphics/thuemorse.c:30:14: note: Shadow variable
    for (int i = 7; i >= 0; i--) {
             ^
examples/graphics/tinysmile.c:31:13: style: The scope of the variable 'temp' can be reduced. [variableScope]
 char x, y, temp;
            ^
examples/graphics/wide_rez/ex10b.c:41:9: style: Unused variable: l [unusedVariable]
 int c, l;
        ^
examples/graphics/wintest.c:62:15: style: Unused variable: z [unusedVariable]
    int x, y, z;
              ^
examples/graphics/xample.c:124:30: style:inconclusive: Function 'get_GC' argument 2 names different: declaration 'gc' definition 'gcp'. [funcArgNamesDifferent]
void get_GC(Window win, GC **gcp, XFontStruct *font_info)
                             ^
examples/graphics/xample.c:22:30: note: Function 'get_GC' argument 2 names different: declaration 'gc' definition 'gcp'.
void get_GC(Window win, GC **gc, XFontStruct *font_info);
                             ^
examples/graphics/xample.c:124:30: note: Function 'get_GC' argument 2 names different: declaration 'gc' definition 'gcp'.
void get_GC(Window win, GC **gcp, XFontStruct *font_info)
                             ^
examples/micro8085/micro8085.c:132:11: style: The scope of the variable 'u8TmpLen' can be reduced. [variableScope]
  uint8_t u8TmpLen, i, ch;
          ^
examples/microbee/dstar.h:110:1: error: syntax error: ; . _levels [syntaxError]
._levels
^
examples/microbee/dstar.h:52:1: error: syntax error: ; . _sprites [syntaxError]
._sprites
^
examples/microman.c:630:5: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
    sprintf (scoretxt,"%06u",score);
    ^
examples/microman.c:797:7: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
      printf("%u - %s\n",x+1,joystick_type[x]);
      ^
examples/msx/ex10.c:34:16: style: The scope of the variable 'i' can be reduced. [variableScope]
 unsigned char i;
               ^
examples/msx/ex10.c:33:9: style: Unused variable: l [unusedVariable]
 int c, l;
        ^
examples/msx/ex10b.c:35:9: style: Unused variable: l [unusedVariable]
 int c, l;
        ^
examples/msx/ex11.c:152:17: warning: Comparison of a boolean expression with an integer other than 0 or 1. [compareBoolExpressionWithInt]
 while (!getk() != 'q' ) {
                ^
examples/msx/ex11.c:48:9: style: The scope of the variable 'c' can be reduced. [variableScope]
 double c;
        ^
examples/msx/ex11.c:113:10: style: Local variable 'sbuffer' shadows outer variable [shadowVariable]
 u_char* sbuffer = (u_char*)malloc(MODE2_MAX);
         ^
examples/msx/ex11.c:42:10: note: Shadowed declaration
 u_char *sbuffer;
         ^
examples/msx/ex11.c:113:10: note: Shadow variable
 u_char* sbuffer = (u_char*)malloc(MODE2_MAX);
         ^
examples/msx/ex2.c:28:11: style: The scope of the variable 'addr' can be reduced. [variableScope]
 uint16_t addr;
          ^
examples/msx/ex3.c:27:11: style: The scope of the variable 'addr' can be reduced. [variableScope]
 uint16_t addr;
          ^
examples/msx/ex3.c:28:9: style: The scope of the variable 'l' can be reduced. [variableScope]
 int c, l;
        ^
examples/msx/ex4.c:43:9: style: The scope of the variable 'a' can be reduced. [variableScope]
 double a;
        ^
examples/msx/ex5.c:47:9: style: The scope of the variable 'a' can be reduced. [variableScope]
 double a;
        ^
examples/msx/ex6.c:28:6: style: The scope of the variable 'd' can be reduced. [variableScope]
 int d;
     ^
examples/msx/ex7.c:347:33: style: The scope of the variable 'rckt' can be reduced. [variableScope]
 rocket_t rockets[MAX_ROCKET], *rckt;
                                ^
examples/msx/ex8.c:39:12: style: The scope of the variable 'addr' can be reduced. [variableScope]
 int x, y, addr;
           ^
examples/msx/ex8.c:55:6: style: The scope of the variable 'asc' can be reduced. [variableScope]
 int asc, x, y, addr;
     ^
examples/msx/vpoke.c:61:6: style: Unused variable: i [unusedVariable]
 int i;
     ^
examples/nabu/retronet.c:70:3: warning: %lu in format string (no. 1) requires 'unsigned long' but the argument type is 'unsigned int'. [invalidPrintfArgType_uint]
  printf("our file length: %lu\n",size);
  ^
examples/nabu/retronet.c:75:3: warning: %ld in format string (no. 1) requires 'long' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
  printf("read position is: %ld\n",newPos);
  ^
examples/nabu/retronet.c:119:3: warning: %ld in format string (no. 1) requires 'long' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
  printf("read response length: %ld\n",size);
  ^
examples/nabu/retronet.c:133:5: warning: %ld in format string (no. 1) requires 'long' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
    printf("File already exists and is %ld bytes\n",testSize);
    ^
examples/osca/comp.c:70:4: warning: %lu in format string (no. 2) requires 'unsigned long' but the argument type is 'signed long'. [invalidPrintfArgType_uint]
   printf("%s pos %lu char %u block %u line %u = %u; %s = %u\n",
   ^
examples/osca/comp.c:70:4: warning: %u in format string (no. 3) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
   printf("%s pos %lu char %u block %u line %u = %u; %s = %u\n",
   ^
examples/osca/comp.c:70:4: warning: %u in format string (no. 4) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
   printf("%s pos %lu char %u block %u line %u = %u; %s = %u\n",
   ^
examples/osca/comp.c:70:4: warning: %u in format string (no. 5) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
   printf("%s pos %lu char %u block %u line %u = %u; %s = %u\n",
   ^
examples/osca/comp.c:70:4: warning: %u in format string (no. 6) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
   printf("%s pos %lu char %u block %u line %u = %u; %s = %u\n",
   ^
examples/osca/comp.c:70:4: warning: %u in format string (no. 8) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
   printf("%s pos %lu char %u block %u line %u = %u; %s = %u\n",
   ^
examples/osca/comp.c:74:3: warning: %lu in format string (no. 1) requires 'unsigned long' but the argument type is 'signed long'. [invalidPrintfArgType_uint]
  printf("Files differ at position %lu, character %u, block %u, line %u.\n",
  ^
examples/osca/comp.c:74:3: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
  printf("Files differ at position %lu, character %u, block %u, line %u.\n",
  ^
examples/osca/comp.c:74:3: warning: %u in format string (no. 3) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
  printf("Files differ at position %lu, character %u, block %u, line %u.\n",
  ^
examples/osca/comp.c:74:3: warning: %u in format string (no. 4) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
  printf("Files differ at position %lu, character %u, block %u, line %u.\n",
  ^
examples/osca/sort.c:66:14: error: Array 'cn[6]' accessed at index 6, which is out of bounds. [arrayIndexOutOfBounds]
          {cn[j]=arg[++i];
             ^
examples/osca/sort.c:98:11: style: The scope of the variable 'len' can be reduced. [variableScope]
     int  len, nlines;
          ^
examples/osca/sort.c:140:11: style: The scope of the variable 's1' can be reduced. [variableScope]
     char s1, t1;
          ^
examples/osca/sort.c:140:15: style: The scope of the variable 't1' can be reduced. [variableScope]
     char s1, t1;
              ^
examples/osca/sort.c:243:11: style: The scope of the variable 'i' can be reduced. [variableScope]
     int  i, test, foldflag, keyflag;   /* misc  */
          ^
examples/osca/sort.c:243:14: style: The scope of the variable 'test' can be reduced. [variableScope]
     int  i, test, foldflag, keyflag;   /* misc  */
             ^
examples/osca/sort.c:245:12: style: The scope of the variable 's' can be reduced. [variableScope]
     char *s;
           ^
examples/osca/wc.c:41:6: style: Unused variable: x [unusedVariable]
 int x,i, nfiles;
     ^
examples/osca/wc.c:43:7: style: Unused variable: gotcha [unusedVariable]
 int  gotcha;
      ^
examples/osca/wc.c:73:11: error: Uninitialized variable: gotcha [uninitvar]
      if (gotcha == 0)
          ^
examples/osca/wc.c:73:11: error: Uninitialized variable: gotcha [uninitvar]
      if (gotcha == 0)
          ^
examples/osca/wc.c:58:28: note: Assuming condition is false
   if ((x=dir_move_first())!=0) return(0);
                           ^
examples/osca/wc.c:73:11: note: Uninitialized variable: gotcha
      if (gotcha == 0)
          ^
examples/osca/wc.c:43:7: style: Variable 'gotcha' is not assigned a value. [unassignedVariable]
 int  gotcha;
      ^
examples/othello.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 23 configurations. Use --force to check all configurations. [toomanyconfigs]

^
examples/othello.c:621:3: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
  printf(" %u",i+1);
  ^
examples/othello.c:646:2: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
 printf("%u-%u",i = cntbrd(b,his), j=cntbrd(b,mine));
 ^
examples/othello.c:646:2: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
 printf("%u-%u",i = cntbrd(b,his), j=cntbrd(b,mine));
 ^
examples/othello.c:1017:12: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
  if (i>0) printf(" You won by %u\n",i);
           ^
examples/othello.c:1018:17: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
  else if (i<0) printf(" You lost by %u\n",-i);
                ^
examples/othello.c:815:10: style: The scope of the variable 'c' can be reduced. [variableScope]
 int i,k,c;
         ^
examples/othello.c:699:9: error: Uninitialized variable: c [uninitvar]
 while (c != '\n' && c != 4) c= getchar();
        ^
examples/othello.c:297:1: error: syntax error: ; . _frame [syntaxError]
._frame
^
examples/othello.c:206:1: error: syntax error: ; . _whitepiece [syntaxError]
._whitepiece
^
examples/pacman/dstar.h:40:1: error: syntax error: ; . _levels [syntaxError]
._levels
^
examples/px8/adcvrt.c:19:3: warning: %d in format string (no. 2) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
  printf("Analog input:\tADCVRT: %d\t\t7508: %d\n", adcvrt(CH_ANALOG) >> 2, status >> 2);
  ^
examples/px8/adcvrt.c:22:3: warning: %d in format string (no. 2) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
  printf("Barcode reader:\tADCVRT: %d\t\t7508: %d\n", adcvrt(CH_BARCODE) >> 2, status >> 2);
  ^
examples/px8/adcvrt.c:35:3: warning: %d in format string (no. 3) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
  printf("Battery:\tADCVRT: %d.%dv\t\t7508: %d.%dv\n", voltage / 10, voltage % 10, status / 10, status % 10);
  ^
examples/px8/adcvrt.c:35:3: warning: %d in format string (no. 4) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
  printf("Battery:\tADCVRT: %d.%dv\t\t7508: %d.%dv\n", voltage / 10, voltage % 10, status / 10, status % 10);
  ^
examples/px8/adcvrt.c:50:5: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
    printf("%d.%d", temp_x10 / 10, temp_x10 % 10);
    ^
examples/px8/adcvrt.c:50:5: warning: %d in format string (no. 2) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
    printf("%d.%d", temp_x10 / 10, temp_x10 % 10);
    ^
examples/rcmx000/example.c:14:8: style: The scope of the variable 'ch' can be reduced. [variableScope]
  char ch;
       ^
examples/rcmx000/iolib.c:67:17: warning: Found suspicious operator ',' [constStatement]
  ld (_ioi_data),a;
                ^
examples/rcmx000/iolib.c:91:10: warning: Found suspicious operator ',' [constStatement]
  ld (hl),a ;
         ^
examples/rcmx000/iolib.c:133:40: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
  return (  iolib_inb(addr) & (1<<bit) ? 1 : 0);
                                       ^
examples/rcmx000/iolib.c:61:8: style: Unused variable: hl [unusedVariable]
  push hl;
       ^
examples/rcmx000/iolib.c:62:8: style: Unused variable: af [unusedVariable]
  push af;
       ^
examples/rcmx000/iolib.c:66:6: style: Variable 'a' is not assigned a value. [unassignedVariable]
  ld a,(hl);
     ^
examples/rcmx000/iolib.c:69:7: style: Unused variable: af [unusedVariable]
  pop af ;
      ^
examples/rcmx000/iolib.c:70:7: style: Unused variable: hl [unusedVariable]
  pop hl ;
      ^
examples/rcmx000/iolib.c:84:8: style: Unused variable: hl [unusedVariable]
  push hl ;
       ^
examples/rcmx000/iolib.c:85:8: style: Unused variable: af [unusedVariable]
  push af ;
       ^
examples/rcmx000/iolib.c:88:6: style: Variable 'a' is not assigned a value. [unassignedVariable]
  ld a,(_ioi_data);
     ^
examples/rcmx000/iolib.c:93:7: style: Unused variable: af [unusedVariable]
  pop af ;
      ^
examples/rcmx000/iolib.c:94:7: style: Unused variable: hl [unusedVariable]
  pop hl ;
      ^
examples/rcmx000/iolib_twinkle3000.c:39:1: style: Label 'wait' is not used. [unusedLabel]
wait:
^
examples/rcmx000/iolib_twinkle3000.c:33:10: style: Unused variable: de [unusedVariable]
    push de ;
         ^
examples/rcmx000/iolib_twinkle3000.c:34:10: style: Unused variable: hl [unusedVariable]
    push hl ;
         ^
examples/rcmx000/iolib_twinkle3000.c:36:8: style: Unused variable: b [unusedVariable]
    ld b,h ;
       ^
examples/rcmx000/iolib_twinkle3000.c:36:10: style: Unused variable: h [unusedVariable]
    ld b,h ;
         ^
examples/rcmx000/iolib_twinkle3000.c:37:8: style: Unused variable: c [unusedVariable]
    ld c,l ; Save physical address to RTC0R in c ;
       ^
examples/rcmx000/iolib_twinkle3000.c:37:10: style: Unused variable: l [unusedVariable]
    ld c,l ; Save physical address to RTC0R in c ;
         ^
examples/rcmx000/iolib_twinkle3000.c:44:8: style: Unused variable: a [unusedVariable]
    ld a,(bc)  ; RTC byte 0 ;
       ^
examples/rcmx000/iolib_twinkle3000.c:45:8: style: Unused variable: l [unusedVariable]
    ld l,a ;
       ^
examples/rcmx000/iolib_twinkle3000.c:45:10: style: Unused variable: a [unusedVariable]
    ld l,a ;
         ^
examples/rcmx000/iolib_twinkle3000.c:48:8: style: Unused variable: a [unusedVariable]
    ld a,(bc)           ; RTC byte 1 ;
       ^
examples/rcmx000/iolib_twinkle3000.c:49:8: style: Unused variable: h [unusedVariable]
    ld h,a ;
       ^
examples/rcmx000/iolib_twinkle3000.c:49:10: style: Unused variable: a [unusedVariable]
    ld h,a ;
         ^
examples/rcmx000/iolib_twinkle3000.c:50:9: style: Unused variable: bc [unusedVariable]
    dec bc ;
        ^
examples/rcmx000/iolib_twinkle3000.c:52:8: style: Unused variable: de [unusedVariable]
    ld de,7fffh ;
       ^
examples/rcmx000/iolib_twinkle3000.c:53:21: style: Unused variable: hl [unusedVariable]
    defb 0dch ; and hl,de ;
                    ^
examples/rcmx000/iolib_twinkle3000.c:53:24: style: Unused variable: de [unusedVariable]
    defb 0dch ; and hl,de ;
                       ^
examples/rcmx000/iolib_twinkle3000.c:54:8: style: Unused variable: nz [unusedVariable]
    jr nz, wait ;
       ^
examples/rcmx000/iolib_twinkle3000.c:54:12: style: Unused variable: wait [unusedVariable]
    jr nz, wait ;
           ^
examples/rcmx000/iolib_twinkle3000.c:56:9: style: Unused variable: hl [unusedVariable]
    pop hl ;
        ^
examples/rcmx000/iolib_twinkle3000.c:57:9: style: Unused variable: de [unusedVariable]
    pop de ;
        ^
examples/rcmx000/iolib_twinkle3000.c:58:9: style: Unused variable: bc [unusedVariable]
    pop bc ;
        ^
examples/rcmx000/iolib_twinkle3000.c:66:9: style: Unused variable: i [unusedVariable]
    int i;
        ^
examples/rcmx000/twinkle2000.c:54:1: style: Label 'wait' is not used. [unusedLabel]
wait:
^
examples/rcmx000/twinkle2000.c:15:13: warning: Found suspicious operator ',' [constStatement]
    ld (24h),a ;
            ^
examples/rcmx000/twinkle2000.c:25:14: warning: Found suspicious operator ',' [constStatement]
    ld (030h),a ;
             ^
examples/rcmx000/twinkle2000.c:34:14: warning: Found suspicious operator ',' [constStatement]
    ld (030h),a ;
             ^
examples/rcmx000/twinkle2000.c:13:8: style: Variable 'a' is not assigned a value. [unassignedVariable]
    ld a,84h ;
       ^
examples/rcmx000/twinkle2000.c:23:8: style: Variable 'a' is not assigned a value. [unassignedVariable]
    ld a,00h  ; leds on ;
       ^
examples/rcmx000/twinkle2000.c:23:22: style: Unused variable: on [unusedVariable]
    ld a,00h  ; leds on ;
                     ^
examples/rcmx000/twinkle2000.c:32:8: style: Variable 'a' is not assigned a value. [unassignedVariable]
    ld a,0ffh  ; leds off ;
       ^
examples/rcmx000/twinkle2000.c:32:23: style: Unused variable: off [unusedVariable]
    ld a,0ffh  ; leds off ;
                      ^
examples/rcmx000/twinkle2000.c:44:8: style: Unused variable: hl [unusedVariable]
    ld hl,(2)  ; RTC byte 0-1 ;
       ^
examples/rcmx000/twinkle2000.c:51:10: style: Unused variable: de [unusedVariable]
    push de ;
         ^
examples/rcmx000/twinkle2000.c:52:10: style: Unused variable: hl [unusedVariable]
    push hl ;
         ^
examples/rcmx000/twinkle2000.c:59:8: style: Unused variable: hl [unusedVariable]
    ld hl,(2)  ; RTC byte 0-1 ;
       ^
examples/rcmx000/twinkle2000.c:61:8: style: Unused variable: de [unusedVariable]
    ld de,07fffh ;
       ^
examples/rcmx000/twinkle2000.c:62:21: style: Unused variable: hl [unusedVariable]
    defb 0dch ; and hl,de ;
                    ^
examples/rcmx000/twinkle2000.c:62:24: style: Unused variable: de [unusedVariable]
    defb 0dch ; and hl,de ;
                       ^
examples/rcmx000/twinkle2000.c:63:8: style: Unused variable: nz [unusedVariable]
    jr nz, wait ;
       ^
examples/rcmx000/twinkle2000.c:63:12: style: Unused variable: wait [unusedVariable]
    jr nz, wait ;
           ^
examples/rcmx000/twinkle2000.c:65:9: style: Unused variable: hl [unusedVariable]
    pop hl ;
        ^
examples/rcmx000/twinkle2000.c:66:9: style: Unused variable: de [unusedVariable]
    pop de ;
        ^
examples/rcmx000/twinkle2000.c:74:9: style: Unused variable: i [unusedVariable]
    int i;
        ^
examples/rcmx000/twinkle3000.c:51:1: style: Label 'wait' is not used. [unusedLabel]
wait:
^
examples/rcmx000/twinkle3000.c:17:14: warning: Found suspicious operator ',' [constStatement]
    ld (0x4e),a ;
             ^
examples/rcmx000/twinkle3000.c:21:14: warning: Found suspicious operator ',' [constStatement]
    ld (0x4f),a ;
             ^
examples/rcmx000/twinkle3000.c:31:14: warning: Found suspicious operator ',' [constStatement]
    ld (0x48),a ;
             ^
examples/rcmx000/twinkle3000.c:41:14: warning: Found suspicious operator ',' [constStatement]
    ld (0x48),a ;
             ^
examples/rcmx000/twinkle3000.c:54:11: warning: Found suspicious operator ',' [constStatement]
    ld (2),a  ; Any write triggers transfer ;
          ^
examples/rcmx000/twinkle3000.c:13:18: style: Unused variable: manuals [unusedVariable]
    ; Rabbit3000 manuals ;
                 ^
examples/rcmx000/twinkle3000.c:15:8: style: Variable 'a' is not assigned a value. [unassignedVariable]
    ld a,0 ;
       ^
examples/rcmx000/twinkle3000.c:19:8: style: Variable 'a' is not assigned a value. [unassignedVariable]
    ld a,0ffh ;
       ^
examples/rcmx000/twinkle3000.c:29:8: style: Variable 'a' is not assigned a value. [unassignedVariable]
    ld a,0  ; leds on ;
       ^
examples/rcmx000/twinkle3000.c:29:20: style: Unused variable: on [unusedVariable]
    ld a,0  ; leds on ;
                   ^
examples/rcmx000/twinkle3000.c:39:8: style: Variable 'a' is not assigned a value. [unassignedVariable]
    ld a,0xff  ; leds off ;
       ^
examples/rcmx000/twinkle3000.c:39:23: style: Unused variable: off [unusedVariable]
    ld a,0xff  ; leds off ;
                      ^
examples/rcmx000/twinkle3000.c:48:10: style: Unused variable: de [unusedVariable]
    push de ;
         ^
examples/rcmx000/twinkle3000.c:49:10: style: Unused variable: hl [unusedVariable]
    push hl ;
         ^
examples/rcmx000/twinkle3000.c:56:8: style: Unused variable: hl [unusedVariable]
    ld hl,(2)  ; RTC byte 0-1 ;
       ^
examples/rcmx000/twinkle3000.c:58:8: style: Unused variable: de [unusedVariable]
    ld de,7fffh ;
       ^
examples/rcmx000/twinkle3000.c:59:21: style: Unused variable: hl [unusedVariable]
    defb 0xdc ; and hl,de ;
                    ^
examples/rcmx000/twinkle3000.c:59:24: style: Unused variable: de [unusedVariable]
    defb 0xdc ; and hl,de ;
                       ^
examples/rcmx000/twinkle3000.c:60:8: style: Unused variable: nz [unusedVariable]
    jr nz, wait ;
       ^
examples/rcmx000/twinkle3000.c:60:12: style: Unused variable: wait [unusedVariable]
    jr nz, wait ;
           ^
examples/rcmx000/twinkle3000.c:62:9: style: Unused variable: hl [unusedVariable]
    pop hl ;
        ^
examples/rcmx000/twinkle3000.c:63:9: style: Unused variable: de [unusedVariable]
    pop de ;
        ^
examples/rcmx000/twinkle3000.c:71:9: style: Unused variable: i [unusedVariable]
    int i;
        ^
examples/sam/ansitest.c:33:3: warning: printf format string requires 0 parameters but 1 is given. [wrongPrintfScanfArgNum]
  printf ("A new line\n",27);
  ^
examples/sam/ansitest.c:43:5: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
    printf ("%c[%umFore text color %u.\n",27,x,x);
    ^
examples/sam/ansitest.c:43:5: warning: %u in format string (no. 3) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
    printf ("%c[%umFore text color %u.\n",27,x,x);
    ^
examples/sam/ansitest.c:49:5: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
    printf ("%c[%umBack text color %u.\n",27,x,x);
    ^
examples/sam/ansitest.c:49:5: warning: %u in format string (no. 3) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
    printf ("%c[%umBack text color %u.\n",27,x,x);
    ^
examples/sam/ansitest.c:65:5: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
    printf ("%c[%u;%uH*\n",27,8+x,22+x);
    ^
examples/sam/ansitest.c:65:5: warning: %u in format string (no. 3) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
    printf ("%c[%u;%uH*\n",27,8+x,22+x);
    ^
examples/sam/ansitest.c:66:5: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
    printf ("%c[%u;%uH*\n",27,18-x,22+x);
    ^
examples/sam/ansitest.c:66:5: warning: %u in format string (no. 3) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
    printf ("%c[%u;%uH*\n",27,18-x,22+x);
    ^
examples/sam/cube.c:28:16: style: The scope of the variable 'mx' can be reduced. [variableScope]
        double mx, my, halfangle;
               ^
examples/sam/cube.c:28:20: style: The scope of the variable 'my' can be reduced. [variableScope]
        double mx, my, halfangle;
                   ^
examples/sam/cube.c:29:16: style: The scope of the variable 'cx' can be reduced. [variableScope]
        double cx,cy,cz,sx,sy,sz;
               ^
examples/sam/cube.c:29:19: style: The scope of the variable 'cy' can be reduced. [variableScope]
        double cx,cy,cz,sx,sy,sz;
                  ^
examples/sam/cube.c:29:22: style: The scope of the variable 'cz' can be reduced. [variableScope]
        double cx,cy,cz,sx,sy,sz;
                     ^
examples/sam/cube.c:29:25: style: The scope of the variable 'sx' can be reduced. [variableScope]
        double cx,cy,cz,sx,sy,sz;
                        ^
examples/sam/cube.c:29:28: style: The scope of the variable 'sy' can be reduced. [variableScope]
        double cx,cy,cz,sx,sy,sz;
                           ^
examples/sam/cube.c:29:31: style: The scope of the variable 'sz' can be reduced. [variableScope]
        double cx,cy,cz,sx,sy,sz;
                              ^
examples/sam/cube.c:28:24: style: Unused variable: halfangle [unusedVariable]
        double mx, my, halfangle;
                       ^
examples/sam/dstar.h:16:25: error: syntax error: 1 = [syntaxError]
                        ;1=edge, 2=clear ball 3=moveable ball 4=moveable block
                        ^
examples/sam/enigma.c:34:20: style: The scope of the variable 'ch' can be reduced. [variableScope]
     unsigned int  ch;
                   ^
examples/sam/gfx.c:10:17: style: Unused variable: j [unusedVariable]
        int     j,i;
                ^
examples/sam/keyget.c:4:17: style: The scope of the variable 'a' can be reduced. [variableScope]
  unsigned char a;
                ^
examples/sam/smile.c:34:13: style: The scope of the variable 'temp' can be reduced. [variableScope]
 char x, y, temp;
            ^
examples/sms/3dcity/engine/enemy_manager.c:26:30: style: The scope of the variable 'delay' can be reduced. [variableScope]
 unsigned char index, baser, delay, enemy, space, value;
                             ^
examples/sms/3dcity/engine/enemy_manager.c:26:37: style: The scope of the variable 'enemy' can be reduced. [variableScope]
 unsigned char index, baser, delay, enemy, space, value;
                                    ^
examples/sms/3dcity/engine/enemy_manager.c:26:44: style: The scope of the variable 'space' can be reduced. [variableScope]
 unsigned char index, baser, delay, enemy, space, value;
                                           ^
examples/sms/3dcity/engine/enemy_manager.c:26:51: style: The scope of the variable 'value' can be reduced. [variableScope]
 unsigned char index, baser, delay, enemy, space, value;
                                                  ^
examples/sms/3dcity/screen/level_screen.c:37:2: warning: Return value of function rand() is not used. [ignoredReturnValue]
 rand();
 ^
examples/sms/3dcity/screen/play_screen.c:81:16: style: The scope of the variable 'check' can be reduced. [variableScope]
 unsigned char check, detectX, detectY, missY, overX;
               ^
examples/sms/3dcity/screen/play_screen.c:81:23: style: The scope of the variable 'detectX' can be reduced. [variableScope]
 unsigned char check, detectX, detectY, missY, overX;
                      ^
examples/sms/3dcity/screen/play_screen.c:81:32: style: The scope of the variable 'detectY' can be reduced. [variableScope]
 unsigned char check, detectX, detectY, missY, overX;
                               ^
examples/sms/3dcity/screen/play_screen.c:81:41: style: The scope of the variable 'missY' can be reduced. [variableScope]
 unsigned char check, detectX, detectY, missY, overX;
                                        ^
examples/sms/3dcity/screen/title_screen.c:31:2: warning: Return value of function rand() is not used. [ignoredReturnValue]
 rand();
 ^
examples/sms/chicken.c:41:23: style: The scope of the variable 'j' can be reduced. [variableScope]
    unsigned char  i, j;
                      ^
examples/sms/chicken.c:48:34: style: The scope of the variable 'p' can be reduced. [variableScope]
    int raster[10], speeds[10], *p, *p2;
                                 ^
examples/sms/libctest.c:11:8: style: Variable 'y' is assigned a value that is never used. [unreadVariable]
 int y = 0;
       ^
examples/sms/libpsgtest.c:20:26: style: The scope of the variable 'palette' can be reduced. [variableScope]
    static unsigned char palette = 0;
                         ^
examples/sms/pngmstr2.c:450:6: style: The scope of the variable 'joy1' can be reduced. [variableScope]
 int joy1;
     ^
examples/sms/pngmstr2.c:451:6: style: The scope of the variable 'incr' can be reduced. [variableScope]
 int incr, lim;
     ^
examples/sms/pngmstr2.c:451:12: style: Unused variable: lim [unusedVariable]
 int incr, lim;
           ^
examples/sms/pongmstr.c:397:6: style: The scope of the variable 'joy1' can be reduced. [variableScope]
 int joy1;
     ^
examples/sms/pongmstr.c:398:6: style: The scope of the variable 'incr' can be reduced. [variableScope]
 int incr, lim;
     ^
examples/sms/pongmstr.c:398:12: style: Unused variable: lim [unusedVariable]
 int incr, lim;
           ^
examples/sms/test.c:45:7: style: The scope of the variable 'i' can be reduced. [variableScope]
 int  i, j;
      ^
examples/sms/test.c:45:10: style: The scope of the variable 'j' can be reduced. [variableScope]
 int  i, j;
         ^
examples/sorcerer/dstar.h:54:20: error: syntax error: 1 = [syntaxError]
 defb    @01111111 ;1=edge, (left)
                   ^
examples/sos/sosinfo.c:118:4: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
   printf("    Guessing.. <=%uK?\n",(0xfff0-0x3000)/1024);
   ^
examples/sound/clicktest.c:11:6: style: Unused variable: x [unusedVariable]
 int x;
     ^
examples/sound/fx.c:9:3: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
  printf("bit_fx(%u)\n",i);
  ^
examples/sound/fx.c:13:3: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
  printf("bit_fx2(%u)\n",i);
  ^
examples/sound/fx.c:17:3: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
  printf("bit_fx3(%u)\n",i);
  ^
examples/sound/fx.c:21:3: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
  printf("bit_fx4(%u)\n",i);
  ^
examples/sound/fx.c:25:3: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
  printf("bit_fx5(%u)\n",i);
  ^
examples/sound/psglib/main.c:30:11: warning: Identical condition 'k&MOVE_DOWN', second condition is always false [identicalConditionAfterEarlyExit]
   if ( k & MOVE_DOWN ) return '2';
          ^
examples/sound/psglib/main.c:29:11: note: If condition 'k&MOVE_DOWN' is true, the function will return/exit
   if ( k & MOVE_DOWN ) return '2';
          ^
examples/sound/psglib/main.c:30:11: note: Testing identical condition 'k&MOVE_DOWN'
   if ( k & MOVE_DOWN ) return '2';
          ^
examples/sound/psglib/main.c:32:11: warning: Identical condition 'k&MOVE_FIRE1', second condition is always false [identicalConditionAfterEarlyExit]
   if ( k & MOVE_FIRE1 ) return ' ';
          ^
examples/sound/psglib/main.c:31:11: note: If condition 'k&MOVE_FIRE1' is true, the function will return/exit
   if ( k & MOVE_FIRE1 ) return 's';
          ^
examples/sound/psglib/main.c:32:11: note: Testing identical condition 'k&MOVE_FIRE1'
   if ( k & MOVE_FIRE1 ) return ' ';
          ^
examples/sound/psgtest.c:29:11: style: Unused variable: x [unusedVariable]
    float x;
          ^
examples/sound/wyz/main.c:95:14: style: Condition 'k!=0' is always false [knownConditionTrueFalse]
      if ( k != 0 ) printf("%c \n",k);
             ^
examples/sound/wyz/main.c:94:15: note: Assignment 'k=0', assigned value is 0
      int k = getk();
              ^
examples/sound/wyz/main.c:95:14: note: Condition 'k!=0' is always false
      if ( k != 0 ) printf("%c \n",k);
             ^
examples/spectrum/ccoswave.c:34:8: style: The scope of the variable 'buf' can be reduced. [variableScope]
char z,buf;
       ^
examples/spectrum/csprite.c:39:1: error: syntax error: ; . _mysprite [syntaxError]
._mysprite
^
examples/spectrum/dstar.h:16:25: error: syntax error: 1 = [syntaxError]
                        ;1=edge, 2=clear ball 3=moveable ball 4=moveable block
                        ^
examples/spectrum/ex10b.c:31:9: style: Unused variable: l [unusedVariable]
 int c, l;
        ^
examples/spectrum/gfx.c:29:12: style: The scope of the variable 'j' can be reduced. [variableScope]
    int i, j, k, l = 0;
           ^
examples/ticalc/ansitest.c:33:5: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
    printf ("%c[%u;%uH*\n",27,1+x,21+x);
    ^
examples/ticalc/ansitest.c:33:5: warning: %u in format string (no. 3) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
    printf ("%c[%u;%uH*\n",27,1+x,21+x);
    ^
examples/ticalc/ansitest.c:34:5: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
    printf ("%c[%u;%uH*\n",27,5-x,21+x);
    ^
examples/ticalc/ansitest.c:34:5: warning: %u in format string (no. 3) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
    printf ("%c[%u;%uH*\n",27,5-x,21+x);
    ^
examples/ticalc/dstar.h:53:20: error: syntax error: 1 = [syntaxError]
 defb    @01111000 ;1=edge,
                   ^
examples/ticalc/enigma.c:31:16: style: The scope of the variable 'ch' can be reduced. [variableScope]
 unsigned int  ch;
               ^
examples/ticalc/graygfx.c:10:7: style: The scope of the variable 'a' can be reduced. [variableScope]
int x,a;
      ^
examples/ticalc/smile.c:34:13: style: The scope of the variable 'temp' can be reduced. [variableScope]
 char x, y, temp;
            ^
examples/ticalc/spritest.c:66:10: style: Unused variable: z [unusedVariable]
 int x,y,z;
         ^
examples/ticalc/spritest.c:69:8: style: Unused variable: ptr [unusedVariable]
 char *ptr;
       ^
examples/tiki100/mandel.c:76:11: error: Array 'palette[14]' accessed at index 15, which is out of bounds. [arrayIndexOutOfBounds]
   palette[x]=x+k;
          ^
examples/tiki100/mandel.c:75:9: style: Variable 'x' is reassigned a value before the old one has been used. [redundantAssignment]
  for (x=0; x<16; x++)
        ^
examples/tiki100/mandel.c:74:4: note: x is assigned
  x=palette[0];
   ^
examples/tiki100/mandel.c:75:9: note: x is overwritten
  for (x=0; x<16; x++)
        ^
examples/trs80/dct.c:117:4: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
   printf("%d", dct->dct_hard ? dct->dct_haddr : dct->dct_faddr);
   ^
examples/trs80/dct.c:120:5: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
    printf(", %d head(s)", dct->dct_head + 1);
    ^
examples/trs80/dct.c:130:4: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
   printf("\tCylinders %u, directory cylinder %u\n",
   ^
examples/trs80/dct.c:130:4: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
   printf("\tCylinders %u, directory cylinder %u\n",
   ^
examples/trs80/dct.c:134:4: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
   printf("\tSectors per cylinder %d\n",
   ^
examples/trs80/dct.c:136:4: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
   printf("\tGranules per cylinder %d\n",
   ^
examples/trs80/dct.c:138:4: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
   printf("\tSectors per granule %d\n", dct->dct_spg + 1);
   ^
examples/trs80/splitlib.c:125:40: error: syntax error [syntaxError]
    ADD  A,A             ; shift bit # left 3x
                                       ^
examples/vz/dstar.h:16:25: error: syntax error: 1 = [syntaxError]
                        ;1=edge, 2=clear ball 3=moveable ball 4=moveable block
                        ^
examples/wall.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 17 configurations. Use --force to check all configurations. [toomanyconfigs]

^
examples/wall.c:305:2: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
 sprintf (scoretxt,"%05u",tt*1000+t);
 ^
examples/wall.c:782:3: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
  printf("%c\n\n Score: %u ",12,tt*1000+t);
  ^
examples/wall.c:437:4: warning: Label 'l_190' is not used. There is #if in function body so the label might be used in code that is removed by the preprocessor. Should this be a 'case' of the enclosing switch()? [unusedLabelSwitchConfiguration]
   l_190:
   ^
examples/wall.c:770:3: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
  sprintf (scoretxt,"%05u",tt*1000+t);
  ^
examples/wall.c:526:4: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
   printf("    %u - %s\n\n",k+1,joystick_type[k]);
   ^
examples/z88/ansitest.c:28:5: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
    printf ("%c[%umFore text color %u.\n",27,x,x);
    ^
examples/z88/ansitest.c:28:5: warning: %u in format string (no. 3) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
    printf ("%c[%umFore text color %u.\n",27,x,x);
    ^
examples/z88/ansitest.c:33:5: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
    printf ("%c[%umBack text color %u.\n",27,x,x);
    ^
examples/z88/ansitest.c:33:5: warning: %u in format string (no. 3) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
    printf ("%c[%umBack text color %u.\n",27,x,x);
    ^
examples/z88/ansitest.c:48:5: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
    printf ("%c[%u;%uH*\n",27,10+x,25+x);
    ^
examples/z88/ansitest.c:48:5: warning: %u in format string (no. 3) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
    printf ("%c[%u;%uH*\n",27,10+x,25+x);
    ^
examples/z88/ansitest.c:49:5: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
    printf ("%c[%u;%uH*\n",27,20-x,25+x);
    ^
examples/z88/ansitest.c:49:5: warning: %u in format string (no. 3) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
    printf ("%c[%u;%uH*\n",27,20-x,25+x);
    ^
examples/z88/cube.c:56:15: style: The scope of the variable 'mx' can be reduced. [variableScope]
        FLOAT mx, my, halfangle;
              ^
examples/z88/cube.c:56:19: style: The scope of the variable 'my' can be reduced. [variableScope]
        FLOAT mx, my, halfangle;
                  ^
examples/z88/cube.c:57:15: style: The scope of the variable 'cx' can be reduced. [variableScope]
        FLOAT cx,cy,cz,sx,sy,sz;
              ^
examples/z88/cube.c:57:18: style: The scope of the variable 'cy' can be reduced. [variableScope]
        FLOAT cx,cy,cz,sx,sy,sz;
                 ^
examples/z88/cube.c:57:21: style: The scope of the variable 'cz' can be reduced. [variableScope]
        FLOAT cx,cy,cz,sx,sy,sz;
                    ^
examples/z88/cube.c:57:24: style: The scope of the variable 'sx' can be reduced. [variableScope]
        FLOAT cx,cy,cz,sx,sy,sz;
                       ^
examples/z88/cube.c:57:27: style: The scope of the variable 'sy' can be reduced. [variableScope]
        FLOAT cx,cy,cz,sx,sy,sz;
                          ^
examples/z88/cube.c:57:30: style: The scope of the variable 'sz' can be reduced. [variableScope]
        FLOAT cx,cy,cz,sx,sy,sz;
                             ^
examples/z88/cube.c:56:23: style: Unused variable: halfangle [unusedVariable]
        FLOAT mx, my, halfangle;
                      ^
examples/z88/define.c:66:13: style: Local variable 'l' shadows outer variable [shadowVariable]
 static int l;  /* Dumped at end with other statics */
            ^
examples/z88/define.c:41:7: note: Shadowed declaration
char *l[3]={"Hello","Hello"}; /* correctly stored and represented (litq) */
      ^
examples/z88/define.c:66:13: note: Shadow variable
 static int l;  /* Dumped at end with other statics */
            ^
examples/z88/define.c:67:13: style: Local variable 'k' shadows outer variable [shadowVariable]
 static int k=2;  /* Dumped as defw */
            ^
examples/z88/define.c:39:6: note: Shadowed declaration
char k[]="Hello"; /* dumped where it is */
     ^
examples/z88/define.c:67:13: note: Shadow variable
 static int k=2;  /* Dumped as defw */
            ^
examples/z88/define.c:68:15: style: Local variable 'j' shadows outer variable [shadowVariable]
 static char *j="Hello"; /* Stored in literal queue */
              ^
examples/z88/define.c:36:7: note: Shadowed declaration
char *j={"Hello"}; /* stored in literal queue */
      ^
examples/z88/define.c:68:15: note: Shadow variable
 static char *j="Hello"; /* Stored in literal queue */
              ^
examples/z88/dstar.h:16:25: error: syntax error: 1 = [syntaxError]
                        ;1=edge, 2=clear ball 3=moveable ball 4=moveable block
                        ^
examples/z88/farmalloc.c:38:2: warning: %ld in format string (no. 1) requires 'long' but the argument type is 'unsigned long'. [invalidPrintfArgType_sint]
 printf("Requesting %ld bytes of storage...",SIZE);
 ^
examples/z88/farmalloc.c:32:7: style: Unused variable: buffer [unusedVariable]
 char buffer[80]; /* Buffer for us to work in */
      ^
examples/z88/farmalloc.c:33:8: style: Unused variable: fp [unusedVariable]
 FILE *fp;
       ^
examples/z88/gfx.c:10:9: style: Unused variable: j [unusedVariable]
    int j, i;
        ^
examples/z88/rpn.c:81:5: warning: Obsolete function 'gets' called. It is recommended to use 'fgets' or 'gets_s' instead. [getsCalled]
    gets(s);
    ^
examples/z88/wc.c:0:0: error: Internal Error. MathLib::normalizeCharacterLiteral: Unhandled char constant '\l'. [cppcheckError]

^
examples/z88/wc.c:0:0: note: Internal Error. MathLib::normalizeCharacterLiteral: Unhandled char constant '\l'.

^
examples/z88/wc.c:0:0: note: Internal Error. MathLib::normalizeCharacterLiteral: Unhandled char constant '\l'.

^
examples/zx80/clock.c:41:2: warning: Obsolete function 'gets' called. It is recommended to use 'fgets' or 'gets_s' instead. [getsCalled]
 gets(hr);
 ^
examples/zx80/clock.c:44:2: warning: scanf() without field width limits can crash with huge input data. [invalidscanf]
 scanf("%s",hr);
 ^
examples/zx81/dstar.h:77:20: error: syntax error: 1 = [syntaxError]
 defb    @01111111 ;1=edge, (left)
                   ^
examples/zx81/dstar.c:156:46: error: There is an unknown macro here somewhere. Configuration is required. If border is a macro then please configure it. [unknownMacro]
 ld a,32+16+8+5  ; 8="attribute file" mode, (border 7)
                                             ^
examples/zx81/dstar.h:225:1: error: syntax error: ; . _levels [syntaxError]
._levels
^
examples/zx81/dstar.h:227:10: error: syntax error [syntaxError]
 defb    @01010101,@01010101,@01010101,@01010101
         ^
examples/zx81/ex10b.c:31:9: style: Unused variable: l [unusedVariable]
 int c, l;
        ^
examples/zx81/horse.c:208:16: style:inconclusive: Boolean expression '!flg' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
    if (getk() & !flg) { speed/=2; flg=1; }
               ^
examples/zx81/horse.c:208:16: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
    if (getk() & !flg) { speed/=2; flg=1; }
               ^
examples/zx81/horse.c:168:19: style: Label 'picture' is not used. [unusedLabel]
 push de        ; picture: current frame data
                  ^
examples/zx81/horse.c:175:19: style: Label 'picture' is not used. [unusedLabel]
 ld bc,416      ; picture: single frame size
                  ^
examples/zx81/horse.c:193:12: style: Unused variable: a [unusedVariable]
 int x, y, a ,b;
           ^
examples/zx81/horse.c:193:15: style: Unused variable: b [unusedVariable]
 int x, y, a ,b;
              ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:132:6: style: The scope of the variable 'n' can be reduced. [variableScope]
 int n;
     ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:147:9: style: The scope of the variable 't' can be reduced. [variableScope]
 int n, t;
        ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:372:6: style: The scope of the variable 'ii' can be reduced. [variableScope]
 int ii, lastwhite, lastred;
     ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:441:12: style: The scope of the variable 'nn' can be reduced. [variableScope]
 int k, n, nn, bestval, moveval, prob;
           ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:535:9: style: The scope of the variable 'n' can be reduced. [variableScope]
 int k, n;
        ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:548:7: style: The scope of the variable 'c' can be reduced. [variableScope]
 char c;
      ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:474:34: error: Division by zero. [zerodiv]
 return (goodmoves[(rand() >> 4) % n]);
                                 ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:461:7: note: Assignment 'n=0', assigned value is 0
  n = 0;
      ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:474:34: note: Division by zero
 return (goodmoves[(rand() >> 4) % n]);
                                 ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:179:13: style: Local variable 'die1' shadows outer variable [shadowVariable]
 extern int die1, die2;
            ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:35:5: note: Shadowed declaration
int die1;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:179:13: note: Shadow variable
 extern int die1, die2;
            ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:179:19: style: Local variable 'die2' shadows outer variable [shadowVariable]
 extern int die1, die2;
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:36:5: note: Shadowed declaration
int die2;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:179:19: note: Shadow variable
 extern int die1, die2;
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:186:13: style: Local variable 'i' shadows outer variable [shadowVariable]
 extern int i, j, l, m, imoves, count;
            ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:37:5: note: Shadowed declaration
int i;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:186:13: note: Shadow variable
 extern int i, j, l, m, imoves, count;
            ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:186:16: style: Local variable 'j' shadows outer variable [shadowVariable]
 extern int i, j, l, m, imoves, count;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:38:5: note: Shadowed declaration
int j;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:186:16: note: Shadow variable
 extern int i, j, l, m, imoves, count;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:186:19: style: Local variable 'l' shadows outer variable [shadowVariable]
 extern int i, j, l, m, imoves, count;
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:39:5: note: Shadowed declaration
int l;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:186:19: note: Shadow variable
 extern int i, j, l, m, imoves, count;
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:186:22: style: Local variable 'm' shadows outer variable [shadowVariable]
 extern int i, j, l, m, imoves, count;
                     ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:40:5: note: Shadowed declaration
int m;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:186:22: note: Shadow variable
 extern int i, j, l, m, imoves, count;
                     ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:186:25: style: Local variable 'imoves' shadows outer variable [shadowVariable]
 extern int i, j, l, m, imoves, count;
                        ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:56:5: note: Shadowed declaration
int imoves;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:186:25: note: Shadow variable
 extern int i, j, l, m, imoves, count;
                        ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:186:33: style: Local variable 'count' shadows outer variable [shadowVariable]
 extern int i, j, l, m, imoves, count;
                                ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:41:5: note: Shadowed declaration
int count;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:186:33: note: Shadow variable
 extern int i, j, l, m, imoves, count;
                                ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:227:13: style: Local variable 'i' shadows outer variable [shadowVariable]
 extern int i, j, l, m, count;
            ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:37:5: note: Shadowed declaration
int i;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:227:13: note: Shadow variable
 extern int i, j, l, m, count;
            ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:227:16: style: Local variable 'j' shadows outer variable [shadowVariable]
 extern int i, j, l, m, count;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:38:5: note: Shadowed declaration
int j;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:227:16: note: Shadow variable
 extern int i, j, l, m, count;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:227:19: style: Local variable 'l' shadows outer variable [shadowVariable]
 extern int i, j, l, m, count;
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:39:5: note: Shadowed declaration
int l;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:227:19: note: Shadow variable
 extern int i, j, l, m, count;
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:227:22: style: Local variable 'm' shadows outer variable [shadowVariable]
 extern int i, j, l, m, count;
                     ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:40:5: note: Shadowed declaration
int m;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:227:22: note: Shadow variable
 extern int i, j, l, m, count;
                     ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:227:25: style: Local variable 'count' shadows outer variable [shadowVariable]
 extern int i, j, l, m, count;
                        ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:41:5: note: Shadowed declaration
int count;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:227:25: note: Shadow variable
 extern int i, j, l, m, count;
                        ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:228:13: style: Local variable 'die1' shadows outer variable [shadowVariable]
 extern int die1, die2;
            ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:35:5: note: Shadowed declaration
int die1;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:228:13: note: Shadow variable
 extern int die1, die2;
            ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:228:19: style: Local variable 'die2' shadows outer variable [shadowVariable]
 extern int die1, die2;
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:36:5: note: Shadowed declaration
int die2;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:228:19: note: Shadow variable
 extern int die1, die2;
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:370:14: style: Local variable 'level' shadows outer variable [shadowVariable]
 extern char level;
             ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:34:6: note: Shadowed declaration
char level;   /*'b'=beginner, 'i'=intermediate, 'e'=expert */
     ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:370:14: note: Shadow variable
 extern char level;
             ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:440:14: style: Local variable 'level' shadows outer variable [shadowVariable]
 extern char level;
             ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:34:6: note: Shadowed declaration
char level;   /*'b'=beginner, 'i'=intermediate, 'e'=expert */
     ^
libsrc/_DEVELOPMENT/EXAMPLES/backgammon.c:440:14: note: Shadow variable
 extern char level;
             ^
libsrc/_DEVELOPMENT/EXAMPLES/beepfx.c:123:24: warning: %n in format string (no. 2) requires 'int *' but the argument type is 'unsigned int *'. [invalidScanfArgType_int]
      for (offset = 0; sscanf(buffer + offset, " %u%n", &i, &j) == 1; offset += j)
                       ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/binary-trees.c:158:24: style: Condition '(minDepth+2)>N' is always false [knownConditionTrueFalse]
    if ((minDepth + 2) > N)
                       ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/binary-trees.c:156:16: note: Assignment 'minDepth=4', assigned value is 4
    minDepth = 4;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/binary-trees.c:158:24: note: Condition '(minDepth+2)>N' is always false
    if ((minDepth + 2) > N)
                       ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/binary-trees.c:180:15: style: Variable 'check' is assigned a value that is never used. [unreadVariable]
        check = 0;
              ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/binary-trees.c:185:19: style: Variable 'check' is assigned a value that is never used. [unreadVariable]
            check += ItemCheck(tempTree);
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/binary-trees.c:189:19: style: Variable 'check' is assigned a value that is never used. [unreadVariable]
            check += ItemCheck(tempTree);
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/htcv309/binary-trees.c:149:24: style: Condition '(minDepth+2)>N' is always false [knownConditionTrueFalse]
    if ((minDepth + 2) > N)
                       ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/htcv309/binary-trees.c:147:16: note: Assignment 'minDepth=4', assigned value is 4
    minDepth = 4;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/htcv309/binary-trees.c:149:24: note: Condition '(minDepth+2)>N' is always false
    if ((minDepth + 2) > N)
                       ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/htcv309/binary-trees.c:171:15: style: Variable 'check' is assigned a value that is never used. [unreadVariable]
        check = 0;
              ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/htcv309/binary-trees.c:176:19: style: Variable 'check' is assigned a value that is never used. [unreadVariable]
            check += ItemCheck(tempTree);
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/htcv309/binary-trees.c:180:19: style: Variable 'check' is assigned a value that is never used. [unreadVariable]
            check += ItemCheck(tempTree);
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/htcv780/binary-trees.c:159:24: style: Condition '(minDepth+2)>N' is always false [knownConditionTrueFalse]
    if ((minDepth + 2) > N)
                       ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/htcv780/binary-trees.c:157:16: note: Assignment 'minDepth=4', assigned value is 4
    minDepth = 4;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/htcv780/binary-trees.c:159:24: note: Condition '(minDepth+2)>N' is always false
    if ((minDepth + 2) > N)
                       ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/htcv780/binary-trees.c:182:15: style: Variable 'check' is assigned a value that is never used. [unreadVariable]
        check = 0;
              ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/htcv780/binary-trees.c:187:19: style: Variable 'check' is assigned a value that is never used. [unreadVariable]
            check += ItemCheck(tempTree);
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/htcv780/binary-trees.c:191:19: style: Variable 'check' is assigned a value that is never used. [unreadVariable]
            check += ItemCheck(tempTree);
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/iar406a/binary-trees.c:159:24: style: Condition '(minDepth+2)>N' is always false [knownConditionTrueFalse]
    if ((minDepth + 2) > N)
                       ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/iar406a/binary-trees.c:157:16: note: Assignment 'minDepth=4', assigned value is 4
    minDepth = 4;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/iar406a/binary-trees.c:159:24: note: Condition '(minDepth+2)>N' is always false
    if ((minDepth + 2) > N)
                       ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/iar406a/binary-trees.c:181:15: style: Variable 'check' is assigned a value that is never used. [unreadVariable]
        check = 0;
              ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/iar406a/binary-trees.c:186:19: style: Variable 'check' is assigned a value that is never used. [unreadVariable]
            check += ItemCheck(tempTree);
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/iar406a/binary-trees.c:190:19: style: Variable 'check' is assigned a value that is never used. [unreadVariable]
            check += ItemCheck(tempTree);
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/iar406a/verify/bt.c:159:24: style: Condition '(minDepth+2)>N' is always false [knownConditionTrueFalse]
    if ((minDepth + 2) > N)
                       ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/iar406a/verify/bt.c:157:16: note: Assignment 'minDepth=4', assigned value is 4
    minDepth = 4;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/iar406a/verify/bt.c:159:24: note: Condition '(minDepth+2)>N' is always false
    if ((minDepth + 2) > N)
                       ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/iar406a/verify/bt.c:181:15: style: Variable 'check' is assigned a value that is never used. [unreadVariable]
        check = 0;
              ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/iar406a/verify/bt.c:186:19: style: Variable 'check' is assigned a value that is never used. [unreadVariable]
            check += ItemCheck(tempTree);
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/iar406a/verify/bt.c:190:19: style: Variable 'check' is assigned a value that is never used. [unreadVariable]
            check += ItemCheck(tempTree);
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/binary-trees.c:161:24: style: Condition '(minDepth+2)>N' is always false [knownConditionTrueFalse]
    if ((minDepth + 2) > N)
                       ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/binary-trees.c:159:16: note: Assignment 'minDepth=4', assigned value is 4
    minDepth = 4;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/binary-trees.c:161:24: note: Condition '(minDepth+2)>N' is always false
    if ((minDepth + 2) > N)
                       ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/binary-trees.c:184:15: style: Variable 'check' is assigned a value that is never used. [unreadVariable]
        check = 0;
              ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/binary-trees.c:189:19: style: Variable 'check' is assigned a value that is never used. [unreadVariable]
            check += ItemCheck(tempTree);
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/binary-trees.c:193:19: style: Variable 'check' is assigned a value that is never used. [unreadVariable]
            check += ItemCheck(tempTree);
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/binary-trees.c:102:5: warning: Either the condition 'new==NULL' is redundant or there is possible null pointer dereference: new. [nullPointerRedundantCheck]
    new->left = left;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/binary-trees.c:91:13: note: Assuming that condition 'new==NULL' is not redundant
    if (new == NULL)
            ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/binary-trees.c:102:5: note: Null pointer dereference
    new->left = left;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/binary-trees.c:103:5: warning: Either the condition 'new==NULL' is redundant or there is possible null pointer dereference: new. [nullPointerRedundantCheck]
    new->right = right;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/binary-trees.c:91:13: note: Assuming that condition 'new==NULL' is not redundant
    if (new == NULL)
            ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/binary-trees.c:103:5: note: Null pointer dereference
    new->right = right;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/binary-trees.c:104:5: warning: Either the condition 'new==NULL' is redundant or there is possible null pointer dereference: new. [nullPointerRedundantCheck]
    new->item = item;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/binary-trees.c:91:13: note: Assuming that condition 'new==NULL' is not redundant
    if (new == NULL)
            ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/binary-trees.c:104:5: note: Null pointer dereference
    new->item = item;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/verify/binary-trees.c:161:24: style: Condition '(minDepth+2)>N' is always false [knownConditionTrueFalse]
    if ((minDepth + 2) > N)
                       ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/verify/binary-trees.c:159:16: note: Assignment 'minDepth=4', assigned value is 4
    minDepth = 4;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/verify/binary-trees.c:161:24: note: Condition '(minDepth+2)>N' is always false
    if ((minDepth + 2) > N)
                       ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/verify/binary-trees.c:184:15: style: Variable 'check' is assigned a value that is never used. [unreadVariable]
        check = 0;
              ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/verify/binary-trees.c:189:19: style: Variable 'check' is assigned a value that is never used. [unreadVariable]
            check += ItemCheck(tempTree);
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/verify/binary-trees.c:193:19: style: Variable 'check' is assigned a value that is never used. [unreadVariable]
            check += ItemCheck(tempTree);
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/verify/binary-trees.c:102:5: warning: Either the condition 'new==NULL' is redundant or there is possible null pointer dereference: new. [nullPointerRedundantCheck]
    new->left = left;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/verify/binary-trees.c:91:13: note: Assuming that condition 'new==NULL' is not redundant
    if (new == NULL)
            ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/verify/binary-trees.c:102:5: note: Null pointer dereference
    new->left = left;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/verify/binary-trees.c:103:5: warning: Either the condition 'new==NULL' is redundant or there is possible null pointer dereference: new. [nullPointerRedundantCheck]
    new->right = right;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/verify/binary-trees.c:91:13: note: Assuming that condition 'new==NULL' is not redundant
    if (new == NULL)
            ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/verify/binary-trees.c:103:5: note: Null pointer dereference
    new->right = right;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/verify/binary-trees.c:104:5: warning: Either the condition 'new==NULL' is redundant or there is possible null pointer dereference: new. [nullPointerRedundantCheck]
    new->item = item;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/verify/binary-trees.c:91:13: note: Assuming that condition 'new==NULL' is not redundant
    if (new == NULL)
            ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/sdcc/verify/binary-trees.c:104:5: note: Null pointer dereference
    new->item = item;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/z88dk-classic/binary-trees.c:158:24: style: Condition '(minDepth+2)>N' is always false [knownConditionTrueFalse]
    if ((minDepth + 2) > N)
                       ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/z88dk-classic/binary-trees.c:156:16: note: Assignment 'minDepth=4', assigned value is 4
    minDepth = 4;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/z88dk-classic/binary-trees.c:158:24: note: Condition '(minDepth+2)>N' is always false
    if ((minDepth + 2) > N)
                       ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/z88dk-classic/binary-trees.c:180:15: style: Variable 'check' is assigned a value that is never used. [unreadVariable]
        check = 0;
              ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/z88dk-classic/binary-trees.c:185:19: style: Variable 'check' is assigned a value that is never used. [unreadVariable]
            check += ItemCheck(tempTree);
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/z88dk-classic/binary-trees.c:189:19: style: Variable 'check' is assigned a value that is never used. [unreadVariable]
            check += ItemCheck(tempTree);
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/z88dk-new/binary-trees.c:158:24: style: Condition '(minDepth+2)>N' is always false [knownConditionTrueFalse]
    if ((minDepth + 2) > N)
                       ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/z88dk-new/binary-trees.c:156:16: note: Assignment 'minDepth=4', assigned value is 4
    minDepth = 4;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/z88dk-new/binary-trees.c:158:24: note: Condition '(minDepth+2)>N' is always false
    if ((minDepth + 2) > N)
                       ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/z88dk-new/binary-trees.c:180:15: style: Variable 'check' is assigned a value that is never used. [unreadVariable]
        check = 0;
              ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/z88dk-new/binary-trees.c:185:19: style: Variable 'check' is assigned a value that is never used. [unreadVariable]
            check += ItemCheck(tempTree);
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/binary-trees/z88dk-new/binary-trees.c:189:19: style: Variable 'check' is assigned a value that is never used. [unreadVariable]
            check += ItemCheck(tempTree);
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/dhry_1.c:171:15: style: Variable 'Int_2_Loc' is assigned a value that is never used. [unreadVariable]
    Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_1_Loc;
              ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/dhry_2.c:146:7: error: Uninitialized variable: Ch_Loc [uninitvar]
  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/dhry_2.c:140:43: note: Assuming condition is false
                Str_2_Par_Ref[Int_Loc+1]) == Ident_1)
                                          ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/dhry_2.c:146:7: note: Uninitialized variable: Ch_Loc
  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/htcv309/dhry-1.c:171:15: style: Variable 'Int_2_Loc' is assigned a value that is never used. [unreadVariable]
    Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_1_Loc;
              ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/htcv309/dhry-2.c:146:7: error: Uninitialized variable: Ch_Loc [uninitvar]
  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/htcv309/dhry-2.c:140:43: note: Assuming condition is false
                Str_2_Par_Ref[Int_Loc+1]) == Ident_1)
                                          ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/htcv309/dhry-2.c:146:7: note: Uninitialized variable: Ch_Loc
  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/htcv780/dhry_2.c:146:7: error: Uninitialized variable: Ch_Loc [uninitvar]
  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/htcv780/dhry_2.c:140:43: note: Assuming condition is false
                Str_2_Par_Ref[Int_Loc+1]) == Ident_1)
                                          ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/htcv780/dhry_2.c:146:7: note: Uninitialized variable: Ch_Loc
  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/iar406a/dhry_1.c:171:15: style: Variable 'Int_2_Loc' is assigned a value that is never used. [unreadVariable]
    Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_1_Loc;
              ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/iar406a/dhry_2.c:146:7: error: Uninitialized variable: Ch_Loc [uninitvar]
  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/iar406a/dhry_2.c:140:43: note: Assuming condition is false
                Str_2_Par_Ref[Int_Loc+1]) == Ident_1)
                                          ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/iar406a/dhry_2.c:146:7: note: Uninitialized variable: Ch_Loc
  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/iar406a/verify/dhry_1.c:171:15: style: Variable 'Int_2_Loc' is assigned a value that is never used. [unreadVariable]
    Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_1_Loc;
              ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/iar406a/verify/dhry_2.c:146:7: error: Uninitialized variable: Ch_Loc [uninitvar]
  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/iar406a/verify/dhry_2.c:140:43: note: Assuming condition is false
                Str_2_Par_Ref[Int_Loc+1]) == Ident_1)
                                          ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/iar406a/verify/dhry_2.c:146:7: note: Uninitialized variable: Ch_Loc
  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/sdcc/dhry_1.c:172:15: style: Variable 'Int_2_Loc' is assigned a value that is never used. [unreadVariable]
    Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_1_Loc;
              ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/sdcc/dhry_2.c:146:7: error: Uninitialized variable: Ch_Loc [uninitvar]
  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/sdcc/dhry_2.c:140:43: note: Assuming condition is false
                Str_2_Par_Ref[Int_Loc+1]) == Ident_1)
                                          ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/sdcc/dhry_2.c:146:7: note: Uninitialized variable: Ch_Loc
  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/sdcc/verify/dhry_1.c:172:15: style: Variable 'Int_2_Loc' is assigned a value that is never used. [unreadVariable]
    Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_1_Loc;
              ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/sdcc/verify/dhry_2.c:146:7: error: Uninitialized variable: Ch_Loc [uninitvar]
  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/sdcc/verify/dhry_2.c:140:43: note: Assuming condition is false
                Str_2_Par_Ref[Int_Loc+1]) == Ident_1)
                                          ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/sdcc/verify/dhry_2.c:146:7: note: Uninitialized variable: Ch_Loc
  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/z88dk-classic/dhry_1.c:171:15: style: Variable 'Int_2_Loc' is assigned a value that is never used. [unreadVariable]
    Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_1_Loc;
              ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/z88dk-classic/dhry_2.c:146:7: error: Uninitialized variable: Ch_Loc [uninitvar]
  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/z88dk-classic/dhry_2.c:140:43: note: Assuming condition is false
                Str_2_Par_Ref[Int_Loc+1]) == Ident_1)
                                          ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/z88dk-classic/dhry_2.c:146:7: note: Uninitialized variable: Ch_Loc
  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/z88dk-new/dhry_1.c:171:15: style: Variable 'Int_2_Loc' is assigned a value that is never used. [unreadVariable]
    Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_1_Loc;
              ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/z88dk-new/dhry_2.c:146:7: error: Uninitialized variable: Ch_Loc [uninitvar]
  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/z88dk-new/dhry_2.c:140:43: note: Assuming condition is false
                Str_2_Par_Ref[Int_Loc+1]) == Ident_1)
                                          ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/dhrystone21/z88dk-new/dhry_2.c:146:7: note: Uninitialized variable: Ch_Loc
  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fannkuch/fannkuch.c:86:25: style: Variable 'checksum' is assigned a value that is never used. [unreadVariable]
    STATIC int checksum = 0;
                        ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fannkuch/fannkuch.c:117:18: style: Variable 'checksum' is assigned a value that is never used. [unreadVariable]
        checksum += permCount % 2 == 0 ? flipsCount : -flipsCount;
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fannkuch/htcv309/fannkuch.c:78:25: style: Variable 'checksum' is assigned a value that is never used. [unreadVariable]
    STATIC int checksum = 0;
                        ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fannkuch/htcv309/fannkuch.c:109:18: style: Variable 'checksum' is assigned a value that is never used. [unreadVariable]
        checksum += permCount % 2 == 0 ? flipsCount : -flipsCount;
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fannkuch/htcv780/fannkuch.c:86:25: style: Variable 'checksum' is assigned a value that is never used. [unreadVariable]
    STATIC int checksum = 0;
                        ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fannkuch/htcv780/fannkuch.c:117:18: style: Variable 'checksum' is assigned a value that is never used. [unreadVariable]
        checksum += permCount % 2 == 0 ? flipsCount : -flipsCount;
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fannkuch/iar406a/fannkuch.c:86:25: style: Variable 'checksum' is assigned a value that is never used. [unreadVariable]
    STATIC int checksum = 0;
                        ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fannkuch/iar406a/fannkuch.c:117:18: style: Variable 'checksum' is assigned a value that is never used. [unreadVariable]
        checksum += permCount % 2 == 0 ? flipsCount : -flipsCount;
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fannkuch/iar406a/verify/fannkuch.c:86:25: style: Variable 'checksum' is assigned a value that is never used. [unreadVariable]
    STATIC int checksum = 0;
                        ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fannkuch/iar406a/verify/fannkuch.c:117:18: style: Variable 'checksum' is assigned a value that is never used. [unreadVariable]
        checksum += permCount % 2 == 0 ? flipsCount : -flipsCount;
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fannkuch/sdcc/fannkuch.c:86:25: style: Variable 'checksum' is assigned a value that is never used. [unreadVariable]
    STATIC int checksum = 0;
                        ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fannkuch/sdcc/fannkuch.c:117:18: style: Variable 'checksum' is assigned a value that is never used. [unreadVariable]
        checksum += permCount % 2 == 0 ? flipsCount : -flipsCount;
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fannkuch/sdcc/verify/fannkuch.c:86:25: style: Variable 'checksum' is assigned a value that is never used. [unreadVariable]
    STATIC int checksum = 0;
                        ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fannkuch/sdcc/verify/fannkuch.c:117:18: style: Variable 'checksum' is assigned a value that is never used. [unreadVariable]
        checksum += permCount % 2 == 0 ? flipsCount : -flipsCount;
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fannkuch/z88dk-classic/fannkuch.c:86:25: style: Variable 'checksum' is assigned a value that is never used. [unreadVariable]
    STATIC int checksum = 0;
                        ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fannkuch/z88dk-classic/fannkuch.c:117:18: style: Variable 'checksum' is assigned a value that is never used. [unreadVariable]
        checksum += permCount % 2 == 0 ? flipsCount : -flipsCount;
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fannkuch/z88dk-new/fannkuch.c:86:25: style: Variable 'checksum' is assigned a value that is never used. [unreadVariable]
    STATIC int checksum = 0;
                        ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fannkuch/z88dk-new/fannkuch.c:117:18: style: Variable 'checksum' is assigned a value that is never used. [unreadVariable]
        checksum += permCount % 2 == 0 ? flipsCount : -flipsCount;
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fasta/fasta.c:174:18: style: Variable 'ss[k+m]' is reassigned a value before the old one has been used. [redundantAssignment]
       ss[k + m] = s[m+k];
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fasta/fasta.c:172:18: note: ss[k+m] is assigned
       ss[k + m] = '\0';
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fasta/fasta.c:174:18: note: ss[k+m] is overwritten
       ss[k + m] = s[m+k];
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fasta/htcv309/fasta.c:162:18: style: Variable 'ss[k+m]' is reassigned a value before the old one has been used. [redundantAssignment]
       ss[k + m] = s[m+k];
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fasta/htcv309/fasta.c:160:18: note: ss[k+m] is assigned
       ss[k + m] = '\0';
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fasta/htcv309/fasta.c:162:18: note: ss[k+m] is overwritten
       ss[k + m] = s[m+k];
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fasta/htcv780/fasta.c:174:18: style: Variable 'ss[k+m]' is reassigned a value before the old one has been used. [redundantAssignment]
       ss[k + m] = s[m+k];
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fasta/htcv780/fasta.c:172:18: note: ss[k+m] is assigned
       ss[k + m] = '\0';
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fasta/htcv780/fasta.c:174:18: note: ss[k+m] is overwritten
       ss[k + m] = s[m+k];
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fasta/iar406a/fasta.c:174:18: style: Variable 'ss[k+m]' is reassigned a value before the old one has been used. [redundantAssignment]
       ss[k + m] = s[m+k];
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fasta/iar406a/fasta.c:172:18: note: ss[k+m] is assigned
       ss[k + m] = '\0';
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fasta/iar406a/fasta.c:174:18: note: ss[k+m] is overwritten
       ss[k + m] = s[m+k];
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fasta/iar406a/verify/fasta.c:174:18: style: Variable 'ss[k+m]' is reassigned a value before the old one has been used. [redundantAssignment]
       ss[k + m] = s[m+k];
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fasta/iar406a/verify/fasta.c:172:18: note: ss[k+m] is assigned
       ss[k + m] = '\0';
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fasta/iar406a/verify/fasta.c:174:18: note: ss[k+m] is overwritten
       ss[k + m] = s[m+k];
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fasta/sdcc/fasta.c:174:18: style: Variable 'ss[k+m]' is reassigned a value before the old one has been used. [redundantAssignment]
       ss[k + m] = s[m+k];
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fasta/sdcc/fasta.c:172:18: note: ss[k+m] is assigned
       ss[k + m] = '\0';
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fasta/sdcc/fasta.c:174:18: note: ss[k+m] is overwritten
       ss[k + m] = s[m+k];
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fasta/sdcc/verify/fasta.c:174:18: style: Variable 'ss[k+m]' is reassigned a value before the old one has been used. [redundantAssignment]
       ss[k + m] = s[m+k];
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fasta/sdcc/verify/fasta.c:172:18: note: ss[k+m] is assigned
       ss[k + m] = '\0';
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fasta/sdcc/verify/fasta.c:174:18: note: ss[k+m] is overwritten
       ss[k + m] = s[m+k];
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fasta/z88dk-classic/fasta.c:174:18: style: Variable 'ss[k+m]' is reassigned a value before the old one has been used. [redundantAssignment]
       ss[k + m] = s[m+k];
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fasta/z88dk-classic/fasta.c:172:18: note: ss[k+m] is assigned
       ss[k + m] = '\0';
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fasta/z88dk-classic/fasta.c:174:18: note: ss[k+m] is overwritten
       ss[k + m] = s[m+k];
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fasta/z88dk-new/fasta.c:174:18: style: Variable 'ss[k+m]' is reassigned a value before the old one has been used. [redundantAssignment]
       ss[k + m] = s[m+k];
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fasta/z88dk-new/fasta.c:172:18: note: ss[k+m] is assigned
       ss[k + m] = '\0';
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/fasta/z88dk-new/fasta.c:174:18: note: ss[k+m] is overwritten
       ss[k + m] = s[m+k];
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/n-body/sdcc/verify/printf_large.c:138:12: error: Expression 'c=(c)|=0x20' depends on order of evaluation of side effects [unknownEvaluationOrder]
         c = tolower(c);
           ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/n-body/sdcc/verify/printf_large.c:530:11: error: Expression 'c=(c)&=0xDF' depends on order of evaluation of side effects [unknownEvaluationOrder]
        c = toupper(c);
          ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/paranoia/part1.c:244:35: style: Same expression on both sides of '&&' because 'One+MinusOne==Zero' and 'MinusOne+One==Zero' represent the same value. [knownConditionTrueFalse]
     && (MinusOne + One == Zero ) && (One + MinusOne == Zero)
                                  ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/paranoia/part3.c:207:20: style: Same expression on both sides of '&&'. [duplicateExpression]
   && (Y2 == Zero) && (Y2 == Zero)
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/paranoia/part6.c:152:5: warning: Redundant assignment of 'X' to itself. [selfAssignment]
  X = X;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/paranoia/part7.c:172:11: style: Opposite expression on both sides of '<'. [oppositeExpression]
 if (!(-V < V && -V0 < V0 && -UfThold < V && UfThold < V)) {
          ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/paranoia/subs.c:14:7: style: Local variable 'ch' shadows outer variable [shadowVariable]
 char ch[8];
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/paranoia/paranoia.h:139:13: note: Shadowed declaration
extern char ch[8];
            ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/paranoia/subs.c:14:7: note: Shadow variable
 char ch[8];
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/paranoia/subs.c:56:8: style: Local variable 'X' shadows outer variable [shadowVariable]
 FLOAT X, Y;
       ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/paranoia/paranoia.h:158:14: note: Shadowed declaration
extern FLOAT X, X1, X2, X8, Random1;
             ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/paranoia/subs.c:56:8: note: Shadow variable
 FLOAT X, Y;
       ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/paranoia/subs.c:56:11: style: Local variable 'Y' shadows outer variable [shadowVariable]
 FLOAT X, Y;
          ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/paranoia/paranoia.h:159:14: note: Shadowed declaration
extern FLOAT Y, Y1, Y2, Random2;
             ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/paranoia/subs.c:56:11: note: Shadow variable
 FLOAT X, Y;
          ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/pi/htcv309/pi.c:54:20: style: The scope of the variable 'd' can be reduced. [variableScope]
   STATIC uint32_t d;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/pi/htcv309/pi.c:82:7: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
      PRINTF("%.4d", c + (uint16_t)(d / 10000));
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/pi/htcv780/pi.c:61:20: style: The scope of the variable 'd' can be reduced. [variableScope]
   STATIC uint32_t d;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/pi/htcv780/pi.c:89:7: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
      PRINTF("%.4d", c + (uint16_t)(d / 10000UL));
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/pi/htcv780/pi_ldiv.c:67:20: style: The scope of the variable 'd' can be reduced. [variableScope]
   STATIC uint32_t d;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/pi/htcv780/pi_ldiv.c:101:7: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
      PRINTF("%.4d", c + (uint16_t)(res.quot));
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/pi/iar406a/pi.c:61:20: style: The scope of the variable 'd' can be reduced. [variableScope]
   STATIC uint32_t d;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/pi/iar406a/pi.c:89:7: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
      PRINTF("%.4d", c + (uint16_t)(d / 10000UL));
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/pi/iar406a/pi_ldiv.c:67:20: style: The scope of the variable 'd' can be reduced. [variableScope]
   STATIC uint32_t d;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/pi/iar406a/pi_ldiv.c:101:7: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
      PRINTF("%.4d", c + (uint16_t)(res.quot));
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/pi/iar406a/verify/pi.c:61:20: style: The scope of the variable 'd' can be reduced. [variableScope]
   STATIC uint32_t d;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/pi/iar406a/verify/pi.c:89:7: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
      PRINTF("%.4d", c + (uint16_t)(d / 10000UL));
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/pi/iar406a/verify/pi_ldiv.c:67:20: style: The scope of the variable 'd' can be reduced. [variableScope]
   STATIC uint32_t d;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/pi/iar406a/verify/pi_ldiv.c:101:7: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
      PRINTF("%.4d", c + (uint16_t)(res.quot));
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/pi/pi.c:59:20: style: The scope of the variable 'd' can be reduced. [variableScope]
   STATIC uint32_t d;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/pi/pi_ldiv.c:65:20: style: The scope of the variable 'd' can be reduced. [variableScope]
   STATIC uint32_t d;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/pi/sdcc/pi.c:59:20: style: The scope of the variable 'd' can be reduced. [variableScope]
   STATIC uint32_t d;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/pi/sdcc/verify/pi.c:59:20: style: The scope of the variable 'd' can be reduced. [variableScope]
   STATIC uint32_t d;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/pi/z88dk-classic/pi.c:56:20: style: The scope of the variable 'd' can be reduced. [variableScope]
   STATIC uint32_t d;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/pi/z88dk-new/pi.c:59:20: style: The scope of the variable 'd' can be reduced. [variableScope]
   STATIC uint32_t d;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/pi/z88dk-new/pi_ldiv.c:65:20: style: The scope of the variable 'd' can be reduced. [variableScope]
   STATIC uint32_t d;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sieve/htcv309/sieve.c:61:10: style: Variable 'count' is assigned a value that is never used. [unreadVariable]
   count = SIZE - 2;
         ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sieve/htcv309/sieve.c:70:21: style: Variable 'count' is assigned a value that is never used. [unreadVariable]
            count   -= !flags[k];
                    ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sieve/htcv309/sieve.c:79:4: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
   PRINTF3("\n%u primes found in [2,%u]:\n\n", count, SIZE-1);
   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sieve/htcv780/sieve.c:68:10: style: Variable 'count' is assigned a value that is never used. [unreadVariable]
   count = SIZE - 2;
         ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sieve/htcv780/sieve.c:77:21: style: Variable 'count' is assigned a value that is never used. [unreadVariable]
            count   -= !flags[k];
                    ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sieve/htcv780/sieve.c:86:4: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
   PRINTF3("\n%u primes found in [2,%u]:\n\n", count, SIZE-1);
   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sieve/iar406a/sieve.c:68:10: style: Variable 'count' is assigned a value that is never used. [unreadVariable]
   count = SIZE - 2;
         ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sieve/iar406a/sieve.c:77:21: style: Variable 'count' is assigned a value that is never used. [unreadVariable]
            count   -= !flags[k];
                    ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sieve/iar406a/sieve.c:86:4: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
   PRINTF3("\n%u primes found in [2,%u]:\n\n", count, SIZE-1);
   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sieve/iar406a/verify/sieve.c:68:10: style: Variable 'count' is assigned a value that is never used. [unreadVariable]
   count = SIZE - 2;
         ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sieve/iar406a/verify/sieve.c:77:21: style: Variable 'count' is assigned a value that is never used. [unreadVariable]
            count   -= !flags[k];
                    ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sieve/iar406a/verify/sieve.c:86:4: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
   PRINTF3("\n%u primes found in [2,%u]:\n\n", count, SIZE-1);
   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sieve/sdcc/sieve.c:68:10: style: Variable 'count' is assigned a value that is never used. [unreadVariable]
   count = SIZE - 2;
         ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sieve/sdcc/sieve.c:77:21: style: Variable 'count' is assigned a value that is never used. [unreadVariable]
            count   -= !flags[k];
                    ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sieve/sdcc/sieve.c:86:4: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
   PRINTF3("\n%u primes found in [2,%u]:\n\n", count, SIZE-1);
   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sieve/sdcc/verify/sieve.c:68:10: style: Variable 'count' is assigned a value that is never used. [unreadVariable]
   count = SIZE - 2;
         ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sieve/sdcc/verify/sieve.c:77:21: style: Variable 'count' is assigned a value that is never used. [unreadVariable]
            count   -= !flags[k];
                    ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sieve/sdcc/verify/sieve.c:86:4: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
   PRINTF3("\n%u primes found in [2,%u]:\n\n", count, SIZE-1);
   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sieve/sieve.c:68:10: style: Variable 'count' is assigned a value that is never used. [unreadVariable]
   count = SIZE - 2;
         ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sieve/sieve.c:77:21: style: Variable 'count' is assigned a value that is never used. [unreadVariable]
            count   -= !flags[k];
                    ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sieve/sieve.c:86:4: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
   PRINTF3("\n%u primes found in [2,%u]:\n\n", count, SIZE-1);
   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sieve/z88dk-classic/sieve.c:65:10: style: Variable 'count' is assigned a value that is never used. [unreadVariable]
   count = SIZE - 2;
         ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sieve/z88dk-classic/sieve.c:74:21: style: Variable 'count' is assigned a value that is never used. [unreadVariable]
            count   -= !flags[k];
                    ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sieve/z88dk-classic/sieve.c:83:4: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
   PRINTF3("\n%u primes found in [2,%u]:\n\n", count, SIZE-1);
   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sieve/z88dk-new/sieve.c:68:10: style: Variable 'count' is assigned a value that is never used. [unreadVariable]
   count = SIZE - 2;
         ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sieve/z88dk-new/sieve.c:77:21: style: Variable 'count' is assigned a value that is never used. [unreadVariable]
            count   -= !flags[k];
                    ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sieve/z88dk-new/sieve.c:86:4: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
   PRINTF3("\n%u primes found in [2,%u]:\n\n", count, SIZE-1);
   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sorting/htcv309/sort.c:93:7: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'int'. [invalidPrintfArgType_uint]
      PRINTF2("%u, ", numbers[i]);
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sorting/htcv309/sort.c:104:7: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'int'. [invalidPrintfArgType_uint]
      PRINTF2("%u, ", numbers[i]);
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sorting/htcv780/sort.c:93:7: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'int'. [invalidPrintfArgType_uint]
      PRINTF2("%u, ", numbers[i]);
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sorting/htcv780/sort.c:104:7: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'int'. [invalidPrintfArgType_uint]
      PRINTF2("%u, ", numbers[i]);
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sorting/iar406a/sort.c:93:7: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'int'. [invalidPrintfArgType_uint]
      PRINTF2("%u, ", numbers[i]);
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sorting/iar406a/sort.c:104:7: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'int'. [invalidPrintfArgType_uint]
      PRINTF2("%u, ", numbers[i]);
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sorting/iar406a/verify/sort.c:93:7: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'int'. [invalidPrintfArgType_uint]
      PRINTF2("%u, ", numbers[i]);
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sorting/iar406a/verify/sort.c:104:7: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'int'. [invalidPrintfArgType_uint]
      PRINTF2("%u, ", numbers[i]);
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sorting/sdcc/qsort.c:16:18: style: The scope of the variable 't' can be reduced. [variableScope]
   unsigned char t;
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sorting/sdcc/sort.c:95:7: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'int'. [invalidPrintfArgType_uint]
      PRINTF2("%u, ", numbers[i]);
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sorting/sdcc/sort.c:106:7: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'int'. [invalidPrintfArgType_uint]
      PRINTF2("%u, ", numbers[i]);
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sorting/sdcc/verify/qsort.c:16:18: style: The scope of the variable 't' can be reduced. [variableScope]
   unsigned char t;
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sorting/sdcc/verify/sort.c:95:7: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'int'. [invalidPrintfArgType_uint]
      PRINTF2("%u, ", numbers[i]);
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sorting/sdcc/verify/sort.c:106:7: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'int'. [invalidPrintfArgType_uint]
      PRINTF2("%u, ", numbers[i]);
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sorting/sort.c:93:7: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'int'. [invalidPrintfArgType_uint]
      PRINTF2("%u, ", numbers[i]);
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sorting/sort.c:104:7: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'int'. [invalidPrintfArgType_uint]
      PRINTF2("%u, ", numbers[i]);
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sorting/z88dk-classic/sort.c:97:7: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'int'. [invalidPrintfArgType_uint]
      PRINTF2("%u, ", numbers[i]);
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sorting/z88dk-classic/sort.c:108:7: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'int'. [invalidPrintfArgType_uint]
      PRINTF2("%u, ", numbers[i]);
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sorting/z88dk-new/sort.c:101:7: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'int'. [invalidPrintfArgType_uint]
      PRINTF2("%u, ", numbers[i]);
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/sorting/z88dk-new/sort.c:112:7: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'int'. [invalidPrintfArgType_uint]
      PRINTF2("%u, ", numbers[i]);
      ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/spectral-norm/htcv309/spectral.c:83:3: warning: Return value of function sqrt() is not used. [ignoredReturnValue]
  PRINTF2("%0.9f\n",sqrt(vBv/vv));
  ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/spectral-norm/htcv780/spectral-norm.c:91:3: warning: Return value of function sqrt() is not used. [ignoredReturnValue]
  PRINTF2("%0.9f\n",sqrt(vBv/vv));
  ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/spectral-norm/iar406a/spectral-norm.c:91:3: warning: Return value of function sqrt() is not used. [ignoredReturnValue]
  PRINTF2("%0.9f\n",sqrt(vBv/vv));
  ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/spectral-norm/iar406a/verify/spectral-norm.c:91:3: warning: Return value of function sqrt() is not used. [ignoredReturnValue]
  PRINTF2("%0.9f\n",sqrt(vBv/vv));
  ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/spectral-norm/sdcc/spectral-norm.c:93:3: warning: Return value of function sqrtf() is not used. [ignoredReturnValue]
  PRINTF2("%0.9f\n",sqrt(vBv/vv));
  ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/spectral-norm/sdcc/verify/printf_large.c:138:12: error: Expression 'c=(c)|=0x20' depends on order of evaluation of side effects [unknownEvaluationOrder]
         c = tolower(c);
           ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/spectral-norm/sdcc/verify/printf_large.c:530:11: error: Expression 'c=(c)&=0xDF' depends on order of evaluation of side effects [unknownEvaluationOrder]
        c = toupper(c);
          ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/spectral-norm/sdcc/verify/spectral-norm.c:93:3: warning: Return value of function sqrtf() is not used. [ignoredReturnValue]
  PRINTF2("%0.9f\n",sqrt(vBv/vv));
  ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/spectral-norm/spectral-norm.c:91:3: warning: Return value of function sqrt() is not used. [ignoredReturnValue]
  PRINTF2("%0.9f\n",sqrt(vBv/vv));
  ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/spectral-norm/z88dk-classic/spectral-norm.c:91:3: warning: Return value of function sqrt() is not used. [ignoredReturnValue]
  PRINTF2("%0.9f\n",sqrt(vBv/vv));
  ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/spectral-norm/z88dk-new/spectral-norm.c:95:3: warning: Return value of function sqrt() is not used. [ignoredReturnValue]
  PRINTF2("%0.9f\n",sqrt(vBv/vv));
  ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/htcv309/whet.c:172:1: style: Label 'LCONT' is not used. There is #if in function body so the label might be used in code that is removed by the preprocessor. [unusedLabelConfiguration]
LCONT:
^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/htcv309/whet.c:146:16: style: Unused variable: startsec [unusedVariable]
   STATIC long startsec, finisec;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/htcv309/whet.c:146:26: style: Unused variable: finisec [unusedVariable]
   STATIC long startsec, finisec;
                         ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/htcv309/whet.c:147:20: style: Unused variable: KIPS [unusedVariable]
   STATIC double_t KIPS;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/htcv309/whet.c:146:16: style: Variable 'startsec' is not assigned a value. [unassignedVariable]
   STATIC long startsec, finisec;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/htcv780/whetstone.c:179:1: style: Label 'LCONT' is not used. There is #if in function body so the label might be used in code that is removed by the preprocessor. [unusedLabelConfiguration]
LCONT:
^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/htcv780/whetstone.c:153:16: style: Unused variable: startsec [unusedVariable]
   STATIC long startsec, finisec;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/htcv780/whetstone.c:153:26: style: Unused variable: finisec [unusedVariable]
   STATIC long startsec, finisec;
                         ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/htcv780/whetstone.c:154:20: style: Unused variable: KIPS [unusedVariable]
   STATIC double_t KIPS;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/htcv780/whetstone.c:153:16: style: Variable 'startsec' is not assigned a value. [unassignedVariable]
   STATIC long startsec, finisec;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/iar406a/verify/whetstone.c:179:1: style: Label 'LCONT' is not used. There is #if in function body so the label might be used in code that is removed by the preprocessor. [unusedLabelConfiguration]
LCONT:
^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/iar406a/verify/whetstone.c:153:16: style: Unused variable: startsec [unusedVariable]
   STATIC long startsec, finisec;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/iar406a/verify/whetstone.c:153:26: style: Unused variable: finisec [unusedVariable]
   STATIC long startsec, finisec;
                         ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/iar406a/verify/whetstone.c:154:20: style: Unused variable: KIPS [unusedVariable]
   STATIC double_t KIPS;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/iar406a/verify/whetstone.c:153:16: style: Variable 'startsec' is not assigned a value. [unassignedVariable]
   STATIC long startsec, finisec;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/iar406a/whetstone.c:179:1: style: Label 'LCONT' is not used. There is #if in function body so the label might be used in code that is removed by the preprocessor. [unusedLabelConfiguration]
LCONT:
^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/iar406a/whetstone.c:153:16: style: Unused variable: startsec [unusedVariable]
   STATIC long startsec, finisec;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/iar406a/whetstone.c:153:26: style: Unused variable: finisec [unusedVariable]
   STATIC long startsec, finisec;
                         ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/iar406a/whetstone.c:154:20: style: Unused variable: KIPS [unusedVariable]
   STATIC double_t KIPS;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/iar406a/whetstone.c:153:16: style: Variable 'startsec' is not assigned a value. [unassignedVariable]
   STATIC long startsec, finisec;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/sdcc/verify/printf_large.c:138:12: error: Expression 'c=(c)|=0x20' depends on order of evaluation of side effects [unknownEvaluationOrder]
         c = tolower(c);
           ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/sdcc/verify/printf_large.c:530:11: error: Expression 'c=(c)&=0xDF' depends on order of evaluation of side effects [unknownEvaluationOrder]
        c = toupper(c);
          ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/sdcc/verify/whetstone.c:179:1: style: Label 'LCONT' is not used. There is #if in function body so the label might be used in code that is removed by the preprocessor. [unusedLabelConfiguration]
LCONT:
^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/sdcc/verify/whetstone.c:153:16: style: Unused variable: startsec [unusedVariable]
   STATIC long startsec, finisec;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/sdcc/verify/whetstone.c:153:26: style: Unused variable: finisec [unusedVariable]
   STATIC long startsec, finisec;
                         ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/sdcc/verify/whetstone.c:154:20: style: Unused variable: KIPS [unusedVariable]
   STATIC double_t KIPS;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/sdcc/verify/whetstone.c:153:16: style: Variable 'startsec' is not assigned a value. [unassignedVariable]
   STATIC long startsec, finisec;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/sdcc/whetstone.c:179:1: style: Label 'LCONT' is not used. There is #if in function body so the label might be used in code that is removed by the preprocessor. [unusedLabelConfiguration]
LCONT:
^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/sdcc/whetstone.c:153:16: style: Unused variable: startsec [unusedVariable]
   STATIC long startsec, finisec;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/sdcc/whetstone.c:153:26: style: Unused variable: finisec [unusedVariable]
   STATIC long startsec, finisec;
                         ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/sdcc/whetstone.c:154:20: style: Unused variable: KIPS [unusedVariable]
   STATIC double_t KIPS;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/sdcc/whetstone.c:153:16: style: Variable 'startsec' is not assigned a value. [unassignedVariable]
   STATIC long startsec, finisec;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/whetstone.c:176:1: style: Label 'LCONT' is not used. There is #if in function body so the label might be used in code that is removed by the preprocessor. [unusedLabelConfiguration]
LCONT:
^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/whetstone.c:150:16: style: Unused variable: startsec [unusedVariable]
   STATIC long startsec, finisec;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/whetstone.c:150:26: style: Unused variable: finisec [unusedVariable]
   STATIC long startsec, finisec;
                         ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/whetstone.c:151:20: style: Unused variable: KIPS [unusedVariable]
   STATIC double_t KIPS;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/whetstone.c:150:16: style: Variable 'startsec' is not assigned a value. [unassignedVariable]
   STATIC long startsec, finisec;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/z88dk-classic/whetstone.c:173:1: style: Label 'LCONT' is not used. There is #if in function body so the label might be used in code that is removed by the preprocessor. [unusedLabelConfiguration]
LCONT:
^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/z88dk-classic/whetstone.c:147:16: style: Unused variable: startsec [unusedVariable]
   STATIC long startsec, finisec;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/z88dk-classic/whetstone.c:147:26: style: Unused variable: finisec [unusedVariable]
   STATIC long startsec, finisec;
                         ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/z88dk-classic/whetstone.c:148:20: style: Unused variable: KIPS [unusedVariable]
   STATIC double_t KIPS;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/z88dk-classic/whetstone.c:147:16: style: Variable 'startsec' is not assigned a value. [unassignedVariable]
   STATIC long startsec, finisec;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/z88dk-new/whetstone.c:176:1: style: Label 'LCONT' is not used. There is #if in function body so the label might be used in code that is removed by the preprocessor. [unusedLabelConfiguration]
LCONT:
^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/z88dk-new/whetstone.c:150:16: style: Unused variable: startsec [unusedVariable]
   STATIC long startsec, finisec;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/z88dk-new/whetstone.c:150:26: style: Unused variable: finisec [unusedVariable]
   STATIC long startsec, finisec;
                         ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/z88dk-new/whetstone.c:151:20: style: Unused variable: KIPS [unusedVariable]
   STATIC double_t KIPS;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/whetstone/z88dk-new/whetstone.c:150:16: style: Variable 'startsec' is not assigned a value. [unassignedVariable]
   STATIC long startsec, finisec;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:422:16: warning: Either the condition 'ch<0' is redundant or ungetc() argument nr 1 can have invalid value. The value is -1 but the valid values are '0:255'. [invalidFunctionArg]
        ungetc(ch, stdin);
               ^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:420:45: note: Assuming that condition 'ch<0' is not redundant
      if (isspace(ch) || iscntrl(ch) || (ch < 0)
                                            ^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:422:16: note: Invalid argument
        ungetc(ch, stdin);
               ^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:981:9: style: Variable 'r' is reassigned a value before the old one has been used. [redundantAssignment]
      r = 1 / d;
        ^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:975:9: note: r is assigned
      r = 1;
        ^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:981:9: note: r is overwritten
      r = 1 / d;
        ^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:371:9: style: The scope of the variable 's' can be reduced. [variableScope]
  long  s, v;
        ^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:589:7: style: The scope of the variable 'n' can be reduced. [variableScope]
  int n;
      ^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:773:9: style: The scope of the variable 'x' can be reduced. [variableScope]
  long  x, y;
        ^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:773:12: style: The scope of the variable 'y' can be reduced. [variableScope]
  long  x, y;
           ^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:771:27: style:inconclusive: Function 'eval_args' argument 2 names different: declaration 'a' definition 'arg'. [funcArgNamesDifferent]
eval_args(long func, long arg, long av[2], int n)
                          ^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:272:33: note: Function 'eval_args' argument 2 names different: declaration 'a' definition 'arg'.
long  eval_args(long func, long a, long av[2], int n);
                                ^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:771:27: note: Function 'eval_args' argument 2 names different: declaration 'a' definition 'arg'.
eval_args(long func, long arg, long av[2], int n)
                          ^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:1052:12: style:inconclusive: Function 'apply' argument 1 names different: declaration 'f' definition 'func'. [funcArgNamesDifferent]
apply(long func, long aparams, int n)
           ^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:275:18: note: Function 'apply' argument 1 names different: declaration 'f' definition 'func'.
long  apply(long f, long args, int n);
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:1052:12: note: Function 'apply' argument 1 names different: declaration 'f' definition 'func'.
apply(long func, long aparams, int n)
           ^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:1052:23: style:inconclusive: Function 'apply' argument 2 names different: declaration 'args' definition 'aparams'. [funcArgNamesDifferent]
apply(long func, long aparams, int n)
                      ^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:275:26: note: Function 'apply' argument 2 names different: declaration 'args' definition 'aparams'.
long  apply(long f, long args, int n);
                         ^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:1052:23: note: Function 'apply' argument 2 names different: declaration 'args' definition 'aparams'.
apply(long func, long aparams, int n)
                      ^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:1067:13: error: Uninitialized variable: fdef [uninitvar]
  f = l_car(fdef);  /* formal parameters */
            ^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:506:8: style: Unused variable: i [unusedVariable]
  int  i;
       ^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:81:0: information: Skipping configuration 'LARGEMEM' since the value of 'LARGEMEM' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
long t_cons_car[NCONS];     /* "car" part of cell */
^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:82:0: information: Skipping configuration 'LARGEMEM' since the value of 'LARGEMEM' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
long t_cons_cdr[NCONS];     /* "cdr" part of cell */
^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:109:0: information: Skipping configuration 'LARGEMEM' since the value of 'LARGEMEM' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
char  t_pnames[PNAME_SIZE];  /* names */
^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:124:0: information: Skipping configuration 'LARGEMEM' since the value of 'LARGEMEM' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
long t_stack[STACK_SIZE];   /* the stack */
^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:339:0: information: Skipping configuration 'LARGEMEM' since the value of 'LARGEMEM' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  for (i = 0; i != NCONS-1; i++)
^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:341:0: information: Skipping configuration 'LARGEMEM' since the value of 'LARGEMEM' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  t_cons_car[NCONS-1] = NCONS-1;    /* self-loop (this is very important) */
^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:1057:0: information: Skipping configuration 'LARGEMEM' since the value of 'LARGEMEM' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  if (t_stack_ptr + n > STACK_SIZE)   /* stack overflow */
^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:1202:0: information: Skipping configuration 'LARGEMEM' since the value of 'LARGEMEM' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  for (i = 0, n = 0; i != NCONS; i++){
^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:1239:0: information: Skipping configuration 'LARGEMEM' since the value of 'LARGEMEM' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    if (t_stack_ptr >= STACK_SIZE)     /* stack overflow */
^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:1295:0: information: Skipping configuration 'LARGEMEM' since the value of 'LARGEMEM' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    if (t_pnames_free == PNAME_SIZE){
^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:667:7: style: Variable 'l' is reassigned a value before the old one has been used. [redundantAssignment]
    l = list_len(l_car(t));  /* #args */
      ^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:659:7: note: l is assigned
    l = list_len(t);  /* #args */
      ^
libsrc/_DEVELOPMENT/EXAMPLES/clisp.c:667:7: note: l is overwritten
    l = list_len(l_car(t));  /* #args */
      ^
libsrc/_DEVELOPMENT/EXAMPLES/cmdline.c:15:4: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
   printf("\nCommand line words: %u\n\n", argc);
   ^
libsrc/_DEVELOPMENT/EXAMPLES/cmdline.c:18:7: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
      printf("%u : %s\n", i+1, argv[i]);
      ^
libsrc/_DEVELOPMENT/EXAMPLES/eliza.c:234:24: style: The scope of the variable 'input' can be reduced. [variableScope]
 static unsigned char* input;   // User's input
                       ^
libsrc/_DEVELOPMENT/EXAMPLES/empire.c:546:4: warning: printf format string requires 2 parameters but 3 are given. [wrongPrintfScanfArgNum]
   printf("  Country%10sBushels%4sPrice\n", "", "", "");
   ^
libsrc/_DEVELOPMENT/EXAMPLES/empire.c:191:4: portability: fflush() called on input stream 'stdin' may result in undefined behaviour on non-linux systems. [fflushOnInputStream]
   fflush(stdin);
   ^
libsrc/_DEVELOPMENT/EXAMPLES/empire.c:193:1: error: va_list 'arg' was opened but not closed by va_end(). [va_end_missing]
}
^
libsrc/_DEVELOPMENT/EXAMPLES/fmemopen.c:16:8: style: The scope of the variable 'ch' can be reduced. [variableScope]
   int ch;
       ^
libsrc/_DEVELOPMENT/EXAMPLES/getline.c:28:10: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
         printf("Terminating char = %u\n", (int)term);
         ^
libsrc/_DEVELOPMENT/EXAMPLES/getline.c:19:7: portability: fflush() called on input stream 'stdin' may result in undefined behaviour on non-linux systems. [fflushOnInputStream]
      fflush(stdin);
      ^
libsrc/_DEVELOPMENT/EXAMPLES/getline.c:13:17: style: The scope of the variable 'slen' can be reduced. [variableScope]
   unsigned int slen;
                ^
libsrc/_DEVELOPMENT/EXAMPLES/malloc_test.c:73:10: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'void *'. [invalidPrintfArgType_uint]
         PRINTF3("Slot %2u : free      %5u\n", vic, p[vic]);
         ^
libsrc/_DEVELOPMENT/EXAMPLES/malloc_test.c:88:13: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'void *'. [invalidPrintfArgType_uint]
            PRINTF4("Slot %2u : malloc at %5u %u bytes\n", vic, p[vic], sz[vic]);
            ^
libsrc/_DEVELOPMENT/EXAMPLES/password.c:48:7: portability: fflush() called on input stream 'stdin' may result in undefined behaviour on non-linux systems. [fflushOnInputStream]
      fflush(stdin);
      ^
libsrc/_DEVELOPMENT/EXAMPLES/password.c:64:7: portability: fflush() called on input stream 'stdin' may result in undefined behaviour on non-linux systems. [fflushOnInputStream]
      fflush(stdin);
      ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/map.h:92:4: style: Variable 'a' is reassigned a value before the old one has been used. [redundantAssignment]
  a=(mpy5)%maplineslength;
   ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/map.h:89:4: note: a is assigned
  a=mpy5%maplineslength;
   ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/map.h:92:4: note: a is overwritten
  a=(mpy5)%maplineslength;
   ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/timeredlabel.h:55:16: style: The scope of the variable 'tl' can be reduced. [variableScope]
 timeredlabel *tl;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/map.h:68:6: style: The scope of the variable 'a' can be reduced. [variableScope]
 int a,c;
     ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/map.h:68:8: style: The scope of the variable 'c' can be reduced. [variableScope]
 int a,c;
       ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/scroller.h:19:10: style: The scope of the variable 'sc' can be reduced. [variableScope]
 scroll *sc;
         ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/explosion.h:4:13: style: The scope of the variable 'exa' can be reduced. [variableScope]
 explosion *exa,*exb;
            ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/explosion.h:51:13: style: The scope of the variable 'ex' can be reduced. [variableScope]
 explosion *ex;
            ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/warning.h:8:15: style: The scope of the variable 's' can be reduced. [variableScope]
 unsigned int s;
              ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/waveship.h:9:13: style: The scope of the variable 'p' can be reduced. [variableScope]
 signed int p;
            ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/stage5endboss.h:14:16: style: The scope of the variable 'a' can be reduced. [variableScope]
 unsigned char a;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/vulcanstation.h:9:16: style: The scope of the variable 'a' can be reduced. [variableScope]
 unsigned char a;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/stage6endboss.h:63:16: style: The scope of the variable 'a' can be reduced. [variableScope]
 unsigned char a;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/stage6endboss.h:178:16: style: The scope of the variable 'a' can be reduced. [variableScope]
 unsigned char a;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/stage8bossb.h:3:16: style: The scope of the variable 'a' can be reduced. [variableScope]
 unsigned char a;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/enemy.h:33:9: style: The scope of the variable 'ea' can be reduced. [variableScope]
 enemy *ea,*eb;
        ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/enemy.h:91:14: style: The scope of the variable 'a' can be reduced. [variableScope]
 signed char a;
             ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/enemy.h:164:14: style: The scope of the variable 'q' can be reduced. [variableScope]
 signed char q;
             ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/enemy.h:178:9: style: The scope of the variable 'en' can be reduced. [variableScope]
 enemy *en;
        ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/scripter.h:8:10: style: The scope of the variable 'sc' can be reduced. [variableScope]
 script *sc;
         ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/scripter.h:27:10: style: The scope of the variable 'sa' can be reduced. [variableScope]
 script *sa,*sb;
         ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/scripter.h:49:16: style: The scope of the variable 'sa' can be reduced. [variableScope]
 unsigned char sa,sb,sc;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/scripter.h:49:19: style: The scope of the variable 'sb' can be reduced. [variableScope]
 unsigned char sa,sb,sc;
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/scripter.h:49:22: style: The scope of the variable 'sc' can be reduced. [variableScope]
 unsigned char sa,sb,sc;
                     ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/scripter.h:130:14: style: The scope of the variable 'q' can be reduced. [variableScope]
 signed char q;
             ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/selectorstage.h:5:16: style: The scope of the variable 'c' can be reduced. [variableScope]
 unsigned char c;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/selectorstage.h:6:16: style: The scope of the variable 'd' can be reduced. [variableScope]
 unsigned char d=0;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/stage4.h:3:16: style: The scope of the variable 'p' can be reduced. [variableScope]
 unsigned char p;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/enemyshoot.h:9:14: style: The scope of the variable 'es' can be reduced. [variableScope]
 enemyshoot *es;
             ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/enemyshoot.h:41:14: style: The scope of the variable 'es' can be reduced. [variableScope]
 enemyshoot *es;
             ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/enemyshoot.h:70:13: style: The scope of the variable 'dx' can be reduced. [variableScope]
 signed int dx,dy,dm;
            ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/enemyshoot.h:70:16: style: The scope of the variable 'dy' can be reduced. [variableScope]
 signed int dx,dy,dm;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/enemyshoot.h:70:19: style: The scope of the variable 'dm' can be reduced. [variableScope]
 signed int dx,dy,dm;
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/enemyshoot.h:71:14: style: The scope of the variable 'es' can be reduced. [variableScope]
 enemyshoot *es;
             ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/enemyshoot.h:129:14: style: The scope of the variable 'esa' can be reduced. [variableScope]
 enemyshoot *esa,*esb;
             ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/playershoot.h:38:15: style: The scope of the variable 'psa' can be reduced. [variableScope]
 playershoot *psa,*psb;
              ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/playershoot.h:59:9: style: The scope of the variable 'en' can be reduced. [variableScope]
 enemy *en;
        ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/playershoot.h:60:14: style: The scope of the variable 'b' can be reduced. [variableScope]
 signed char b;
             ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/playstage.h:59:17: style: Local variable 'palette_bin' shadows outer variable [shadowVariable]
 unsigned char *palette_bin;
                ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/fixedbank.h:159:28: note: Shadowed declaration
extern const unsigned char palette_bin[];
                           ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/playstage.h:59:17: note: Shadow variable
 unsigned char *palette_bin;
                ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/selectorstage.h:6:17: style: Variable 'd' is assigned a value that is never used. [unreadVariable]
 unsigned char d=0;
                ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/player.h:31:2: style:inconclusive: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
 if(numenemies>0)
 ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/AstroForce/src/player.h:57:2: style:inconclusive: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
 if(numenemyshoots>0)
 ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/BalubaBalok/src/game.c:1052:20: style: The scope of the variable 'd' can be reduced. [variableScope]
 unsigned char b,c,d;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/BalubaBalok/src/game.c:1116:18: style: The scope of the variable 'x' can be reduced. [variableScope]
 unsigned char c,x,y;
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/BalubaBalok/src/game.c:1116:20: style: The scope of the variable 'y' can be reduced. [variableScope]
 unsigned char c,x,y;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/BalubaBalok/src/game.c:1117:15: style: The scope of the variable 'b' can be reduced. [variableScope]
 unsigned int b;
              ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/BalubaBalok/src/game.c:1136:18: style: The scope of the variable 'x' can be reduced. [variableScope]
 unsigned char c,x,y;
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/BalubaBalok/src/game.c:1136:20: style: The scope of the variable 'y' can be reduced. [variableScope]
 unsigned char c,x,y;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/BalubaBalok/src/game.c:1137:15: style: The scope of the variable 'b' can be reduced. [variableScope]
 unsigned int b;
              ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/BalubaBalok/src/game.c:1463:15: style: The scope of the variable 'ks' can be reduced. [variableScope]
 unsigned int ks;
              ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/BalubaBalok/src/game.c:1079:14: warning: Either the condition 'numenemies>0' is redundant or there is division by zero at line 1079. [zerodivcond]
 b=stageframe%numenemies;
             ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/BalubaBalok/src/game.c:1080:15: note: Assuming that condition 'numenemies>0' is not redundant
 if(numenemies>0)
              ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/BalubaBalok/src/game.c:1079:14: note: Division by zero
 b=stageframe%numenemies;
             ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/CandyKidDemo/screen/ready_screen.h:20:2: warning: Return value of function rand() is not used. [ignoredReturnValue]
 rand();
 ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/CandyKidDemo/engine/font_manager.h:30:14: style: The scope of the variable 'tile' can be reduced. [variableScope]
 signed char tile;
             ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/CandyKidDemo/engine/font_manager.h:32:15: style: The scope of the variable 'quotient' can be reduced. [variableScope]
 unsigned int quotient = 0;
              ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/CandyKidDemo/engine/font_manager.h:33:16: style: The scope of the variable 'remainder' can be reduced. [variableScope]
 unsigned char remainder = 0;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/CandyKidDemo/engine/font_manager.h:61:14: style: The scope of the variable 'tile' can be reduced. [variableScope]
 signed char tile;
             ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/CandyKidDemo/engine/sound_manager.h:6:16: style: The scope of the variable 'sound' can be reduced. [variableScope]
 unsigned char sound;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/CandyKidDemo/engine/font_manager.h:32:24: style: Variable 'quotient' is assigned a value that is never used. [unreadVariable]
 unsigned int quotient = 0;
                       ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/CandyKidDemo/engine/font_manager.h:33:26: style: Variable 'remainder' is assigned a value that is never used. [unreadVariable]
 unsigned char remainder = 0;
                         ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/game/game_enemies.c:338:31: warning: Either the condition 'spawnIndex>=(16*8+12)' is redundant or the array 'flyingRandom[140]' is accessed at index 140, which is out of bounds. [arrayIndexOutOfBoundsCond]
 u8 randomEnemy = flyingRandom[spawnIndex++] / 7;
                              ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/game/game_enemies.c:339:17: note: Assuming that condition 'spawnIndex>=(16*8+12)' is not redundant
 if (spawnIndex >= RANDOM_SIZE) spawnIndex = 0;
                ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/game/game_enemies.c:338:31: note: Array index out of bounds
 u8 randomEnemy = flyingRandom[spawnIndex++] / 7;
                              ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/game/game_enemies.c:531:9: style: The scope of the variable 'e' can be reduced. [variableScope]
 enemy *e;
        ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/game/game_enemies.c:764:9: style: The scope of the variable 'e' can be reduced. [variableScope]
 enemy *e;
        ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/game/game_enemies.c:807:12: style: The scope of the variable 'bomb' can be reduced. [variableScope]
 fixPoint *bomb;
           ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/game/game_enemies.c:382:5: style: Unused variable: scratchByte [unusedVariable]
 u8 scratchByte;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/game/game_enemies.c:593:11: style: Unused variable: bomb [unusedVariable]
 fixPoint bomb;
          ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/game/game_hud.c:26:6: style: Variable 'i' is assigned a value that is never used. [unreadVariable]
 u8 i=0;
     ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/game/game_hud.c:68:7: style: Unused variable: intChar [unusedVariable]
 char intChar[5];
      ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/game/game_mines.c:120:8: style: The scope of the variable 'diff' can be reduced. [variableScope]
 fix16 diff;
       ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/game/game_mines.c:121:12: style: The scope of the variable 'minePos' can be reduced. [variableScope]
 fixPoint *minePos;
           ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/game/game_mines.c:169:12: style: The scope of the variable 'point' can be reduced. [variableScope]
 fixPoint *point;
           ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/game/game_mines.c:220:8: style: The scope of the variable 'dir' can be reduced. [variableScope]
 u8 i, dir;
       ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/game/game_mines.c:221:12: style: The scope of the variable 'point' can be reduced. [variableScope]
 fixPoint *point;
           ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/game/game_player.c:281:31: style:inconclusive: Function 'player_inputReleased' argument 1 names different: declaration 'pressed' definition 'released'. [funcArgNamesDifferent]
void player_inputReleased(u16 released, u16 state)
                              ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/game/game_player.h:39:32: note: Function 'player_inputReleased' argument 1 names different: declaration 'pressed' definition 'released'.
void player_inputReleased( u16 pressed, u16 state);
                               ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/game/game_player.c:281:31: note: Function 'player_inputReleased' argument 1 names different: declaration 'pressed' definition 'released'.
void player_inputReleased(u16 released, u16 state)
                              ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/s8/psg_player.c:27:5: style: The scope of the variable 'chan' can be reduced. [variableScope]
 u8 chan, mixer, prevMixer;
    ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/s8/psg_player.c:183:24: style:inconclusive: Function 'psgplayer_play' argument 1 names different: declaration 'track' definition 'trackIdx'. [funcArgNamesDifferent]
void psgplayer_play(u8 trackIdx, void *psgData) //const psgFrame (*psgData)[])
                       ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/s8/psg_player.h:22:24: note: Function 'psgplayer_play' argument 1 names different: declaration 'track' definition 'trackIdx'.
void psgplayer_play(u8 track, void *psgData); //const psgFrame (*psgData)[])
                       ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/s8/psg_player.c:183:24: note: Function 'psgplayer_play' argument 1 names different: declaration 'track' definition 'trackIdx'.
void psgplayer_play(u8 trackIdx, void *psgData) //const psgFrame (*psgData)[])
                       ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/screens/screen_hiscore.c:55:6: style: Variable 'i' is assigned a value that is never used. [unreadVariable]
 u8 i=0;
     ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/screens/screen_hiscore.c:52:5: style: Unused variable: invertString [unusedVariable]
 u8 invertString[6]; //99999 + \0
    ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/compression/compression.c:67:37: error: Subtracting pointers that point to different objects [comparePointers]
   assert(RAWBIN_SIZE == rawbin_end - rawbin);
                                    ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/compression/binaries.h:7:22: note: Variable declared here.
extern unsigned char rawbin_end[];
                     ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/compression/compression.c:67:26: note: Array decayed to pointer here.
   assert(RAWBIN_SIZE == rawbin_end - rawbin);
                         ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/compression/binaries.h:6:22: note: Variable declared here.
extern unsigned char rawbin[];
                     ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/compression/compression.c:67:39: note: Array decayed to pointer here.
   assert(RAWBIN_SIZE == rawbin_end - rawbin);
                                      ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/compression/compression.c:67:37: note: Subtracting pointers that point to different objects
   assert(RAWBIN_SIZE == rawbin_end - rawbin);
                                    ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/datastorm/datastorm.c:450:18: style: Local variable 'sc_p' shadows outer variable [shadowVariable]
  unsigned char *sc_p;
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/datastorm/datastorm.c:122:16: note: Shadowed declaration
unsigned char *sc_p;
               ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/datastorm/datastorm.c:450:18: note: Shadow variable
  unsigned char *sc_p;
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/rasterparallax/main.c:47:19: style: The scope of the variable 'pole_y' can be reduced. [variableScope]
  unsigned char i,pole_y;
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/splitscreen/main.c:67:17: style: Local variable 'i' shadows outer variable [shadowVariable]
  unsigned char i,y;
                ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/splitscreen/main.c:11:15: note: Shadowed declaration
unsigned char i;
              ^
libsrc/_DEVELOPMENT/EXAMPLES/sms/splitscreen/main.c:67:17: note: Shadow variable
  unsigned char i,y;
                ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:489:4: warning: Either the condition 'q2<=8' is redundant or the array 'z[9][9]' is accessed at index z[9][9], which is out of bounds. [arrayIndexOutOfBoundsCond]
  z[q1][q2] = g[q1][q2];
   ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:491:43: note: Assuming that condition 'q2<=8' is not redundant
  if (q1 >= 1 && q1 <= 8 && q2 >= 1 && q2 <= 8)
                                          ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:489:4: note: Array index out of bounds
  z[q1][q2] = g[q1][q2];
   ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:489:16: warning: Either the condition 'q2<=8' is redundant or the array 'g[9][9]' is accessed at index g[9][9], which is out of bounds. [arrayIndexOutOfBoundsCond]
  z[q1][q2] = g[q1][q2];
               ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:491:43: note: Assuming that condition 'q2<=8' is not redundant
  if (q1 >= 1 && q1 <= 8 && q2 >= 1 && q2 <= 8)
                                          ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:489:16: note: Array index out of bounds
  z[q1][q2] = g[q1][q2];
               ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:1774:22: style: The statement 'if (d1!=1) d1=1' is logically equivalent to 'd1=1'. [duplicateConditionalAssign]
              if (d1 != 1)
                     ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:1775:20: note: Assignment 'd1=1'
                d1 = 1;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:1774:22: note: Condition 'd1!=1' is redundant
              if (d1 != 1)
                     ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:263:3: portability: fflush() called on input stream 'stdin' may result in undefined behaviour on non-linux systems. [fflushOnInputStream]
  fflush(stdin);
  ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:473:3: portability: fflush() called on input stream 'stdin' may result in undefined behaviour on non-linux systems. [fflushOnInputStream]
  fflush(stdin);   /** Z88DK **/
  ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:1151:7: style: The scope of the variable 'i' can be reduced. [variableScope]
  int i, x3, y3;
      ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:1220:7: style: The scope of the variable 'a1' can be reduced. [variableScope]
  int a1;
      ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:1221:12: style: The scope of the variable 'd3' can be reduced. [variableScope]
  double_t d3 = 0.0;
           ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:1505:13: style: The scope of the variable 'j0' can be reduced. [variableScope]
  int i, j, j0;
            ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:1658:10: style: The scope of the variable 'sTemp' can be reduced. [variableScope]
  string sTemp;
         ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:1888:17: style: The scope of the variable 'sect_name' can be reduced. [variableScope]
  static char * sect_name[] = {""," I"," II"," III"," IV"};
                ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:587:12: style: Local variable 'c1' shadows outer variable [shadowVariable]
  double_t c1;
           ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:242:13: note: Shadowed declaration
double_t a, c1;                   /* Used by Library Computer */
            ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:587:12: note: Shadow variable
  double_t c1;
           ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:1064:12: style: Local variable 'c1' shadows outer variable [shadowVariable]
  double_t c1;
           ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:242:13: note: Shadowed declaration
double_t a, c1;                   /* Used by Library Computer */
            ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:1064:12: note: Shadow variable
  double_t c1;
           ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:2182:12: style: Local variable 'd' shadows outer variable [shadowVariable]
  double_t d;
           ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:243:10: note: Shadowed declaration
double_t d[9];                                /* Damage Array */
         ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:2182:12: note: Shadow variable
  double_t d;
           ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:675:6: style: Variable 'q4' is assigned a value that is never used. [unreadVariable]
  q4 = q1;
     ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:676:6: style: Variable 'q5' is assigned a value that is never used. [unreadVariable]
  q5 = q2;
     ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:1115:6: style: Variable 'x5' is assigned a value that is never used. [unreadVariable]
  x5 = 0;
     ^
libsrc/_DEVELOPMENT/EXAMPLES/startrek.c:1221:15: style: Variable 'd3' is assigned a value that is never used. [unreadVariable]
  double_t d3 = 0.0;
              ^
libsrc/_DEVELOPMENT/EXAMPLES/sudoku.c:293:7: portability: fflush() called on input stream 'stdin' may result in undefined behaviour on non-linux systems. [fflushOnInputStream]
      fflush(stdin);
      ^
libsrc/_DEVELOPMENT/EXAMPLES/sudoku.c:85:12: style: The scope of the variable 'i' can be reduced. [variableScope]
   uint8_t i;
           ^
libsrc/_DEVELOPMENT/EXAMPLES/umchess.c:54:8: style:inconclusive: Boolean expression 'z==8' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
   z==8&K==I&&(N<200&d<98||
       ^
libsrc/_DEVELOPMENT/EXAMPLES/umchess.c:54:21: style:inconclusive: Boolean expression 'N<200' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
   z==8&K==I&&(N<200&d<98||
                    ^
libsrc/_DEVELOPMENT/EXAMPLES/umchess.c:64:12: style:inconclusive: Boolean expression 'p>2' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
    W(r=p>2&r<0?-r:-o[++j])
           ^
libsrc/_DEVELOPMENT/EXAMPLES/umchess.c:70:25: style:inconclusive: Boolean expression 'y-E<2' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
      m=E-S&&b[E]&&y-E<2&E-y<2?I:m;    /* castling-on-Pawn-check bug fixed */
                        ^
libsrc/_DEVELOPMENT/EXAMPLES/umchess.c:71:13: style:inconclusive: Boolean expression 'p<3' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
      if(p<3&y==E)H^=16;
            ^
libsrc/_DEVELOPMENT/EXAMPLES/umchess.c:72:24: style:inconclusive: Boolean expression 'p<3' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
      t=b[H];if(t&k|p<3&!(y-x&7)-!t)break;
                       ^
libsrc/_DEVELOPMENT/EXAMPLES/umchess.c:88:21: style:inconclusive: Boolean expression 'x==K' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
       {if(v+I&&x==K&y==L&z==8)
                    ^
libsrc/_DEVELOPMENT/EXAMPLES/umchess.c:88:26: style:inconclusive: Boolean expression 'z==8' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
       {if(v+I&&x==K&y==L&z==8)
                         ^
libsrc/_DEVELOPMENT/EXAMPLES/umchess.c:100:13: style:inconclusive: Boolean expression 'p>2' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
         p>2&(p-3|j-7||
            ^
libsrc/_DEVELOPMENT/EXAMPLES/umchess.c:107:11: style:inconclusive: Boolean expression 'm>I-M' is used in bitwise operation. Did you mean '||'? [bitwiseOnBoolean]
C:if(m>I-M|m<M-I)d=98;
          ^
libsrc/_DEVELOPMENT/EXAMPLES/umchess.c:54:8: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
   z==8&K==I&&(N<200&d<98||
       ^
libsrc/_DEVELOPMENT/EXAMPLES/umchess.c:64:6: style: Suspicious condition (assignment + comparison); Clarify expression with parentheses. [clarifyCondition]
    W(r=p>2&r<0?-r:-o[++j])
     ^
libsrc/_DEVELOPMENT/EXAMPLES/umchess.c:64:12: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
    W(r=p>2&r<0?-r:-o[++j])
           ^
libsrc/_DEVELOPMENT/EXAMPLES/umchess.c:70:25: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
      m=E-S&&b[E]&&y-E<2&E-y<2?I:m;    /* castling-on-Pawn-check bug fixed */
                        ^
libsrc/_DEVELOPMENT/EXAMPLES/umchess.c:71:13: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
      if(p<3&y==E)H^=16;
            ^
libsrc/_DEVELOPMENT/EXAMPLES/umchess.c:72:24: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
      t=b[H];if(t&k|p<3&!(y-x&7)-!t)break;
                       ^
libsrc/_DEVELOPMENT/EXAMPLES/umchess.c:88:21: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
       {if(v+I&&x==K&y==L&z==8)
                    ^
libsrc/_DEVELOPMENT/EXAMPLES/umchess.c:100:13: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
         p>2&(p-3|j-7||
            ^
libsrc/_DEVELOPMENT/EXAMPLES/umchess.c:107:11: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
C:if(m>I-M|m<M-I)d=98;
          ^
libsrc/_DEVELOPMENT/EXAMPLES/umchess.c:64:16: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
    W(r=p>2&r<0?-r:-o[++j])
               ^
libsrc/_DEVELOPMENT/EXAMPLES/umchess.c:108:8: style: Clarify calculation precedence for '+' and '?'. [clarifyCalculation]
  m=m+I?m:-D(24-k,-I,I,0,S,S,1);
       ^
libsrc/_DEVELOPMENT/EXAMPLES/umchess.c:128:25: style: Clarify calculation precedence for '-' and '?'. [clarifyCalculation]
  k^=D(k,-I,I,Q,O,8,2)-I?0:24;
                        ^
libsrc/_DEVELOPMENT/EXAMPLES/z80/stdio/test.c:14:7: portability: fflush() called on input stream 'stdin' may result in undefined behaviour on non-linux systems. [fflushOnInputStream]
      fflush(stdin);
      ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_bifrost2/bifrost2dem.c:40:9: style: The scope of the variable 'px' can be reduced. [variableScope]
    int px, py, tile, attr, f, key;
        ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_bifrost2/bifrost2dem.c:40:13: style: The scope of the variable 'py' can be reduced. [variableScope]
    int px, py, tile, attr, f, key;
            ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_bifrost2/bifrost2dem.c:40:32: style: The scope of the variable 'key' can be reduced. [variableScope]
    int px, py, tile, attr, f, key;
                               ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_sp1/BlackStar/src/main.c:853:20: style: Checking if unsigned expression 'lives' is less than zero. [unsignedLessThanZero]
         if (lives <= 0)
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_sp1/demo2/demo.c:118:10: error: Array 'levelb[2304]' accessed at index 4294967285, which is out of bounds. [arrayIndexOutOfBounds]
   levelb[p]=84;
         ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_sp1/demo2/demo.c:98:8: note: Assignment 'p=0', assigned value is 0
   p = 0;
       ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_sp1/demo2/demo.c:113:7: note: Compound assignment '+=', assigned value is 3
      p += 3;
      ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_sp1/demo2/demo.c:116:10: note: Assignment 'p=p-15+1', assigned value is 4294967285
   p=p-15+1;
         ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_sp1/demo2/demo.c:118:10: note: Array index out of bounds
   levelb[p]=84;
         ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_sp1/demo2/demo.c:119:10: error: Array 'levelb[2304]' accessed at index 4294967288, which is out of bounds. [arrayIndexOutOfBounds]
   levelb[p+3]=73;
         ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_sp1/demo2/demo.c:98:8: note: Assignment 'p=0', assigned value is 0
   p = 0;
       ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_sp1/demo2/demo.c:113:7: note: Compound assignment '+=', assigned value is 3
      p += 3;
      ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_sp1/demo2/demo.c:116:10: note: Assignment 'p=p-15+1', assigned value is 4294967285
   p=p-15+1;
         ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_sp1/demo2/demo.c:119:10: note: Array index out of bounds
   levelb[p+3]=73;
         ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_sp1/demo2/demo.c:120:10: error: Array 'levelb[2304]' accessed at index 4294967291, which is out of bounds. [arrayIndexOutOfBounds]
   levelb[p+6]=77;
         ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_sp1/demo2/demo.c:98:8: note: Assignment 'p=0', assigned value is 0
   p = 0;
       ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_sp1/demo2/demo.c:113:7: note: Compound assignment '+=', assigned value is 3
      p += 3;
      ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_sp1/demo2/demo.c:116:10: note: Assignment 'p=p-15+1', assigned value is 4294967285
   p=p-15+1;
         ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_sp1/demo2/demo.c:120:10: note: Array index out of bounds
   levelb[p+6]=77;
         ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_sp1/demo2/demo.c:121:10: error: Array 'levelb[2304]' accessed at index 4294967294, which is out of bounds. [arrayIndexOutOfBounds]
   levelb[p+9]=77;
         ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_sp1/demo2/demo.c:98:8: note: Assignment 'p=0', assigned value is 0
   p = 0;
       ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_sp1/demo2/demo.c:113:7: note: Compound assignment '+=', assigned value is 3
      p += 3;
      ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_sp1/demo2/demo.c:116:10: note: Assignment 'p=p-15+1', assigned value is 4294967285
   p=p-15+1;
         ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_sp1/demo2/demo.c:121:10: note: Array index out of bounds
   levelb[p+9]=77;
         ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_sp1/demo2/demo.c:122:10: error: Array 'levelb[2304]' accessed at index 4294967297, which is out of bounds. [arrayIndexOutOfBounds]
   levelb[p+12]=89;
         ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_sp1/demo2/demo.c:98:8: note: Assignment 'p=0', assigned value is 0
   p = 0;
       ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_sp1/demo2/demo.c:113:7: note: Compound assignment '+=', assigned value is 3
      p += 3;
      ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_sp1/demo2/demo.c:116:10: note: Assignment 'p=p-15+1', assigned value is 4294967285
   p=p-15+1;
         ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_sp1/demo2/demo.c:122:10: note: Array index out of bounds
   levelb[p+12]=89;
         ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_sp1/demo2/demo.c:161:19: style: The scope of the variable 's' can be reduced. [variableScope]
   struct sp1_ss *s;
                  ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_tritone/tritone.c:81:24: warning: %n in format string (no. 2) requires 'int *' but the argument type is 'unsigned int *'. [invalidScanfArgType_int]
      for (offset = 0; sscanf(buffer + offset, "%u%n", &i, &j) == 1; offset += j)
                       ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/demo_tritone/tritone.c:78:7: portability: fflush() called on input stream 'stdin' may result in undefined behaviour on non-linux systems. [fflushOnInputStream]
      fflush(stdin);
      ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/dot-command/dzx7/dzx7.c:195:8: style: The scope of the variable 'i' can be reduced. [variableScope]
   int i;
       ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/dot-command/dzx7/dzx7.c:104:20: error: va_list 'v' was opened but not closed by va_end(). [va_end_missing]
   return (int)ebuf;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/dot-command/extract/extract.c:109:7: warning: %lX in format string (no. 1) requires 'unsigned long' but the argument type is 'unsigned int'. [invalidPrintfArgType_uint]
      printf("%08lX\n", base);
      ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/dot-command/extract/extract.c:101:26: style: Local variable 'buffer' shadows outer variable [shadowVariable]
   static unsigned char *buffer;
                         ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/dot-command/extract/extract.c:67:15: note: Shadowed declaration
unsigned char buffer[512];   // file buffer
              ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/dot-command/extract/extract.c:101:26: note: Shadow variable
   static unsigned char *buffer;
                         ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/dot-command/extract/extract.c:94:20: error: va_list 'v' was opened but not closed by va_end(). [va_end_missing]
   return (int)ebuf;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/dot-command/extract/extract.c:405:13: warning: %lu in format string (no. 2) requires 'unsigned long' but the argument type is 'unsigned int'. [invalidPrintfArgType_uint]
            printf("Stopped at page %u (%lu bytes)\n", (unsigned int)(page_number(options.memaddr)), total);
            ^
libsrc/_DEVELOPMENT/EXAMPLES/zx/two_terminals/terminals_x2.c:42:10: portability: fflush() called on input stream 'stdin' may result in undefined behaviour on non-linux systems. [fflushOnInputStream]
         fflush(stdin);
         ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/dzx7/128/dzx7.c:184:8: style: The scope of the variable 'i' can be reduced. [variableScope]
   int i;
       ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/dzx7/128/dzx7.c:90:20: error: va_list 'v' was opened but not closed by va_end(). [va_end_missing]
   return (int)ebuf;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/dzx7/48/dzx7.c:183:8: style: The scope of the variable 'i' can be reduced. [variableScope]
   int i;
       ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/dzx7/48/dzx7.c:89:20: error: va_list 'v' was opened but not closed by va_end(). [va_end_missing]
   return (int)ebuf;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/extract/extract.c:93:7: warning: %lX in format string (no. 1) requires 'unsigned long' but the argument type is 'unsigned int'. [invalidPrintfArgType_uint]
      printf("%08lX%s", base, (screen_mode.cols == 0) ? "\n" : " ");
      ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/extract/extract.c:407:13: warning: %lu in format string (no. 2) requires 'unsigned long' but the argument type is 'unsigned int'. [invalidPrintfArgType_uint]
            printf("Stopped at page %u (%lu bytes)\n", (unsigned int)(zxn_page_from_addr(options.memaddr)), total);
            ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/extract/extract.c:83:26: style: Local variable 'buffer' shadows outer variable [shadowVariable]
   static unsigned char *buffer;
                         ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/extract/extract.c:51:15: note: Shadowed declaration
unsigned char buffer[512];   // file buffer
              ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/extract/extract.c:83:26: note: Shadow variable
   static unsigned char *buffer;
                         ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/extract/extract.c:76:20: error: va_list 'v' was opened but not closed by va_end(). [va_end_missing]
   return (int)ebuf;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/find/128/directory.c:22:30: style: The scope of the variable 'last' can be reduced. [variableScope]
   static struct dir_record *last;
                             ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/find/128/find.c:115:25: style: The scope of the variable 'first' can be reduced. [variableScope]
   static unsigned char first;
                        ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/find/128/find.c:117:23: style: The scope of the variable 'found' can be reduced. [variableScope]
   static struct opt *found;
                      ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/find/128/options.c:205:22: style: The scope of the variable 'multiplier' can be reduced. [variableScope]
      static int32_t multiplier;
                     ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/find/128/options.c:316:25: style: The scope of the variable 'dirnam' can be reduced. [variableScope]
   static unsigned char dirnam[ESX_PATHNAME_MAX + 1];
                        ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/ls/128/catalog.c:30:30: style: The scope of the variable 'last' can be reduced. [variableScope]
   static struct dir_record *last;
                             ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/ls/128/catalog.c:171:18: style: The scope of the variable 'another' can be reduced. [variableScope]
   unsigned char another;
                 ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/ls/128/catalog.c:174:25: style: The scope of the variable 'enter_dir' can be reduced. [variableScope]
   static unsigned char enter_dir;
                        ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/ls/128/catalog.c:175:25: style: The scope of the variable 'dots' can be reduced. [variableScope]
   static unsigned char dots;
                        ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/ls/128/catalog.c:176:25: style: The scope of the variable 'filter' can be reduced. [variableScope]
   static unsigned char filter;
                        ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/ls/128/catalog.c:295:25: style: The scope of the variable 'dots' can be reduced. [variableScope]
   static unsigned char dots;
                        ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/ls/128/catalog.c:296:25: style: The scope of the variable 'filter' can be reduced. [variableScope]
   static unsigned char filter;
                        ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/ls/128/date.c:30:7: warning: sprintf format string requires 2 parameters but 4 are given. [wrongPrintfScanfArgNum]
      sprintf(buffer, "%02u-%02u %02:%02", date_tm.tm_mon + 1, date_tm.tm_mday, date_tm.tm_hour, date_tm.tm_min);
      ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/ls/128/list.c:135:13: warning: %lu in format string (no. 2) requires 'unsigned long' but the argument type is 'unsigned int'. [invalidPrintfArgType_uint]
            printf("%-11s %6lu %.*s%s\n", flags.date_func(&frp.fr->time), frp.fr->size, min(flags.disp_width - 20 - strlen(ext), ext - name), name, ext);
            ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/ls/128/list.c:42:24: style: The scope of the variable 'i' can be reduced. [variableScope]
   static unsigned int i;
                       ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/ls/128/list.c:115:36: style: Local variable 'p' shadows outer variable [shadowVariable]
      for (struct file_record_ptr *p = fbase; i--; ++p)
                                   ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/ls/128/list.c:46:22: note: Shadowed declaration
      unsigned char *p;
                     ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/ls/128/list.c:115:36: note: Shadow variable
      for (struct file_record_ptr *p = fbase; i--; ++p)
                                   ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/ls/48/ls.c:36:4: warning: %lu in format string (no. 1) requires 'unsigned long' but the argument type is 'unsigned int'. [invalidPrintfArgType_uint]
   printf(" %6lu %s\n", *ls_size, ls_name);
   ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/mv/128/mv.c:387:21: style: The scope of the variable 'another' can be reduced. [variableScope]
      unsigned char another;
                    ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/run/run.c:103:23: style: The scope of the variable 'found' can be reduced. [variableScope]
   static struct opt *found;
                      ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/dot-command/strings/strings.c:83:20: error: va_list 'v' was opened but not closed by va_end(). [va_end_missing]
   return (int)ebuf;
                   ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/firmware/loader/fat.c:282:17: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned long'. [invalidPrintfArgType_sint]
                printf("Reading directory sector %d\n",iDirectorySector);
                ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/firmware/loader/fat.c:312:13: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned long'. [invalidPrintfArgType_sint]
            printf("GetFATLink returned %d\n",iDirectoryCluster);
            ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/firmware/loader/fat.c:295:25: error: Buffer is accessed out of bounds: (const char*)pEntry->Name [bufferAccessOutOfBounds]
                    if (compare((const char*)pEntry->Name, name, 11) == 0)
                        ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/sprites/mixed-sw-hw/main.c:332:10: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
         printf("\x16\x02\x16" "\x15\x32" "NUM SW SPRITES = %02u", ++num_sw_sprites);
         ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/sprites/mixed-sw-hw/main.c:357:10: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
         printf("\x16\x02\x17" "\x15\x32" "NUM HW SPRITES = %02u", ++num_hw_sprites);
         ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/sprites/mixed-sw-hw/main.c:396:10: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
         printf("\x16\x02\x15" "\x15\x32" "NUM SPLATS     = %02u", ++num_splats);
         ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/sprites/mixed-sw-hw/main.c:127:23: style: The scope of the variable 'u' can be reduced. [variableScope]
   struct sp1_update *u;
                      ^
libsrc/_DEVELOPMENT/EXAMPLES/zxn/sprites/mixed-sw-hw/main.c:239:25: style: The scope of the variable 'c' can be reduced. [variableScope]
   static unsigned char c;
                        ^
libsrc/_DEVELOPMENT/math/float/am9511/c/am9511_atan2.c:6:11: style: The scope of the variable 'v' can be reduced. [variableScope]
    float v;
          ^
libsrc/_DEVELOPMENT/math/float/am9511/c/am9511_round.c:28:11: style: Variable 'signbit' is assigned a value that is never used. [unreadVariable]
  signbit = w & 0x80000000;
          ^
libsrc/_DEVELOPMENT/math/float/math16/c/log10f16.c:36:2: error: syntax error [syntaxError]
 */
 ^
libsrc/_DEVELOPMENT/math/float/math16/c/log2f16.c:40:2: error: syntax error [syntaxError]
 */
 ^
libsrc/_DEVELOPMENT/math/float/math16/c/logf16.c:37:2: error: syntax error [syntaxError]
 */
 ^
libsrc/_DEVELOPMENT/math/float/math32/c/m32_atan2f.c:6:11: style: The scope of the variable 'v' can be reduced. [variableScope]
    float v;
          ^
libsrc/_DEVELOPMENT/math/float/math32/c/m32_roundf.c:28:11: style: Variable 'signbit' is assigned a value that is never used. [unreadVariable]
  signbit = w & 0x80000000;
          ^
libsrc/arch/z80/AsmCall.c:37:18: warning:inconclusive: Found suspicious operator '+' [constStatement]
    ld      l,(ix+0)  ;HL=Routine address
                 ^
libsrc/arch/z80/AsmCall.c:44:13: warning: Found suspicious operator ',' [constStatement]
    ld     a,(ix+4) ;A=in registers detail
            ^
libsrc/arch/z80/AsmCall.c:49:15: warning: Found suspicious operator ',' [constStatement]
    ld      de,CONT
              ^
libsrc/arch/z80/AsmCall.c:124:13: style: Variable 'ld' is assigned a value that is never used. [unreadVariable]
    ld      (ix+11),h
            ^
libsrc/fcntl/gen_rnd/open.c:65:4: portability: Returning an address value in a function with integer return type is not portable. [CastAddressToIntegerAtReturn]
   return(myfile); }
   ^
libsrc/fcntl/gen_rnd/open.c:82:3: portability: Returning an address value in a function with integer return type is not portable. [CastAddressToIntegerAtReturn]
  return(myfile);
  ^
libsrc/fcntl/gen_rnd/open.c:104:3: portability: Returning an address value in a function with integer return type is not portable. [CastAddressToIntegerAtReturn]
  return(myfile);
  ^
libsrc/fcntl/gen_rnd/readbyte.c:33:28: style: Condition 'myfile->name_prefix='Z'' is always true [knownConditionTrueFalse]
  if ((myfile)->name_prefix='Z')
                           ^
libsrc/fcntl/gen_rnd/rename.c:19:5: style: Unused variable: blockcount [unusedVariable]
int blockcount;
    ^
libsrc/fcntl/gen_rnd/writebyte.c:37:28: style: Condition 'myfile->name_prefix='Z'' is always true [knownConditionTrueFalse]
  if ((myfile)->name_prefix='Z')
                           ^
libsrc/games/bit_load_vg5000.c:19:15: style: The scope of the variable 'start' can be reduced. [variableScope]
 unsigned int start,size;
              ^
libsrc/games/bit_load_vg5000.c:19:21: style: The scope of the variable 'size' can be reduced. [variableScope]
 unsigned int start,size;
                    ^
libsrc/games/bit_load_vg5000.c:48:8: style: Variable 'start' is assigned a value that is never used. [unreadVariable]
  start=bit_tapin()+256*bit_tapin();
       ^
libsrc/games/psg_play.c:27:5: style: The scope of the variable 'duration' can be reduced. [variableScope]
int duration=2;
    ^
libsrc/gfx/portable/linedraw.c:10:35: style: The scope of the variable 'e2' can be reduced. [variableScope]
  int err = (dx>dy ? dx : -dy)/2, e2;
                                  ^
libsrc/gfx/x11/XCreateBitmapFromData.c:49:7: style: Unused variable: mychar [unusedVariable]
 char mychar;
      ^
libsrc/gfx/x11/XDrawString.c:28:2: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'GC *'. [invalidPrintfArgType_uint]
 printf (" Drawstring; pick in gc: %u   ...  ", gc);
 ^
libsrc/gfx/x11/XSetFont.c:21:2: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'GC *'. [invalidPrintfArgType_uint]
 printf (" Setting font: %u in GC %u  ", font, mygc);
 ^
libsrc/gfx/x11/_xfindchar.c:38:5: error: syntax error [syntaxError]
 or @11100000
    ^
libsrc/lib3d/object_render_flatshading.c:31:4: style: Redundant initialization for 'm'. The initialized value is overwritten before it is read. [redundantInitialization]
 m = mesh->points;
   ^
libsrc/lib3d/object_render_flatshading.c:25:14: note: m is initialized
 vector_t* m = mesh->points;
             ^
libsrc/lib3d/object_render_flatshading.c:31:4: note: m is overwritten
 m = mesh->points;
   ^
libsrc/lib3d/object_render_flatshading.c:22:12: style: The scope of the variable 'i' can be reduced. [variableScope]
 vector_t *i, *j, *k;
           ^
libsrc/lib3d/object_render_flatshading.c:22:16: style: The scope of the variable 'j' can be reduced. [variableScope]
 vector_t *i, *j, *k;
               ^
libsrc/lib3d/object_render_flatshading.c:22:20: style: The scope of the variable 'k' can be reduced. [variableScope]
 vector_t *i, *j, *k;
                   ^
libsrc/lib3d/object_render_flatshading.c:27:6: style: Unused variable: li [unusedVariable]
 int li;
     ^
libsrc/lib3d/object_render_wireframe.c:27:4: style: Redundant initialization for 'm'. The initialized value is overwritten before it is read. [redundantInitialization]
 m = mesh->points;
   ^
libsrc/lib3d/object_render_wireframe.c:22:14: note: m is initialized
 vector_t* m = mesh->points;
             ^
libsrc/lib3d/object_render_wireframe.c:27:4: note: m is overwritten
 m = mesh->points;
   ^
libsrc/lib3d/object_render_wireframe.c:20:12: style: The scope of the variable 'i' can be reduced. [variableScope]
 vector_t *i, *j, *k, q1, q2;
           ^
libsrc/lib3d/object_render_wireframe.c:20:16: style: The scope of the variable 'j' can be reduced. [variableScope]
 vector_t *i, *j, *k, q1, q2;
               ^
libsrc/lib3d/object_render_wireframe.c:20:20: style: The scope of the variable 'k' can be reduced. [variableScope]
 vector_t *i, *j, *k, q1, q2;
                   ^
libsrc/lib3d/stencil_add_ellipse.c:26:14: style: Variable 'k' is reassigned a value before the old one has been used. [redundantAssignment]
 if (ea==0) k=360; else k=ea;
             ^
libsrc/lib3d/stencil_add_ellipse.c:23:3: note: k is assigned
 k=sa;
  ^
libsrc/lib3d/stencil_add_ellipse.c:26:14: note: k is overwritten
 if (ea==0) k=360; else k=ea;
             ^
libsrc/math/cimpl/ftoe.c:22:13: style: The scope of the variable 'd' can be reduced. [variableScope]
            d,          /* a digit */
            ^
libsrc/math/genmath/ftoe.c:23:17: style: The scope of the variable 'd' can be reduced. [variableScope]
                d,                      /* a digit */
                ^
libsrc/math/genmath/sqrt.c:19:8: error: The address of local variable 'extra' is accessed at non-zero index. [objectIndex]
 pextra[5] = (px[5]>>1)^64 ; /* answer exponent is half of "x" exponent */
       ^
libsrc/math/genmath/sqrt.c:17:11: note: Address of variable taken here.
 pextra = &extra ;   /* set the pointers */
          ^
libsrc/math/genmath/sqrt.c:19:8: note: The address of local variable 'extra' is accessed at non-zero index.
 pextra[5] = (px[5]>>1)^64 ; /* answer exponent is half of "x" exponent */
       ^
libsrc/math/genmath/sqrt.c:19:17: error: The address of local variable 'x' is accessed at non-zero index. [objectIndex]
 pextra[5] = (px[5]>>1)^64 ; /* answer exponent is half of "x" exponent */
                ^
libsrc/math/genmath/sqrt.c:16:7: note: Address of variable taken here.
 px = &x ;
      ^
libsrc/math/genmath/sqrt.c:19:17: note: The address of local variable 'x' is accessed at non-zero index.
 pextra[5] = (px[5]>>1)^64 ; /* answer exponent is half of "x" exponent */
                ^
libsrc/math/genmath/sqrt.c:23:11: error: The address of local variable 'extra' is accessed at non-zero index. [objectIndex]
  --pextra[5] ;   /* /2 */
          ^
libsrc/math/genmath/sqrt.c:17:11: note: Address of variable taken here.
 pextra = &extra ;   /* set the pointers */
          ^
libsrc/math/genmath/sqrt.c:23:11: note: The address of local variable 'extra' is accessed at non-zero index.
  --pextra[5] ;   /* /2 */
          ^
libsrc/math/math48/ftoe_impl.c:23:17: style: The scope of the variable 'd' can be reduced. [variableScope]
                d,                      /* a digit */
                ^
libsrc/regex/regexp.c:224:3: error: Memory leak: r [memleak]
  return(NULL);
  ^
libsrc/regex/regexp.c:194:7: style: The scope of the variable 'len' can be reduced. [variableScope]
  int len;
      ^
libsrc/regex/regexp.c:476:0: information: Skipping configuration 'CHARBITS' since the value of 'CHARBITS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
      class = UCHARAT(regparse-2)+1;
^
libsrc/regex/regexp.c:477:0: information: Skipping configuration 'CHARBITS' since the value of 'CHARBITS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
      classend = UCHARAT(regparse);
^
libsrc/regex/regexp.c:686:0: information: Skipping configuration 'CHARBITS' since the value of 'CHARBITS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (UCHARAT(prog->program) != MAGIC) {
^
libsrc/regex/regexp.c:1022:9: style: The scope of the variable 'next' can be reduced. [variableScope]
  char *next;
        ^
libsrc/regex/regsub.c:49:0: information: Skipping configuration 'CHARBITS' since the value of 'CHARBITS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (UCHARAT(prog->program) != MAGIC) {
^
libsrc/sprites/software/sp1/deprecated/spectrum/examples/ex1.c:150:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/spectrum/examples/ex2a.c:149:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/spectrum/examples/ex2b.c:149:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/spectrum/examples/ex2c.c:151:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/spectrum/examples/ex2d.c:152:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/spectrum/examples/ex2e.c:157:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/spectrum/examples/ex2f.c:162:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/spectrum/examples/ex2g.c:177:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/spectrum/examples/ex2h.c:177:24: error: syntax error [syntaxError]
 DEFB   0,   0,   0,   0
                       ^
libsrc/sprites/software/sp1/deprecated/spectrum/examples/ex3a.c:157:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/spectrum/examples/ex3b.c:166:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/spectrum/examples/ex3c.c:170:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/spectrum/examples/ex4a.c:200:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/spectrum/examples/ex4b.c:202:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/spectrum/examples/ex4c.c:210:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/spectrum/examples/ex5a.c:202:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/spectrum/examples/ex5b.c:232:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/spectrum/examples/ex5c.c:230:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/spectrum/examples/ex5d.c:207:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/spectrum/examples/ex5e.c:353:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/spectrum/examples/ex6a.c:94:13: style: Variable 'zx_border' is assigned a value that is never used. [unreadVariable]
   zx_border(INK_BLACK);
            ^
libsrc/sprites/software/sp1/deprecated/spectrum/examples/ex6b.c:115:1: error: syntax error: ; . _scene [syntaxError]
._scene                        ; C variable "scene" will hold this address
^
libsrc/sprites/software/sp1/deprecated/ts2068hr/examples/ex1.c:155:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/ts2068hr/examples/ex2a.c:154:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/ts2068hr/examples/ex2b.c:154:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/ts2068hr/examples/ex2c.c:156:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/ts2068hr/examples/ex2d.c:157:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/ts2068hr/examples/ex2e.c:162:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/ts2068hr/examples/ex2f.c:167:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/ts2068hr/examples/ex2g.c:182:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/ts2068hr/examples/ex2h.c:182:24: error: syntax error [syntaxError]
 DEFB   0,   0,   0,   0
                       ^
libsrc/sprites/software/sp1/deprecated/ts2068hr/examples/ex3a.c:162:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/ts2068hr/examples/ex3b.c:171:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/ts2068hr/examples/ex3c.c:175:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/ts2068hr/examples/ex4a.c:5:25: error: No pair for character ('). Can't process file. File is either invalid or unicode, which is currently not supported. [syntaxError]
as the hi-res mode doesn't have colour the example does not
                        ^
libsrc/sprites/software/sp1/deprecated/ts2068hr/examples/ex4b.c:5:25: error: No pair for character ('). Can't process file. File is either invalid or unicode, which is currently not supported. [syntaxError]
as the hi-res mode doesn't have colour the example does not
                        ^
libsrc/sprites/software/sp1/deprecated/ts2068hr/examples/ex4c.c:202:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/ts2068hr/examples/ex5a.c:206:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/ts2068hr/examples/ex5b.c:237:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/ts2068hr/examples/ex5c.c:235:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/ts2068hr/examples/ex5d.c:211:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/ts2068hr/examples/ex5e.c:365:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/zx81hr/examples/ex1.c:144:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/zx81hr/examples/ex2a.c:147:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/zx81hr/examples/ex2b.c:147:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/zx81hr/examples/ex2c.c:149:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/zx81hr/examples/ex2d.c:150:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/zx81hr/examples/ex2e.c:155:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/zx81hr/examples/ex2f.c:160:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/zx81hr/examples/ex2g.c:175:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/zx81hr/examples/ex2h.c:175:24: error: syntax error [syntaxError]
 DEFB   0,   0,   0,   0
                       ^
libsrc/sprites/software/sp1/deprecated/zx81hr/examples/ex3a.c:155:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/zx81hr/examples/ex3b.c:164:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/zx81hr/examples/ex3c.c:168:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/zx81hr/examples/ex4a.c:5:18: error: No pair for character ('). Can't process file. File is either invalid or unicode, which is currently not supported. [syntaxError]
as the zx81 doesn't have colour the example does not
                 ^
libsrc/sprites/software/sp1/deprecated/zx81hr/examples/ex4b.c:5:18: error: No pair for character ('). Can't process file. File is either invalid or unicode, which is currently not supported. [syntaxError]
as the zx81 doesn't have colour the example does not
                 ^
libsrc/sprites/software/sp1/deprecated/zx81hr/examples/ex4c.c:191:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/zx81hr/examples/ex5a.c:200:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/zx81hr/examples/ex5b.c:230:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/zx81hr/examples/ex5c.c:228:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/zx81hr/examples/ex5d.c:204:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/deprecated/zx81hr/examples/ex5e.c:358:37: error: syntax error [syntaxError]
 DEFB 255,  0,255,  0,255,  0,255,  0
                                    ^
libsrc/sprites/software/sp1/zx/examples/ex1.c:76:19: style: The scope of the variable 's' can be reduced. [variableScope]
   struct sp1_ss *s;
                  ^
libsrc/sprites/software/sp1/zx/examples/ex2a.c:72:19: style: The scope of the variable 's' can be reduced. [variableScope]
   struct sp1_ss *s;
                  ^
libsrc/sprites/software/sp1/zx/examples/ex2b.c:72:19: style: The scope of the variable 's' can be reduced. [variableScope]
   struct sp1_ss *s;
                  ^
libsrc/sprites/software/sp1/zx/examples/ex2c.c:74:19: style: The scope of the variable 's' can be reduced. [variableScope]
   struct sp1_ss *s;
                  ^
libsrc/sprites/software/sp1/zx/examples/ex2d.c:75:19: style: The scope of the variable 's' can be reduced. [variableScope]
   struct sp1_ss *s;
                  ^
libsrc/sprites/software/sp1/zx/examples/ex2e.c:80:19: style: The scope of the variable 's' can be reduced. [variableScope]
   struct sp1_ss *s;
                  ^
libsrc/sprites/software/sp1/zx/examples/ex2f.c:85:19: style: The scope of the variable 's' can be reduced. [variableScope]
   struct sp1_ss *s;
                  ^
libsrc/sprites/software/sp1/zx/examples/ex3a.c:80:19: style: The scope of the variable 's' can be reduced. [variableScope]
   struct sp1_ss *s;
                  ^
libsrc/sprites/software/sp1/zx/examples/ex4a.c:111:19: style: The scope of the variable 's' can be reduced. [variableScope]
   struct sp1_ss *s;
                  ^
libsrc/sprites/software/sp1/zx/examples/ex4b.c:113:19: style: The scope of the variable 's' can be reduced. [variableScope]
   struct sp1_ss *s;
                  ^
libsrc/sprites/software/sp1/zx/examples/ex4c.c:113:19: style: The scope of the variable 's' can be reduced. [variableScope]
   struct sp1_ss *s;
                  ^
libsrc/sprites/software/sp1/zx/examples/ex5a.c:103:19: style: The scope of the variable 's' can be reduced. [variableScope]
   struct sp1_ss *s;
                  ^
libsrc/sprites/software/sp1/zx/examples/ex5b.c:120:19: style: The scope of the variable 's' can be reduced. [variableScope]
   struct sp1_ss *s;
                  ^
libsrc/sprites/software/sp1/zx/examples/ex5c.c:116:19: style: The scope of the variable 's' can be reduced. [variableScope]
   struct sp1_ss *s;
                  ^
libsrc/sprites/software/sp1/zx/examples/ex5d.c:97:19: style: The scope of the variable 's' can be reduced. [variableScope]
   struct sp1_ss *s;
                  ^
libsrc/sprites/software/sp1/zx/examples/ex5e.c:170:23: style: The scope of the variable 't' can be reduced. [variableScope]
   struct sp1_update *t;
                      ^
libsrc/sprites/software/sp1/zx/examples/ex5e.c:199:19: style: The scope of the variable 's' can be reduced. [variableScope]
   struct sp1_ss *s;
                  ^
libsrc/stdio/_freopen1.c:37:9: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
        mode++;
        ^
libsrc/stdio/_freopen1.c:37:13: style: Variable 'mode' is assigned a value that is never used. [unreadVariable]
        mode++;
            ^
libsrc/stdio/fchkstd.c:65:16: style:inconclusive: Boolean expression '_IOSYSTEM==0' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
 if ( fp->flags&_IOSYSTEM == 0 ) return 0;
               ^
libsrc/stdio/fchkstd.c:65:16: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
 if ( fp->flags&_IOSYSTEM == 0 ) return 0;
               ^
libsrc/stdio/fchkstd.c:67:29: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
 return ( fp->flags&_IOREAD ? -1 : 1 );
                            ^
libsrc/stdio/fchkstd.c:44:6: warning: Found suspicious operator ',' [constStatement]
 ld a,(de)
     ^
libsrc/stdio/fclose.c:37:2: warning:inconclusive: Found suspicious operator '&&' [constStatement]
 and _IOUSE  ;inuse?
 ^
libsrc/stdio/fclose.c:40:7: warning: Found suspicious operator ',' [constStatement]
 ld hl,-1  ;EOF
      ^
libsrc/stdio/fclose.c:77:1: style: Unused variable: fclose_check_success [unusedVariable]
fclose_check_success:
^
libsrc/stdio/feof.c:28:6: error: syntax error [syntaxError]
 and @00001000
     ^
libsrc/stdio/ferror.c:31:18: error: syntax error [syntaxError]
; check EOF only if not WRITE mode
                 ^
libsrc/stdio/fflush.c:34:12: style: Same expression on both sides of '|'. [duplicateExpression]
 and _IOUSE|_IOEXTRA
           ^
libsrc/stdio/fflush.c:36:23: warning:inconclusive: Found suspicious operator '!' [constStatement]
 jr nz,fflush_error  ;not used
                      ^
libsrc/stdio/fflush.c:65:7: warning: Found suspicious operator ',' [constStatement]
 ld hl,-1 ; EOF
      ^
libsrc/stdio/fgetc.c:100:28: error: syntax error [syntaxError]
    call    fchkstd ;check for stdin (stdout/err have failed already)
                           ^
libsrc/stdio/fgetc.c:128:0: information: Skipping configuration '__STDIO_BINARY;__STDIO_EOFMARKER' since the value of '__STDIO_EOFMARKER' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    cp      __STDIO_EOFMARKER ;compare with the EOF marker
^
libsrc/stdio/fgetc.c:244:0: information: Skipping configuration '__STDIO_BINARY;__STDIO_EOFMARKER' since the value of '__STDIO_EOFMARKER' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    cp __STDIO_EOFMARKER
^
libsrc/stdio/fgetc.c:270:0: information: Skipping configuration '__STDIO_BINARY;__STDIO_EOFMARKER' since the value of '__STDIO_EOFMARKER' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    cp __STDIO_EOFMARKER ;compare with the EOF marker
^
libsrc/stdio/fgetc.c:244:0: information: Skipping configuration '__STDIO_EOFMARKER' since the value of '__STDIO_EOFMARKER' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    cp __STDIO_EOFMARKER
^
libsrc/stdio/fgetpos.c:90:16: error: syntax error [syntaxError]
 ld de,0 ;posn for lseek()
               ^
libsrc/stdio/fgets_cons.c:35:9: style: The scope of the variable 'c' can be reduced. [variableScope]
    int c;
        ^
libsrc/stdio/fmemopen.c:8:17: style: Unused variable: flags [unusedVariable]
        int     flags;
                ^
libsrc/stdio/fputc_callee.c:37:19: style:inconclusive: Boolean expression '!__CPU_GBZ80__ push ix IF __CPU_R2KA__' is used in bitwise operation. Did you mean '||'? [bitwiseOnBoolean]
  IF __CPU_R2KA__ | __CPU_R3K__
                  ^
libsrc/stdio/fputc_callee.c:37:19: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  IF __CPU_R2KA__ | __CPU_R3K__
                  ^
libsrc/stdio/fputc_callee.c:175:13: style: Variable 'hl' is reassigned a value before the old one has been used. [redundantAssignment]
; Exit:  hl = byte written
            ^
libsrc/stdio/fputc_callee.c:173:13: note: hl is assigned
; Entry: hl = fp
            ^
libsrc/stdio/fputc_callee.c:175:13: note: hl is overwritten
; Exit:  hl = byte written
            ^
libsrc/stdio/fputc_callee.c:125:16: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
 call fchkstd ;preserves bc
               ^
libsrc/stdio/fputc_callee.c:63:3: style: Label 'Entry' is not used. There is #if in function body so the label might be used in code that is removed by the preprocessor. [unusedLabelConfiguration]
; Entry: ix = fp
  ^
libsrc/stdio/fputc_callee.c:65:3: style: Label 'Exit' is not used. There is #if in function body so the label might be used in code that is removed by the preprocessor. [unusedLabelConfiguration]
; Exit:  hl = byte written
  ^
libsrc/stdio/fputc_callee.c:173:3: style: Label 'Entry' is not used. [unusedLabel]
; Entry: hl = fp
  ^
libsrc/stdio/fputc_callee.c:175:3: style: Label 'Exit' is not used. [unusedLabel]
; Exit:  hl = byte written
  ^
libsrc/stdio/fputc_callee.c:67:7: warning: Found suspicious operator ',' [constStatement]
 ld hl,-1 ;EOF
      ^
libsrc/stdio/fputc_callee.c:69:2: warning:inconclusive: Found suspicious operator '&&' [constStatement]
 and a ;no thing
 ^
libsrc/stdio/fputc_callee.c:72:30: warning:inconclusive: Found suspicious operator '+' [constStatement]
; Check removed to allow READ+WRITE streams
                             ^
libsrc/stdio/fputc_callee.c:169:18: warning:inconclusive: Found suspicious operator '|' [constStatement]
IF __CPU_INTEL__ | __CPU_GBZ80__
                 ^
libsrc/stdio/fputc_callee.c:178:15: warning: Found suspicious operator ',' [constStatement]
    ld      hl,-1   ;EOF
              ^
libsrc/stdio/fputc_callee.c:182:5: warning:inconclusive: Found suspicious operator '&&' [constStatement]
    and     a       ;no thing
    ^
libsrc/stdio/fputc_callee.c:197:17: warning: Found suspicious operator ',' [constStatement]
    ld      (hl),e
                ^
libsrc/stdio/fputc_callee.c:200:14: warning: Found suspicious operator ',' [constStatement]
    ld      l,c     ;load char to return
             ^
libsrc/stdio/fputc_callee.c:74:7: style: Variable 'nz' is not assigned a value. [unassignedVariable]
; ret nz ;don`t want reading streams
      ^
libsrc/stdio/fputc_callee.c:194:15: style: Variable 'c' is not assigned a value. [unassignedVariable]
    ld      a,c     ;store character
              ^
libsrc/stdio/fputc_callee.c:144:22: error: syntax error [syntaxError]
 ld a,_IOTEXT ;check for text mode
                     ^
libsrc/stdio/fputc_cons_generic_ioctl.c:75:10: error: syntax error: +) [syntaxError]
 ld a,(hl+)
         ^
libsrc/stdio/fputs_callee.c:76:15: error: syntax error [syntaxError]
 ld a,l ;test for EOF returned
              ^
libsrc/stdio/fread.c:127:15: error: syntax error: && return [syntaxError]
 ; divide and return
              ^
libsrc/stdio/fread.c:16:17: style: Condition 'len' is always true [knownConditionTrueFalse]
        while ( len ) {
                ^
libsrc/stdio/fread.c:12:18: note: Assuming that condition 'len==0' is not redundant
        if ( len == 0 ) return len;
                 ^
libsrc/stdio/fread.c:16:17: note: Condition 'len' is always true
        while ( len ) {
                ^
libsrc/stdio/fread.c:18:18: warning: Storing fgetc() return value in char variable and then comparing with EOF. [checkCastIntToCharAndBack]
            if ( c == EOF ) break;
                 ^
libsrc/stdio/fread.c:19:34: portability: 'ptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
            *(unsigned char *)ptr++ = c;
                                 ^
libsrc/stdio/fread.c:20:13: error: Uninitialized variable: r [uninitvar]
            r++;
            ^
libsrc/stdio/fread.c:14:22: style: Variable 'r' is not assigned a value. [unassignedVariable]
        unsigned int r;
                     ^
libsrc/stdio/fread.c:29:40: portability: 'ptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
            len = read(fp->desc.fd, ptr+1, len);
                                       ^
libsrc/stdio/fseek.c:43:11: error: syntax error: keyword 'return' is not allowed in global scope [syntaxError]
 pop af  ;return address
          ^
libsrc/stdio/ftell.c:57:7: warning: Found suspicious operator ',' [constStatement]
 ld de,65535 ;-1
      ^
libsrc/stdio/ftell.c:74:7: warning: Found suspicious operator ',' [constStatement]
 ld de,0 ;posn
      ^
libsrc/stdio/funopen.c:40:17: error: syntax error [syntaxError]
 push hl  ;Keep for later
                ^
libsrc/stdio/fwrite.c:82:15: error: syntax error: && return [syntaxError]
 ; divide and return
              ^
libsrc/stdio/ungetc.c:35:39: error: syntax error [syntaxError]
 ret nz ;cant push back after EOF (or for write stream)
                                      ^
libsrc/stdio/zsock/fgetc_net.c:23:34: warning:inconclusive: Found suspicious operator '-' [constStatement]
  if (sock_closed(s) ) return_nc -1;
                                 ^
libsrc/stdio/zsock/fgetc_net.c:18:9: style: Variable 'num' is assigned a value that is never used. [unreadVariable]
 int num=0;
        ^
libsrc/stdio/zsock/fgetc_net.c:16:7: style: Unused variable: pad [unusedVariable]
 char pad;
      ^
libsrc/stdio/zsock/fopen_zsock.c:79:4: portability: Returning an address value in a function with integer return type is not portable. [CastAddressToIntegerAtReturn]
   return s;
   ^
libsrc/stdio/zsock/fopen_zsock.c:60:6: style: Unused variable: ret [unusedVariable]
 int ret;
     ^
libsrc/stdio/zsock/fputc_net.c:21:6: style: Variable 'num' is assigned a value that is never used. [unreadVariable]
  num=sock_putc(c,s);
     ^
libsrc/stdlib/unbcd.c:33:7: warning: Found suspicious operator ',' [constStatement]
 ex de,hl
      ^
libsrc/stdlib/unbcd.c:48:7: warning: Found suspicious operator ',' [constStatement]
 ex de,hl
      ^
libsrc/stdlib/unbcd.c:67:7: warning: Found suspicious operator ',' [constStatement]
 ex de,hl
      ^
libsrc/stdlib/unbcd.c:76:8: warning: Found suspicious operator ',' [constStatement]
 add hl,de
       ^
libsrc/stdlib/unbcd.c:78:8: warning: Found suspicious operator ',' [constStatement]
 add hl,de
       ^
libsrc/stdlib/unbcd.c:11:5: style: Variable 'hl' is not assigned a value. [unassignedVariable]
 ld hl,(sp+2)
    ^
libsrc/target/c128/c128/getjoyscia.c:34:7: style: Unused variable: savecia [unusedVariable]
 call savecia
      ^
libsrc/target/c128/c128/getjoyscia.c:50:14: style: Unused variable: restorecia [unusedVariable]
        call restorecia
             ^
libsrc/target/c128/c128/getjoyscia.c:58:13: style: Variable 'bc' is not assigned a value. [unassignedVariable]
        pop bc  ;cia1+ciaDataDirB
            ^
libsrc/target/c128/c128/getkeyscia.c:20:1: error: syntax error: ; . _ciaKeyScan [syntaxError]
._ciaKeyScan defw ciaKeyScantbl
^
libsrc/target/c128/c128/mapvdc.c:24:1: error: syntax error: ; . _vdcScrHorz [syntaxError]
._vdcScrHorz defw 0
^
libsrc/target/c128/c128/winvdc.c:22:9: style: The scope of the variable 'ChSave' can be reduced. [variableScope]
  char  ChSave;
        ^
libsrc/target/c128/c128/winvdc.c:30:13: warning: String literal compared with variable 'Title'. Did you intend to use strcmp() instead? [literalWithCharPtrCompare]
  if (Title != "")
            ^
libsrc/target/cpc/fcntl/cpc_openin.c:12:32: style:inconclusive: Function 'cpc_openin' argument 2 names different: declaration 'namelen' definition 'len'. [funcArgNamesDifferent]
int cpc_openin(char *name, int len, char *buf)
                               ^
libsrc/target/cpc/fcntl/cpcfcntl.h:23:47: note: Function 'cpc_openin' argument 2 names different: declaration 'namelen' definition 'len'.
extern int __LIB__ cpc_openin(char *name, int namelen,char *buf);
                                              ^
libsrc/target/cpc/fcntl/cpc_openin.c:12:32: note: Function 'cpc_openin' argument 2 names different: declaration 'namelen' definition 'len'.
int cpc_openin(char *name, int len, char *buf)
                               ^
libsrc/target/cpc/fcntl/cpc_openout.c:12:33: style:inconclusive: Function 'cpc_openout' argument 2 names different: declaration 'namelen' definition 'len'. [funcArgNamesDifferent]
int cpc_openout(char *name, int len, char *buf)
                                ^
libsrc/target/cpc/fcntl/cpcfcntl.h:24:48: note: Function 'cpc_openout' argument 2 names different: declaration 'namelen' definition 'len'.
extern int __LIB__ cpc_openout(char *name, int namelen,char *buf);
                                               ^
libsrc/target/cpc/fcntl/cpc_openout.c:12:33: note: Function 'cpc_openout' argument 2 names different: declaration 'namelen' definition 'len'.
int cpc_openout(char *name, int len, char *buf)
                                ^
libsrc/target/cpm/fcntl/bdos.c:24:17: error: syntax error [syntaxError]
 rla  ;make -ve if error
                ^
libsrc/target/cpm/fcntl/bdos_callee.c:29:17: error: syntax error [syntaxError]
 rla  ;make -ve if error
                ^
libsrc/target/cpm/fcntl/bdosh_callee.c:16:14: warning: Unused variable value 'arg' [constStatement]
; ld e,(hl) ;arg
             ^
libsrc/target/cpm/fcntl/bdosh_callee.c:13:9: style: Unused variable: __bdos [unusedVariable]
 EXTERN __bdos
        ^
libsrc/target/cpm/fcntl/bdosh_callee.c:14:6: style: Unused variable: hl [unusedVariable]
; ld hl,2
     ^
libsrc/target/cpm/fcntl/bdosh_callee.c:15:10: style: Unused variable: sp [unusedVariable]
; add hl,sp
         ^
libsrc/target/cpm/fcntl/bdosh_callee.c:16:6: style: Unused variable: e [unusedVariable]
; ld e,(hl) ;arg
     ^
libsrc/target/cpm/fcntl/bdosh_callee.c:18:6: style: Unused variable: d [unusedVariable]
; ld d,(hl)
     ^
libsrc/target/cpm/fcntl/bdosh_callee.c:20:6: style: Unused variable: c [unusedVariable]
; ld c,(hl) ;func
     ^
libsrc/target/cpm/fcntl/bios.c:24:20: error: syntax error: 1 = [syntaxError]
 ld hl,(1)   ; base+1 = addr of jump table + 3
                   ^
libsrc/target/cpm/fcntl/creat.c:21:23: style: The scope of the variable 'uid' can be reduced. [variableScope]
    unsigned char pad,uid;
                      ^
libsrc/target/cpm/fcntl/creat.c:21:19: style: Unused variable: pad [unusedVariable]
    unsigned char pad,uid;
                  ^
libsrc/target/cpm/fcntl/get_dir_name.c:17:5: portability: Returning an address value in a function with integer return type is not portable. [CastAddressToIntegerAtReturn]
    return tempdirname;
    ^
libsrc/target/cpm/fcntl/get_dpb.c:18:20: error: syntax error: 1 = [syntaxError]
 ld hl,(1)   ; base+1 = addr of jump table + 3
                   ^
libsrc/target/cpm/fcntl/lseek.c:19:13: style: The scope of the variable 'cnt' can be reduced. [variableScope]
    int     cnt;
            ^
libsrc/target/cpm/fcntl/lseek.c:20:13: style: The scope of the variable 'buffer' can be reduced. [variableScope]
    char    buffer[SECSIZE];
            ^
libsrc/target/cpm/fcntl/open.c:29:19: style: The scope of the variable 'uid' can be reduced. [variableScope]
    unsigned char uid,pad;
                  ^
libsrc/target/cpm/fcntl/open.c:29:23: style: Unused variable: pad [unusedVariable]
    unsigned char uid,pad;
                      ^
libsrc/target/cpm/fcntl/parsefcb.c:84:42: error: There is an unknown macro here somewhere. Configuration is required. If in is a macro then please configure it. [unknownMacro]
; Leor Zolman put it into Public Domain (in 9/20/2002)
                                         ^
libsrc/target/cpm/fcntl/read.c:77:17: portability: 'buf' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
            buf += size;
                ^
libsrc/target/cpm/fcntl/read.c:19:19: style: Unused variable: buffer [unusedVariable]
    unsigned char buffer[SECSIZE+2];
                  ^
libsrc/target/cpm/fcntl/read.c:33:21: portability: 'buf' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
            if((*buf++ = (bdos(CPM_RRDR,0xFF) & 0x7f)) == '\n')
                    ^
libsrc/target/cpm/fcntl/readbyte.c:18:18: warning:inconclusive: Found suspicious operator '-' [constStatement]
        return_c -1;
                 ^
libsrc/target/cpm/fcntl/readbyte.c:20:15: style: Unused variable: buffer [unusedVariable]
    return_nc buffer;
              ^
libsrc/target/cpm/fcntl/setfcb.c:23:12: style: Unused variable: j [unusedVariable]
    int  i,j;
           ^
libsrc/target/cpm/fcntl/stat.c:35:18: style: The scope of the variable 'sfc' can be reduced. [variableScope]
    struct sfcb *sfc;
                 ^
libsrc/target/cpm/fcntl/stat.c:32:6: style: Unused variable: inode [unusedVariable]
 int inode;
     ^
libsrc/target/cpm/fcntl/write.c:76:17: portability: 'buf' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
            buf += size;
                ^
libsrc/target/cpm/fcntl/write.c:19:19: style: Unused variable: buffer [unusedVariable]
    unsigned char buffer[SECSIZE+2];
                  ^
libsrc/target/cpm/fcntl/write.c:35:31: portability: 'buf' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
            bdos(CPM_WPUN,*buf++);
                              ^
libsrc/target/cpm/fcntl/write.c:43:29: portability: 'buf' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
            bdos(offset,*buf++);
                            ^
libsrc/target/lm80c/rs232/rs232_params.c:20:17: style: Unused variable: hl [unusedVariable]
        ld      hl,RS_ERR_OK
                ^
libsrc/target/msx/asmlib/UnapiBuildCodeBlock.c:42:16: style: Variable 'codeBlockWords' is assigned a value that is never used. [unreadVariable]
 codeBlockWords=(uint16_t*)&(codeBlock->UnapiCallCode[0]);
               ^
libsrc/target/msx/asmlib/UnapiGetRamHelper.c:5:8: style: Unused variable: arg [unusedVariable]
 char* arg;
       ^
libsrc/target/mtx/rs232/rs232_params.c:46:31: error: syntax error [syntaxError]
 ; We now have d as the value for baud rate
                              ^
libsrc/target/nabu/retronet/rn_fileHandleInsert.c:22:42: portability: 'data' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
    hcca_start_write(HCCA_MODE_HDR, data + dataOffset, dataLen);
                                         ^
libsrc/target/osca/fcntl/flosmulti/open.c:75:2: portability: Returning an address value in a function with integer return type is not portable. [CastAddressToIntegerAtReturn]
 return(flosfile);
 ^
libsrc/target/oz/oz/ozinput/ozeditline.c:39:21: style: The scope of the variable 'k' can be reduced. [variableScope]
    static unsigned k;
                    ^
libsrc/target/pps/fcntl/creat.c:21:22: warning:inconclusive: Found suspicious operator '+' [constStatement]
        ld      l,(ix+4)        ;lower 16 of filename
                     ^
libsrc/target/pps/fcntl/lseek.c:27:22: warning:inconclusive: Found suspicious operator '+' [constStatement]
        ld      b,(ix+2)        ;whence
                     ^
libsrc/target/pps/fcntl/read.c:26:22: warning:inconclusive: Found suspicious operator '+' [constStatement]
        ld      e,(ix+0)        ;len
                     ^
libsrc/target/pps/fcntl/read.c:30:34: warning: Unused variable value 'fd' [constStatement]
        ld      a,(ix+4)        ;fd
                                 ^
libsrc/target/pps/fcntl/readbyte.c:20:15: warning: Redundant assignment of 'de' to itself. [selfAssignment]
 ex de,hl ;de = fd
              ^
libsrc/target/pps/fcntl/readbyte.c:19:7: style: Unused variable: ix [unusedVariable]
 push ix ;save callers
      ^
libsrc/target/pps/fcntl/write.c:26:22: warning:inconclusive: Found suspicious operator '+' [constStatement]
        ld      e,(ix+0)        ;len
                     ^
libsrc/target/pps/fcntl/writebyte.c:22:22: warning:inconclusive: Found suspicious operator '+' [constStatement]
        ld      a,(ix+2)        ;fd
                     ^
libsrc/target/pps/time/clock.c:27:17: style: Variable 'c' is not assigned a value. [unassignedVariable]
        ld      c,$21   ;SYSTIME
                ^
libsrc/target/pps/time/clock.c:27:19: style: Unused variable: $21 [unusedVariable]
        ld      c,$21   ;SYSTIME
                  ^
libsrc/target/s1mp3/flash/flash_initialise.c:278:1: style: Label 'DetermineFlashType_Toshiba32MByte' is not used. [unusedLabel]
DetermineFlashType_Toshiba32MByte:
^
libsrc/target/s1mp3/flash/flash_initialise.c:283:1: style: Label 'DetermineFlashType_Toshiba64MByte' is not used. [unusedLabel]
DetermineFlashType_Toshiba64MByte:
^
libsrc/target/s1mp3/flash/flash_initialise.c:288:1: style: Label 'DetermineFlashType_Tosh128MB' is not used. [unusedLabel]
DetermineFlashType_Tosh128MB:
^
libsrc/target/s1mp3/flash/flash_initialise.c:298:1: style: Label 'DetermineFlashType_Tosh128MB2' is not used. [unusedLabel]
DetermineFlashType_Tosh128MB2:
^
libsrc/target/s1mp3/flash/flash_initialise.c:303:1: style: Label 'DetermineFlashType_Toshiba256MByte' is not used. [unusedLabel]
DetermineFlashType_Toshiba256MByte:
^
libsrc/target/s1mp3/flash/flash_initialise.c:308:1: style: Label 'DetermineFlashType_Generic_Check' is not used. [unusedLabel]
DetermineFlashType_Generic_Check:
^
libsrc/target/s1mp3/flash/flash_initialise.c:330:1: style: Label 'DetermineFlashType_32MByte' is not used. [unusedLabel]
DetermineFlashType_32MByte:
^
libsrc/target/s1mp3/flash/flash_initialise.c:335:1: style: Label 'DetermineFlashType_64MByte' is not used. [unusedLabel]
DetermineFlashType_64MByte:
^
libsrc/target/s1mp3/flash/flash_initialise.c:340:1: style: Label 'DetermineFlashType_128MByte' is not used. [unusedLabel]
DetermineFlashType_128MByte:
^
libsrc/target/s1mp3/flash/flash_initialise.c:347:1: style: Label 'DetermineFlashType_128MByte_X2' is not used. [unusedLabel]
DetermineFlashType_128MByte_X2:
^
libsrc/target/s1mp3/flash/flash_initialise.c:352:1: style: Label 'DetermineFlashType_256MByte' is not used. [unusedLabel]
DetermineFlashType_256MByte:
^
libsrc/target/s1mp3/flash/flash_initialise.c:206:14: warning: Found suspicious operator ',' [constStatement]
    ld      b,60h                                       ; Small delay
             ^
libsrc/target/s1mp3/flash/flash_initialise.c:424:38: warning: Found suspicious operator ',' [constStatement]
    ld      (_FLASH_NandFlashTypeCE1),a     ; Set CE1 NAND Flash type
                                     ^
libsrc/target/s1mp3/flash/flash_initialise.c:210:15: style: Variable 'a' is not assigned a value. [unassignedVariable]
    ld      b,a                                         ; Manufacturer Code
              ^
libsrc/target/s1mp3/flash/flash_pageread.c:24:13: style: Unused variable: d [unusedVariable]
    ld      d,0x80                                          ; 0x80XX - where to write
            ^
libsrc/target/s1mp3/isr/isr_initialise.c:161:1: style: Label 'misr_start' is not used. [unusedLabel]
misr_start:
^
libsrc/target/s1mp3/isr/isr_initialise.c:176:1: style: Label 'nmisr_start' is not used. [unusedLabel]
nmisr_start:
^
libsrc/target/s1mp3/isr/isr_initialise.c:213:3: style: Local variable '_Current_ISR_Table' shadows outer variable [shadowVariable]
  _Current_ISR_Table[Int_Number >> 1] = Proc;
  ^
libsrc/target/s1mp3/isr/isr_initialise.c:81:7: note: Shadowed declaration
void *_Current_ISR_Table[] = {
      ^
libsrc/target/s1mp3/isr/isr_initialise.c:213:3: note: Shadow variable
  _Current_ISR_Table[Int_Number >> 1] = Proc;
  ^
libsrc/target/s1mp3/isr/isr_initialise.c:231:4: style: Local variable '_Current_ISR_Table' shadows outer variable [shadowVariable]
   _Current_ISR_Table[Int_Number  >> 1] = _Default_ISR_Table[Int_Number  >> 1];
   ^
libsrc/target/s1mp3/isr/isr_initialise.c:81:7: note: Shadowed declaration
void *_Current_ISR_Table[] = {
      ^
libsrc/target/s1mp3/isr/isr_initialise.c:231:4: note: Shadow variable
   _Current_ISR_Table[Int_Number  >> 1] = _Default_ISR_Table[Int_Number  >> 1];
   ^
libsrc/target/s1mp3/isr/isr_initialise.c:194:18: warning:inconclusive: Found suspicious operator '-' [constStatement]
 ld bc, misr_end - misr_start
                 ^
libsrc/target/s1mp3/isr/isr_initialise.c:217:3: warning: Unused variable value 'return' [constStatement]
  return(1);
  ^
libsrc/target/s1mp3/isr/isr_initialise.c:235:3: warning: Unused variable value 'return' [constStatement]
  return(1);
  ^
libsrc/target/s1mp3/isr/isr_initialise.c:20:5: style: Variable 'a' is not assigned a value. [unassignedVariable]
 in a, (SARADC_IRQSTAT_REG)
    ^
libsrc/target/s1mp3/isr/isr_initialise.c:36:5: style: Variable 'a' is not assigned a value. [unassignedVariable]
 in a, (RTC_IRQSTATUS_REG)
    ^
libsrc/target/s1mp3/isr/isr_initialise.c:44:5: style: Variable 'a' is not assigned a value. [unassignedVariable]
 in a, (IRQ_STATUS_REG)
    ^
libsrc/target/s1mp3/isr/isr_initialise.c:52:5: style: Variable 'a' is not assigned a value. [unassignedVariable]
 in a, (UART_CONTROL_REG)
    ^
libsrc/target/s1mp3/isr/isr_initialise.c:60:5: style: Variable 'a' is not assigned a value. [unassignedVariable]
 in a, (USB_IRQSTATUS_REG)
    ^
libsrc/target/s1mp3/isr/isr_initialise.c:68:5: style: Variable 'a' is not assigned a value. [unassignedVariable]
 in a, (I2C_CONTROL_REG)
    ^
libsrc/target/s1mp3/isr/isr_initialise.c:105:5: style: Unused variable: a [unusedVariable]
 in a, (MINT_STATUS_REG)
    ^
libsrc/target/s1mp3/isr/isr_initialise.c:213:39: style: Variable '_Current_ISR_Table' is assigned a value that is never used. [unreadVariable]
  _Current_ISR_Table[Int_Number >> 1] = Proc;
                                      ^
libsrc/target/s1mp3/isr/isr_initialise.c:231:41: style: Variable '_Current_ISR_Table' is assigned a value that is never used. [unreadVariable]
   _Current_ISR_Table[Int_Number  >> 1] = _Default_ISR_Table[Int_Number  >> 1];
                                        ^
libsrc/target/s1mp3/keyboard/keyboard_getkeystate.c:27:5: style: Variable 'l' is not assigned a value. [unassignedVariable]
 ld l, 0
    ^
libsrc/target/s1mp3/keyboard/keyboard_initialise.c:8:10: style: Variable 'a' is not assigned a value. [unassignedVariable]
 ld      a, KEYSCAN_CTRL_ENABLE | KEYSCAN_CTRL_MASK_KEYIN1
         ^
libsrc/target/s1mp3/lcd/fonts.c:27:6: style: Variable 'b' is assigned a value that is never used. [unreadVariable]
    b=1;
     ^
libsrc/target/s1mp3/lcd/lcd_copypicture.c:12:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
libsrc/target/s1mp3/lcd/lcd_copypicture.c:13:6: style: The scope of the variable 'j' can be reduced. [variableScope]
 int j;
     ^
libsrc/target/s1mp3/lcd/lcd_copypicture.c:14:6: style: The scope of the variable 'k' can be reduced. [variableScope]
 int k;
     ^
libsrc/target/s1mp3/lcd/lcd_copypicture.c:15:6: style: The scope of the variable 'l' can be reduced. [variableScope]
 int l;
     ^
libsrc/target/s1mp3/lcd/lcd_copypicture.c:16:6: style: Unused variable: Pos_X [unusedVariable]
 int Pos_X;
     ^
libsrc/target/s1mp3/lcd/lcd_copypicture.c:17:6: style: Unused variable: Pos_Y [unusedVariable]
 int Pos_Y;
     ^
libsrc/target/s1mp3/lcd/lcd_writetext.c:31:16: style: The scope of the variable 'byte_offset' can be reduced. [variableScope]
 unsigned char byte_offset;
               ^
libsrc/target/s1mp3/lcd/lcd_writetext.c:32:16: style: The scope of the variable 'y_bits' can be reduced. [variableScope]
 unsigned char y_bits;
               ^
libsrc/target/s1mp3/lcd/lcd_writetext.c:33:16: style: The scope of the variable 'remaining_bits' can be reduced. [variableScope]
 unsigned char remaining_bits;
               ^
libsrc/target/s1mp3/lcd/lcd_writetext.c:34:16: style: The scope of the variable 'mask' can be reduced. [variableScope]
 unsigned char mask;
               ^
libsrc/target/s1mp3/lcd/lcd_writetext.c:37:17: style: The scope of the variable 'glyph_scan' can be reduced. [variableScope]
 unsigned char *glyph_scan;
                ^
libsrc/target/s1mp3/lcd/lcd_writetext.c:118:18: style: The scope of the variable 'glyph' can be reduced. [variableScope]
   unsigned char glyph;
                 ^
libsrc/target/s1mp3/lcd/lcd_writetext.c:119:18: style: The scope of the variable 'width' can be reduced. [variableScope]
   unsigned char width;
                 ^
libsrc/target/s1mp3/lcd/lcd_writetext.c:120:16: style: The scope of the variable 'height' can be reduced. [variableScope]
 unsigned char height;
               ^
libsrc/target/s1mp3/lcd/lcd_writetext.c:121:16: style: The scope of the variable 'store_width' can be reduced. [variableScope]
 unsigned char store_width;
               ^
libsrc/target/s1mp3/lcd/lcd_writetext.c:122:17: style: The scope of the variable 'glyph_ptr' can be reduced. [variableScope]
 unsigned char *glyph_ptr;
                ^
libsrc/target/s1mp3/lcd_s6b0724/lcdtarget_initialise.c:62:2: warning:inconclusive: Found suspicious operator '&&' [constStatement]
 and 0FEh    ;(~LCDTARGET_A0) 11111110
 ^
libsrc/target/s1mp3/lcd_s6b0724/lcdtarget_initialise.c:14:31: error: Uninitialized variable: a [uninitvar]
 ld (_lcdtarget_srampagereg), a
                              ^
libsrc/target/s1mp3/lcd_s6b0724/lcdtarget_initialise.c:13:5: style: Variable 'a' is not assigned a value. [unassignedVariable]
 in a, (INTERNAL_MROM_SRAM_PAGE_REG)
    ^
libsrc/target/s1mp3/lcd_s6b0724/lcdtarget_initialise.c:39:5: style: Variable 'a' is not assigned a value. [unassignedVariable]
 ld a, (_lcdtarget_empagehireg)
    ^
libsrc/target/s1mp3/lcd_s6b0724/lcdtarget_initialise.c:61:5: style: Variable 'a' is not assigned a value. [unassignedVariable]
 in a, (MFP_GPOA_SELECT_REG)
    ^
libsrc/target/s1mp3/lcd_s6b0724/lcdtarget_updatescreen.c:21:3: warning:inconclusive: Found suspicious operator '||' [constStatement]
  or LCDTARGET_A0     ; Enable Data write
  ^
libsrc/target/s1mp3/lcd_s6b0724/lcdtarget_updatescreen.c:9:16: style: Unused variable: x [unusedVariable]
 unsigned char x;
               ^
libsrc/target/s1mp3/lcd_s6b0724/lcdtarget_updatescreen.c:20:6: style: Variable 'a' is not assigned a value. [unassignedVariable]
  in a, (MFP_GPOA_SELECT_REG)
     ^
libsrc/target/s1mp3/rs232/rs232_initialise.c:22:31: warning: Found suspicious operator ',' [constStatement]
    out     (RTC_ALARM_HI_REG),a
                              ^
libsrc/target/s1mp3/rs232/rs232_isr.c:11:6: style: The scope of the variable 'tmp' can be reduced. [variableScope]
 int tmp;
     ^
libsrc/target/s1mp3/rs232/rs232_isr.c:12:16: style: The scope of the variable 'rxc' can be reduced. [variableScope]
 unsigned char rxc;
               ^
libsrc/target/s1mp3/rs232/rs232_isr.c:13:19: style: The scope of the variable 'discard' can be reduced. [variableScope]
    unsigned char discard;
                  ^
libsrc/target/s1mp3/rs232/rs232_isr.c:45:10: error: Uninitialized variable: rxc [uninitvar]
      if(rxc == CTRLS)
         ^
libsrc/target/s1mp3/rs232/rs232_isr.c:52:15: error: Uninitialized variable: rxc [uninitvar]
      else if(rxc == CTRLQ)
              ^
libsrc/target/s1mp3/rs232/rs232_isr.c:65:60: error: Uninitialized variable: rxc [uninitvar]
                pi_sp->input_buffer[pi_sp->input_insert] = rxc;
                                                           ^
libsrc/target/s1mp3/rs232/rs232_isr.c:12:16: style: Variable 'rxc' is not assigned a value. [unassignedVariable]
 unsigned char rxc;
               ^
libsrc/target/s1mp3/rtc/rtc_getstatus.c:10:5: style: Unused variable: a [unusedVariable]
 in a, (RTC_IRQSTATUS_REG)
    ^
libsrc/target/s1mp3/rtc/rtc_initialise.c:6:5: style: Variable 'a' is not assigned a value. [unassignedVariable]
 in a, (RTC_CONTROL_REG)
    ^
libsrc/target/s1mp3/rtc/rtc_isr.c:19:15: error: syntax error [syntaxError]
 ; Nothing to do with this interrupt yet!
              ^
libsrc/target/s1mp3/usb/usb_initialise.c:28:33: warning: Found suspicious operator ',' [constStatement]
        out (CTC1_PERIOD_HI_REG), a
                                ^
libsrc/target/s1mp3/usb/usb_isr.c:743:6: warning: Redundant assignment of 'hl' to itself. [selfAssignment]
; hl = Buffer
     ^
libsrc/target/s1mp3/usb/usb_isr.c:172:1: style: Label 'ConfigureStall_EP1_OUT' is not used. [unusedLabel]
ConfigureStall_EP1_OUT:
^
libsrc/target/s1mp3/usb/usb_isr.c:206:1: style: Label 'ConfigureStall_EP1_IN' is not used. [unusedLabel]
ConfigureStall_EP1_IN:
^
libsrc/target/s1mp3/usb/usb_isr.c:753:3: style: Label 'hl' is not used. [unusedLabel]
; hl: start position
  ^
libsrc/target/s1mp3/usb/usb_isr.c:754:3: style: Label 'a' is not used. [unusedLabel]
; a:  size of the data should be returned
  ^
libsrc/target/s1mp3/usb/usb_isr.c:393:15: warning: Found suspicious operator ',' [constStatement]
    ld      sp,(_SPKeeper)
              ^
libsrc/target/s1mp3/usb/usb_isr.c:397:14: warning: Found suspicious operator ',' [constStatement]
    ld      a,0ffh                      ; All Irqs
             ^
libsrc/target/s1mp3/usb/usb_isr.c:701:26: warning: Found suspicious operator ',' [constStatement]
    out     (USB_EPI_REG),a             ; EPI=Control-write
                         ^
libsrc/target/s1mp3/usb/usb_isr.c:703:31: warning: Found suspicious operator ',' [constStatement]
    out     (USB_EPI_MODE_REG),a        ; STALL IN/OUT
                              ^
libsrc/target/s1mp3/usb/usb_isr.c:739:7: warning: Found suspicious operator ',' [constStatement]
 ld hl,2 ;const
      ^
libsrc/target/s1mp3/usb/usb_isr.c:744:7: warning: Found suspicious operator ',' [constStatement]
 ld hl,4 ;const
      ^
libsrc/target/s1mp3/usb/usb_isr.c:772:30: warning: Found suspicious operator ',' [constStatement]
    out     (B1_2_MEMMAP_REG),a
                             ^
libsrc/target/s1mp3/usb/usb_isr.c:775:14: warning: Found suspicious operator ',' [constStatement]
    ld      b, USB_EPI_MODE_COMPLETE | USB_EPI_MODE_STALL
             ^
libsrc/target/s1mp3/usb/usb_isr.c:778:56: warning: Found suspicious operator ',' [constStatement]
    call    sSet_Ep0_Rd_Mode    ; b->(USB_EPI_MODE_REG), c->(USB_EPI_MPS_REG)
                                                       ^
libsrc/target/s1mp3/usb/usb_isr.c:795:34: warning: Found suspicious operator ',' [constStatement]
            out     (USB_EPI_REG),a     ; EPI=Control-read
                                 ^
libsrc/target/s1mp3/usb/usb_isr.c:182:2: style: Variable '--------------------------------------------------------------------' is assigned a value that is never used. [unreadVariable]
;----------------------------------------------------------------------
 ^
libsrc/target/s1mp3/usb/usb_isr.c:173:13: style: Unused variable: bc [unusedVariable]
    ld      bc,01bfh                ; Stall EP1_OUT
            ^
libsrc/target/s1mp3/usb/usb_isr.c:216:2: style: Variable '--------------------------------------------------------------------' is assigned a value that is never used. [unreadVariable]
;----------------------------------------------------------------------
 ^
libsrc/target/s1mp3/usb/usb_isr.c:207:13: style: Unused variable: bc [unusedVariable]
    ld      bc,01bfh                ; Stall EP1_IN
            ^
libsrc/target/s1mp3/usb/usb_isr.c:239:2: style: Variable '--------------------------------------------------------------------' is assigned a value that is never used. [unreadVariable]
;----------------------------------------------------------------------
 ^
libsrc/target/s1mp3/usb/usb_isr.c:338:13: style: Variable 'a' is not assigned a value. [unassignedVariable]
    in      a,(INTERNAL_MROM_SRAM_PAGE_REG)
            ^
libsrc/target/s1mp3/usb/usb_isr.c:385:14: style: Variable 'a' is not assigned a value. [unassignedVariable]
;    in      a,(USB_EP_STATUS_REG)
             ^
libsrc/target/s1mp3/usb/usb_isr.c:387:13: style: Unused variable: nz [unusedVariable]
;   jp      nz, EP1_OUT_ISR
            ^
libsrc/target/s1mp3/usb/usb_isr.c:387:17: style: Unused variable: EP1_OUT_ISR [unusedVariable]
;   jp      nz, EP1_OUT_ISR
                ^
libsrc/target/s1mp3/usb/usb_isr.c:389:14: style: Variable 'a' is not assigned a value. [unassignedVariable]
;    ld      a,0ffh                      ; All Irqs
             ^
libsrc/target/s1mp3/usb/usb_isr.c:389:48: style: Unused variable: Irqs [unusedVariable]
;    ld      a,0ffh                      ; All Irqs
                                               ^
libsrc/target/s1mp3/usb/usb_isr.c:464:19: style: Unused variable: dummy_variable_for_stack_alignment [unusedVariable]
    unsigned char dummy_variable_for_stack_alignment;
                  ^
libsrc/target/s1mp3/usb/usb_isr.c:515:19: style: Unused variable: dummy_variable_for_stack_alignment [unusedVariable]
    unsigned char dummy_variable_for_stack_alignment;
                  ^
libsrc/target/s1mp3/usb/usb_isr.c:697:2: style: Variable '--------------------------------------------------------------------' is assigned a value that is never used. [unreadVariable]
;----------------------------------------------------------------------
 ^
libsrc/target/s1mp3/usb/usb_isr.c:751:2: style: Variable '--------------------------------------------------------------------' is assigned a value that is never used. [unreadVariable]
;----------------------------------------------------------------------
 ^
libsrc/target/s1mp3/usb/usb_isr.c:749:8: style: Variable 'hl' is not assigned a value. [unassignedVariable]
 ex de,hl
       ^
libsrc/target/s1mp3/usb/usb_isr.c:753:13: style: Unused variable: position [unusedVariable]
; hl: start position
            ^
libsrc/target/s1mp3/usb/usb_isr.c:774:13: style: Unused variable: bc [unusedVariable]
;   ld      bc,03c7h            ; complete=1,stall=1
            ^
libsrc/target/s1mp3/usb/usb_isr.c:883:49: warning: Either the condition 'outpointer>=80' is redundant or the array 'circularbuffer[80]' is accessed at index 80, which is out of bounds. [arrayIndexOutOfBoundsCond]
                Buffer[count++] = circularbuffer[outpointer++];
                                                ^
libsrc/target/s1mp3/usb/usb_isr.c:884:32: note: Assuming that condition 'outpointer>=80' is not redundant
                if (outpointer >= MAX_BUFFER_SIZE)
                               ^
libsrc/target/s1mp3/usb/usb_isr.c:883:49: note: Array index out of bounds
                Buffer[count++] = circularbuffer[outpointer++];
                                                ^
libsrc/target/s1mp3/usb/usb_isr.c:870:18: style: The scope of the variable 'count' can be reduced. [variableScope]
   unsigned char count;
                 ^
libsrc/target/s1mp3/usb/usb_isr.c:323:34: warning: Found suspicious operator ',' [constStatement]
        out     (USB_DEVADDR_REG),a     ; Enable device with address
                                 ^
libsrc/target/s1mp3/usb/usb_isr.c:874:8: error: Uninitialized variable: Buffer [uninitvar]
   if (Buffer[0] == 0)
       ^
libsrc/target/s1mp3/usb/usb_isr.c:321:17: style: Variable 'a' is not assigned a value. [unassignedVariable]
        ld      a,(_USBDeviceAddress)
                ^
libsrc/target/s1mp3/watchdog/watchdog_disable.c:9:7: style: Variable 'a' is not assigned a value. [unassignedVariable]
 ld   a, 0
      ^
libsrc/target/s1mp3/watchdog/watchdog_enable.c:10:7: error: Uninitialized variable: a [uninitvar]
 or   a, l
      ^
libsrc/target/s1mp3/watchdog/watchdog_enable.c:9:7: style: Variable 'a' is not assigned a value. [unassignedVariable]
 ld   a, WATCHDOG_ENABLE
      ^
libsrc/target/s1mp3/watchdog/watchdog_reset.c:8:5: style: Variable 'a' is not assigned a value. [unassignedVariable]
 in a, (WATCHDOG_REG)
    ^
libsrc/target/srr/srr/fillplot.c:20:9: portability: Returning an integer in a function with pointer return type is not portable. [CastIntegerToAddressAtReturn]
        return *pbase;        /* return the screen RAM addr */
        ^
libsrc/target/srr/srr/tape_save_block.c:35:11: portability: 'addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 itoa(addr+len,parm,16);
          ^
libsrc/target/svi/rs232/rs232_params.c:73:30: error: syntax error [syntaxError]
        bit     7,b     ;Set for 2 stop bits
                             ^
libsrc/target/svi/rs232/rs232_put.c:23:6: style: Variable 'a' is not assigned a value. [unassignedVariable]
 ;in a,(TTMODST)
     ^
libsrc/target/trs80/fcntl/open.c:64:6: portability: Returning an address value in a function with integer return type is not portable. [CastAddressToIntegerAtReturn]
     return (trs80_file);
     ^
libsrc/target/trs80/fcntl/open.c:81:6: portability: Returning an address value in a function with integer return type is not portable. [CastAddressToIntegerAtReturn]
     return (trs80_file);
     ^
libsrc/target/trs80/fcntl/readbyte.c:29:12: warning:inconclusive: Found suspicious operator '-' [constStatement]
  return_c -1;
           ^
libsrc/target/x1/time/time.c:22:10: style: Unused variable: days [unusedVariable]
 long    days;
         ^
libsrc/target/x1/x1/subcpu_get.c:16:1: style: Label 'OBCK' is not used. [unusedLabel]
OBCK:
^
libsrc/target/x1/x1/subcpu_get.c:17:5: style: Variable 'A' is not assigned a value. [unassignedVariable]
 LD A,1AH
    ^
libsrc/target/x1/x1/subcpu_set.c:16:1: style: Label 'IBCK' is not used. [unusedLabel]
IBCK:
^
libsrc/target/x1/x1/subcpu_set.c:17:5: style: Variable 'A' is not assigned a value. [unassignedVariable]
 LD A,1AH
    ^
libsrc/target/z88/fcntl/brotherdor.c:36:10: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
 pop ix ;callers ix
         ^
libsrc/target/z88/fcntl/creat.c:34:73: error: syntax error: !) [syntaxError]
        ld      sp,hl           ;restore our stack (we did nothing to it!)
                                                                        ^
libsrc/target/z88/fcntl/lseek.c:46:47: error: syntax error [syntaxError]
        call_oz(os_frm)         ;must succeed if we get this far!
                                              ^
libsrc/target/z88/fcntl/open.c:31:22: warning:inconclusive: Found suspicious operator '+' [constStatement]
        ld      l,(ix+10)        ;lower 16 of filename
                     ^
libsrc/target/z88/fcntl/open.c:34:22: warning:inconclusive: Found suspicious operator '+' [constStatement]
        ld      a,(ix+8)        ;access flags
                     ^
libsrc/target/z88/fcntl/opendor.c:17:32: error: syntax error [syntaxError]
;Create some room on the stack for the filename to be expanded into..
                               ^
libsrc/target/z88/fcntl/read.c:39:9: style: Same expression on both sides of '&&'. [duplicateExpression]
        and     a
        ^
libsrc/target/z88/fcntl/read.c:27:22: warning:inconclusive: Found suspicious operator '+' [constStatement]
        ld      c,(ix+0)        ;len
                     ^
libsrc/target/z88/fcntl/readdor.c:20:35: error: syntax error [syntaxError]
 ld ix,2  ;Use iy as framepointer for ease
                                  ^
libsrc/target/z88/fcntl/sondor.c:39:10: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
 pop ix ;old ix
         ^
libsrc/target/z88/fcntl/write.c:40:9: style: Same expression on both sides of '&&'. [duplicateExpression]
        and     a
        ^
libsrc/target/z88/fcntl/write.c:28:22: warning:inconclusive: Found suspicious operator '+' [constStatement]
        ld      c,(ix+0)        ;len
                     ^
libsrc/target/z88/fcntl/writedor.c:20:35: error: syntax error [syntaxError]
 ld ix,0  ;Use ix as framepointer for ease
                                  ^
libsrc/target/z88/net/getxxbyport.c:29:9: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        sprintf(store_in, "%u", port);
        ^
libsrc/target/z88/unused/parsename.c:15:10: warning:inconclusive: Found suspicious operator '+' [constStatement]
 ld e,(ix+2) ;st
         ^
libsrc/target/z88/unused/parsename.c:28:9: warning: Found suspicious operator ',' [constStatement]
 ld (hl),0  ;endptr
        ^
libsrc/target/z88/unused/parseseg.c:16:10: warning:inconclusive: Found suspicious operator '+' [constStatement]
 ld l,(ix+4) ;seg
         ^
libsrc/target/z88/z88/QueryPackage.c:12:1: error: Unmatched '{'. Configuration: ''. [syntaxError]
{
^
libsrc/target/z88/z88/fnexpand.c:31:27: error: syntax error [syntaxError]
 xor a ;terminate just in case
                          ^
libsrc/target/z88/z88/openpopup.c:55:21: error: syntax error [syntaxError]
 call_oz(os_out)  ; for width of window
                    ^
libsrc/target/z88/z88/opentitled.c:41:18: warning:inconclusive: Found suspicious operator '/' [constStatement]
 ld b,129  ; left/right bars only
                 ^
libsrc/target/z88/z88/stripdev.c:20:45: error: syntax error [syntaxError]
 jr nz,nostrip ; exit with original pointer if no device
                                            ^
libsrc/target/z88/z88/strippath.c:29:7: warning: Found suspicious operator ',' [constStatement]
 ex de,hl  ; HL=pointer to final segment
      ^
libsrc/target/z88/z88/wcclose.c:25:13: error: syntax error [syntaxError]
 dec hl ;-1 if error
            ^
libsrc/target/z88/z88/wcnext.c:16:10: warning:inconclusive: Found suspicious operator '+' [constStatement]
 ld c,(ix+4) ;len
         ^
libsrc/target/z88/z88/wcnext.c:33:6: warning: Found suspicious operator ',' [constStatement]
 jr z,wcnext_exit ;okay! no buffer
     ^
libsrc/target/z88/z88/wcopen.c:26:6: error: syntax error [syntaxError]
 and @00000011
     ^
libsrc/target/zx-common/fcntl/esxdos/getcwd.c:14:23: error: syntax error [syntaxError]
 push hl ;save buffer for return value
                      ^
libsrc/target/zx-common/fcntl/esxdos/getwd.c:12:23: error: syntax error [syntaxError]
 push hl ;save buffer for return value
                      ^
libsrc/target/zx-common/fcntl/esxdos/lseek.c:7:13: style: Unused variable: asm_esxdos_f_seek [unusedVariable]
     EXTERN asm_esxdos_f_seek
            ^
libsrc/target/zx-common/fcntl/esxdos/open.c:16:14: warning: Found suspicious operator ',' [constStatement]
    ld      c,0  ; esx_mode_open_exist
             ^
libsrc/target/zx-common/fcntl/esxdos/open.c:23:1: style: Unused variable: not_o_creat [unusedVariable]
not_o_creat:
^
libsrc/target/zx-common/fcntl/esxdos/readbyte.c:17:19: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
     pop    ix  ; get users back
                  ^
libsrc/target/zx-common/fcntl/esxdos/writebyte.c:22:20: warning: Redundant assignment of 'hl' to itself. [selfAssignment]
     ret    nc  ;hl= number of bytes written
                   ^
libsrc/target/zx/fcntl/microdrive/lseek.c:23:7: style: The scope of the variable 'if1_filestatus' can be reduced. [variableScope]
 int  if1_filestatus;
      ^
libsrc/target/zx/fcntl/microdrive/lseek.c:25:7: style: The scope of the variable 'sector' can be reduced. [variableScope]
 int  sector;
      ^
libsrc/target/zx/fcntl/microdrive/lseek.c:36:18: style: Variable 'if1_filestatus' is assigned a value that is never used. [unreadVariable]
  if1_filestatus = if1_load_record(if1_file->drive, if1_file->name, 0, if1_file);
                 ^
libsrc/target/zx/fcntl/microdrive/lseek.c:44:20: style: Variable 'if1_filestatus' is assigned a value that is never used. [unreadVariable]
    if1_filestatus = if1_load_sector(if1_file->drive, sector, if1_file);
                   ^
libsrc/target/zx/fcntl/microdrive/open.c:53:2: portability: Returning an address value in a function with integer return type is not portable. [CastAddressToIntegerAtReturn]
 return(if1_file);
 ^
libsrc/target/zx/fcntl/microdrive/open.c:66:3: portability: Returning an address value in a function with integer return type is not portable. [CastAddressToIntegerAtReturn]
  return(if1_file);
  ^
libsrc/target/zx/fcntl/microdrive/open.c:95:3: portability: Returning an address value in a function with integer return type is not portable. [CastAddressToIntegerAtReturn]
  return(if1_file);
  ^
libsrc/target/zx/fcntl/microdrive/open.c:84:18: style: Variable 'if1_filestatus' is assigned a value that is never used. [unreadVariable]
  if1_filestatus = if1_load_record(if1_driveno(name), if1_filename(name), 0, if1_file);
                 ^
libsrc/target/zx/fcntl/microdrive/readbyte.c:24:7: style: The scope of the variable 'if1_filestatus' can be reduced. [variableScope]
 int  if1_filestatus;
      ^
libsrc/target/zx/fcntl/microdrive/writebyte.c:24:7: style: Unused variable: if1_filestatus [unusedVariable]
 int  if1_filestatus;
      ^
libsrc/target/zx/fcntl/plus3/findhand.c:40:1: error: syntax error: ! . gotone [syntaxError]
.gotone
^
libsrc/target/zx/fcntl/plus3/freehand.c:40:1: error: syntax error: ! . gotone [syntaxError]
.gotone ld hl,(_hand_status)
^
libsrc/target/zx/fcntl/plus3/open.c:64:43: error: AST broken, ternary operator missing operand(s) [internalAstError]
 ld c,3  ;exclusive read/write - who cares?
                                          ^
libsrc/target/zx/fcntl/plus3/read.c:25:19: error: syntax error: 0 return [syntaxError]
 ex de,hl  ;len=0 return 0
                  ^
libsrc/target/zx/fcntl/plus3/readbyte.c:20:10: error: syntax error [syntaxError]
 pop bc ;for FASTCALL parameter is pushed on entry
         ^
libsrc/target/zx/fcntl/plus3/write.c:25:19: error: syntax error: 0 return [syntaxError]
 ex de,hl  ;len=0 return 0
                  ^
libsrc/target/zx/rs232/if1/rs232_get.c:228:37: error: There is an unknown macro here somewhere. Configuration is required. If either is a macro then please configure it. [unknownMacro]
L0C34:  POP     AF              ; ( either 0 and NC or the first received byte
                                    ^
libsrc/target/zx/rs232/if1/rs232_init.c:23:25: warning: Found suspicious operator ',' [constStatement]
        ;ld      ($5cc7),a       ; Reset SER-FL to clean the input buffer
                        ^
libsrc/target/zx/rs232/if1/rs232_init.c:23:45: warning:inconclusive: Found suspicious operator '-' [constStatement]
        ;ld      ($5cc7),a       ; Reset SER-FL to clean the input buffer
                                            ^
libsrc/target/zx/rs232/if1/rs232_init.c:25:25: warning: Found suspicious operator ',' [constStatement]
        ;ld      (23750),a       ; Set IOBORD to the current border colour (hide flashing)
                        ^
libsrc/target/zx/rs232/if1/rs232_init.c:22:18: style: Variable 'a' is not assigned a value. [unassignedVariable]
        ;xor     a
                 ^
libsrc/target/zx/rs232/if1/rs232_init.c:24:18: style: Variable 'a' is not assigned a value. [unassignedVariable]
        ;ld      a,(23624)
                 ^
libsrc/target/zx/rs232/if1/rs232_params.c:74:66: error: syntax error: $037 . ; [syntaxError]
        ; (a bug in cpp was changing the next line to:  defw $037. ;0x04 ; experimental ... now fixed)
                                                                 ^
libsrc/target/zx/rs232/if1/rs232_put.c:40:119: error: syntax error [syntaxError]
;        OUT     ($FE),A         ; Change the border colour.  -  No Thanks Jetset Willy change the borders in program if wanted
                                                                                                                      ^
libsrc/target/zx/rs232/plus3/rs232_get.c:75:42: error: syntax error [syntaxError]
        LD   B,$FA        ; Waiting time for start bit.
                                         ^
libsrc/target/zx/rs232/plus3/rs232_init.c:29:13: style: Unused variable: speed [unusedVariable]
  ; Default speed: 2400 baud
            ^
libsrc/target/zx/rs232/plus3/rs232_params.c:42:19: warning: Found suspicious operator ',' [constStatement]
        ld      hl,1            ; RS_ERR_NOT_INITIALIZED
                  ^
libsrc/target/zx/rs232/plus3/rs232_params.c:65:19: warning: Found suspicious operator ',' [constStatement]
        ld      hl,0            ; RS_ERR_OK
                  ^
libsrc/target/zx/rs232/plus3/rs232_params.c:62:19: style: Unused variable: a [unusedVariable]
        ld      l,a
                  ^
libsrc/target/zx/rs232/plus3/rs232_put.c:78:55: error: There is an unknown macro here somewhere. Configuration is required. If a is a macro then please configure it. [unknownMacro]
        JP   NC,L08F9     ; Branch to transmit a 1 or a 0 (initially sending a 0 for the start bit).
                                                      ^
libsrc/threading/preempt/get_task.c:14:32: error: syntax error [syntaxError]
 ; Exit        ix = Task table for specified task
                               ^
libsrc/threading/preempt/roundrobin_scheduler.c:27:14: error: syntax error [syntaxError]
; Jump table for the roundrobin scheduler
             ^
libsrc/threading/preempt/sem_post.c:29:3: error: Syntax Error: AST broken, binary operator '||' doesn't have two operands. [internalAstError]
; or l
  ^
libsrc/threading/preempt/sem_wait.c:39:12: warning: Found suspicious operator ',' [constStatement]
 ld      ix,(_threadbase + current) ; Get current thread
           ^
libsrc/threading/preempt/sem_wait.c:40:15: warning:inconclusive: Found suspicious operator '+' [constStatement]
 set     0,(ix+thread_flags)  ; We should sleep
              ^
libsrc/threading/preempt/thread_create.c:15:6: error: syntax error: 2 = [syntaxError]
; sp + 2 = prio
     ^
libsrc/threading/preempt/thread_exit.c:17:21: warning:inconclusive: Found suspicious operator '+' [constStatement]
   res         7,(ix+thread_flags)      ; Thread no available
                    ^
libsrc/threading/preempt/thread_exit.c:14:18: error: Uninitialized variable: ix [uninitvar]
   bit        2,(ix+thread_flags)
                 ^
libsrc/threading/preempt/thread_exit.c:13:16: style: Variable 'ix' is not assigned a value. [unassignedVariable]
   ld          ix,(_threadbase + current)
               ^
libsrc/threading/preempt/thread_exit.c:19:4: style: Unused variable: halt [unusedVariable]
   halt    ; We should no longer exist
   ^
libsrc/threading/preempt/thread_manager.c:34:60: error: syntax error [syntaxError]
          ld    hl,(_threadbase + task_save_func)    ; See if there is an OS specific saving to do
                                                           ^
libsrc/threading/preempt/thread_manager_start.c:33:34: warning: Found suspicious operator ',' [constStatement]
        ld      (ix + thread_pid),0  ; Fake number
                                 ^
libsrc/threading/preempt/thread_manager_start.c:36:24: warning: Found suspicious operator ',' [constStatement]
 ld (ix + thread_flags),130  ; System - cannot exit
                       ^
libsrc/time/ctime.c:19:10: style: Obsolete function 'asctime' called. It is recommended to use 'strftime' instead. [asctimeCalled]
 return (asctime(timeinfo));
         ^
libsrc/time/gmtime.c:128:13: style: The scope of the variable 'tm2' can be reduced. [variableScope]
 struct tm *tm2;
            ^
libsrc/video/regis/regis_position.c:17:31: style:inconclusive: Function '__regis_move_rel' argument 1 names different: declaration 'x' definition 'xp'. [funcArgNamesDifferent]
void __regis_move_rel(int16_t xp, int16_t yp)
                              ^
libsrc/video/regis/regis.h:18:38: note: Function '__regis_move_rel' argument 1 names different: declaration 'x' definition 'xp'.
extern void __regis_move_rel(int16_t x, int16_t y);
                                     ^
libsrc/video/regis/regis_position.c:17:31: note: Function '__regis_move_rel' argument 1 names different: declaration 'x' definition 'xp'.
void __regis_move_rel(int16_t xp, int16_t yp)
                              ^
libsrc/video/regis/regis_position.c:17:43: style:inconclusive: Function '__regis_move_rel' argument 2 names different: declaration 'y' definition 'yp'. [funcArgNamesDifferent]
void __regis_move_rel(int16_t xp, int16_t yp)
                                          ^
libsrc/video/regis/regis.h:18:49: note: Function '__regis_move_rel' argument 2 names different: declaration 'y' definition 'yp'.
extern void __regis_move_rel(int16_t x, int16_t y);
                                                ^
libsrc/video/regis/regis_position.c:17:43: note: Function '__regis_move_rel' argument 2 names different: declaration 'y' definition 'yp'.
void __regis_move_rel(int16_t xp, int16_t yp)
                                          ^
libsrc/video/tms9918/msx_calculate_side.c:22:14: style: The scope of the variable 'ux' can be reduced. [variableScope]
 int ly, hy, ux;
             ^
src/appmake/abc80.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/abc80.c:123:18: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fin. [nullPointerRedundantCheck]
    while (!feof(fin)) {
                 ^
src/appmake/abc80.c:294:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/abc80.c:335:22: note: Calling function 'datablockout', 1st argument 'fpin' value is 0
        datablockout(fpin, fpout);
                     ^
src/appmake/abc80.c:123:18: note: Null pointer dereference
    while (!feof(fin)) {
                 ^
src/appmake/abc80.c:193:19: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/abc80.c:185:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/abc80.c:193:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/abc80.c:198:21: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin);
                    ^
src/appmake/abc80.c:185:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/abc80.c:198:21: note: Null pointer dereference
        len = ftell(fpin);
                    ^
src/appmake/abc80.c:200:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/abc80.c:185:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/abc80.c:200:15: note: Null pointer dereference
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/abc80.c:208:17: warning: Either the condition '(fpout=fopen(tmpname,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fprintf(fpout, "10 B=%i", pos);
                ^
src/appmake/abc80.c:202:44: note: Assuming that condition '(fpout=fopen(tmpname,"wb"))==NULL' is not redundant
        if ((fpout = fopen(tmpname, "wb")) == NULL) {
                                           ^
src/appmake/abc80.c:208:17: note: Null pointer dereference
        fprintf(fpout, "10 B=%i", pos);
                ^
src/appmake/abc80.c:209:19: warning: Either the condition '(fpout=fopen(tmpname,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fputc(13, fpout);
                  ^
src/appmake/abc80.c:202:44: note: Assuming that condition '(fpout=fopen(tmpname,"wb"))==NULL' is not redundant
        if ((fpout = fopen(tmpname, "wb")) == NULL) {
                                           ^
src/appmake/abc80.c:209:19: note: Null pointer dereference
        fputc(13, fpout);
                  ^
src/appmake/abc80.c:210:17: warning: Either the condition '(fpout=fopen(tmpname,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fprintf(fpout, "20 FOR I=B To B+%i", len - 1);
                ^
src/appmake/abc80.c:202:44: note: Assuming that condition '(fpout=fopen(tmpname,"wb"))==NULL' is not redundant
        if ((fpout = fopen(tmpname, "wb")) == NULL) {
                                           ^
src/appmake/abc80.c:210:17: note: Null pointer dereference
        fprintf(fpout, "20 FOR I=B To B+%i", len - 1);
                ^
src/appmake/abc80.c:211:19: warning: Either the condition '(fpout=fopen(tmpname,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fputc(13, fpout);
                  ^
src/appmake/abc80.c:202:44: note: Assuming that condition '(fpout=fopen(tmpname,"wb"))==NULL' is not redundant
        if ((fpout = fopen(tmpname, "wb")) == NULL) {
                                           ^
src/appmake/abc80.c:211:19: note: Null pointer dereference
        fputc(13, fpout);
                  ^
src/appmake/abc80.c:212:17: warning: Either the condition '(fpout=fopen(tmpname,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fprintf(fpout, "30 READ A");
                ^
src/appmake/abc80.c:202:44: note: Assuming that condition '(fpout=fopen(tmpname,"wb"))==NULL' is not redundant
        if ((fpout = fopen(tmpname, "wb")) == NULL) {
                                           ^
src/appmake/abc80.c:212:17: note: Null pointer dereference
        fprintf(fpout, "30 READ A");
                ^
src/appmake/abc80.c:213:19: warning: Either the condition '(fpout=fopen(tmpname,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fputc(13, fpout);
                  ^
src/appmake/abc80.c:202:44: note: Assuming that condition '(fpout=fopen(tmpname,"wb"))==NULL' is not redundant
        if ((fpout = fopen(tmpname, "wb")) == NULL) {
                                           ^
src/appmake/abc80.c:213:19: note: Null pointer dereference
        fputc(13, fpout);
                  ^
src/appmake/abc80.c:214:17: warning: Either the condition '(fpout=fopen(tmpname,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fprintf(fpout, "40 POKE I,A");
                ^
src/appmake/abc80.c:202:44: note: Assuming that condition '(fpout=fopen(tmpname,"wb"))==NULL' is not redundant
        if ((fpout = fopen(tmpname, "wb")) == NULL) {
                                           ^
src/appmake/abc80.c:214:17: note: Null pointer dereference
        fprintf(fpout, "40 POKE I,A");
                ^
src/appmake/abc80.c:215:19: warning: Either the condition '(fpout=fopen(tmpname,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fputc(13, fpout);
                  ^
src/appmake/abc80.c:202:44: note: Assuming that condition '(fpout=fopen(tmpname,"wb"))==NULL' is not redundant
        if ((fpout = fopen(tmpname, "wb")) == NULL) {
                                           ^
src/appmake/abc80.c:215:19: note: Null pointer dereference
        fputc(13, fpout);
                  ^
src/appmake/abc80.c:216:17: warning: Either the condition '(fpout=fopen(tmpname,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fprintf(fpout, "50 NEXT I");
                ^
src/appmake/abc80.c:202:44: note: Assuming that condition '(fpout=fopen(tmpname,"wb"))==NULL' is not redundant
        if ((fpout = fopen(tmpname, "wb")) == NULL) {
                                           ^
src/appmake/abc80.c:216:17: note: Null pointer dereference
        fprintf(fpout, "50 NEXT I");
                ^
src/appmake/abc80.c:217:19: warning: Either the condition '(fpout=fopen(tmpname,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fputc(13, fpout);
                  ^
src/appmake/abc80.c:202:44: note: Assuming that condition '(fpout=fopen(tmpname,"wb"))==NULL' is not redundant
        if ((fpout = fopen(tmpname, "wb")) == NULL) {
                                           ^
src/appmake/abc80.c:217:19: note: Null pointer dereference
        fputc(13, fpout);
                  ^
src/appmake/abc80.c:218:17: warning: Either the condition '(fpout=fopen(tmpname,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fprintf(fpout, "60 R=CALL(B)");
                ^
src/appmake/abc80.c:202:44: note: Assuming that condition '(fpout=fopen(tmpname,"wb"))==NULL' is not redundant
        if ((fpout = fopen(tmpname, "wb")) == NULL) {
                                           ^
src/appmake/abc80.c:218:17: note: Null pointer dereference
        fprintf(fpout, "60 R=CALL(B)");
                ^
src/appmake/abc80.c:231:19: warning: Either the condition '(fpout=fopen(tmpname,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fputc(13, fpout);
                  ^
src/appmake/abc80.c:202:44: note: Assuming that condition '(fpout=fopen(tmpname,"wb"))==NULL' is not redundant
        if ((fpout = fopen(tmpname, "wb")) == NULL) {
                                           ^
src/appmake/abc80.c:231:19: note: Null pointer dereference
        fputc(13, fpout);
                  ^
src/appmake/abc80.c:232:16: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fclose(fpin);
               ^
src/appmake/abc80.c:185:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/abc80.c:232:16: note: Null pointer dereference
        fclose(fpin);
               ^
src/appmake/abc80.c:233:16: warning: Either the condition '(fpout=fopen(tmpname,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fclose(fpout);
               ^
src/appmake/abc80.c:202:44: note: Assuming that condition '(fpout=fopen(tmpname,"wb"))==NULL' is not redundant
        if ((fpout = fopen(tmpname, "wb")) == NULL) {
                                           ^
src/appmake/abc80.c:233:16: note: Null pointer dereference
        fclose(fpout);
               ^
src/appmake/abc80.c:248:19: warning: Either the condition '(fpin=fopen(tmpname,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/abc80.c:240:43: note: Assuming that condition '(fpin=fopen(tmpname,"rb"))==NULL' is not redundant
        if ((fpin = fopen(tmpname, "rb")) == NULL) {
                                          ^
src/appmake/abc80.c:248:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/abc80.c:253:21: warning: Either the condition '(fpin=fopen(tmpname,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin);
                    ^
src/appmake/abc80.c:240:43: note: Assuming that condition '(fpin=fopen(tmpname,"rb"))==NULL' is not redundant
        if ((fpin = fopen(tmpname, "rb")) == NULL) {
                                          ^
src/appmake/abc80.c:253:21: note: Null pointer dereference
        len = ftell(fpin);
                    ^
src/appmake/abc80.c:256:15: warning: Either the condition '(fpin=fopen(tmpname,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/abc80.c:240:43: note: Assuming that condition '(fpin=fopen(tmpname,"rb"))==NULL' is not redundant
        if ((fpin = fopen(tmpname, "rb")) == NULL) {
                                          ^
src/appmake/abc80.c:256:15: note: Null pointer dereference
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/abc80.c:279:18: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fputc(3, fpout);
                 ^
src/appmake/abc80.c:258:45: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
        if ((fpout = fopen(filename, "wb")) == NULL) {
                                            ^
src/appmake/abc80.c:279:18: note: Null pointer dereference
        fputc(3, fpout);
                 ^
src/appmake/abc80.c:286:16: warning: Either the condition '(fpin=fopen(tmpname,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fclose(fpin);
               ^
src/appmake/abc80.c:240:43: note: Assuming that condition '(fpin=fopen(tmpname,"rb"))==NULL' is not redundant
        if ((fpin = fopen(tmpname, "rb")) == NULL) {
                                          ^
src/appmake/abc80.c:286:16: note: Null pointer dereference
        fclose(fpin);
               ^
src/appmake/abc80.c:287:16: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fclose(fpout);
               ^
src/appmake/abc80.c:258:45: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
        if ((fpout = fopen(filename, "wb")) == NULL) {
                                            ^
src/appmake/abc80.c:287:16: note: Null pointer dereference
        fclose(fpout);
               ^
src/appmake/abc80.c:298:19: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/abc80.c:294:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/abc80.c:298:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/abc80.c:302:21: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin);
                    ^
src/appmake/abc80.c:294:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/abc80.c:302:21: note: Null pointer dereference
        len = ftell(fpin);
                    ^
src/appmake/abc80.c:303:15: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0, SEEK_SET);
              ^
src/appmake/abc80.c:294:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/abc80.c:303:15: note: Null pointer dereference
        fseek(fpin, 0, SEEK_SET);
              ^
src/appmake/abc80.c:337:16: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fclose(fpin);
               ^
src/appmake/abc80.c:294:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/abc80.c:337:16: note: Null pointer dereference
        fclose(fpin);
               ^
src/appmake/abc80.c:338:16: warning: Either the condition '(fpout=fopen(wavfile,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fclose(fpout);
               ^
src/appmake/abc80.c:309:44: note: Assuming that condition '(fpout=fopen(wavfile,"wb"))==NULL' is not redundant
        if ((fpout = fopen(wavfile, "wb")) == NULL) {
                                           ^
src/appmake/abc80.c:338:16: note: Null pointer dereference
        fclose(fpout);
               ^
src/appmake/abc80.c:142:10: style: The scope of the variable 'wavfile' can be reduced. [variableScope]
    char wavfile[FILENAME_MAX + 1];
         ^
src/appmake/abc80.c:143:10: style: The scope of the variable 'tmpname' can be reduced. [variableScope]
    char tmpname[FILENAME_MAX + 1];
         ^
src/appmake/abc80.c:145:9: style: The scope of the variable 'c' can be reduced. [variableScope]
    int c;
        ^
src/appmake/abc80.c:148:9: style: The scope of the variable 'lnum' can be reduced. [variableScope]
    int lnum;
        ^
src/appmake/abc80.c:150:9: style: The scope of the variable 'blcount' can be reduced. [variableScope]
    int blcount;
        ^
src/appmake/abc80.c:152:9: style: The scope of the variable 'numbyte' can be reduced. [variableScope]
    int numbyte;
        ^
src/appmake/abc80.c:254:16: style: Variable 'blocks' is assigned a value that is never used. [unreadVariable]
        blocks = len / 252;
               ^
src/appmake/ace-tap.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/ace-tap.c:108:13: error: Resource handle 'fpin' freed twice. [doubleFree]
            fclose(fpin);
            ^
src/appmake/ace-tap.c:99:13: note: Resource handle 'fpin' freed twice.
            fclose(fpin);
            ^
src/appmake/ace-tap.c:108:13: note: Resource handle 'fpin' freed twice.
            fclose(fpin);
            ^
src/appmake/ace-tap.c:98:19: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/ace-tap.c:90:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/ace-tap.c:98:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/ace-tap.c:103:21: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin);
                    ^
src/appmake/ace-tap.c:90:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/ace-tap.c:103:21: note: Null pointer dereference
        len = ftell(fpin);
                    ^
src/appmake/ace-tap.c:105:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/ace-tap.c:90:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/ace-tap.c:105:15: note: Null pointer dereference
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/ace-tap.c:177:16: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fclose(fpin);
               ^
src/appmake/ace-tap.c:90:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/ace-tap.c:177:16: note: Null pointer dereference
        fclose(fpin);
               ^
src/appmake/ace-tap.c:178:16: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fclose(fpout);
               ^
src/appmake/ace-tap.c:107:45: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
        if ((fpout = fopen(filename, "wb")) == NULL) {
                                            ^
src/appmake/ace-tap.c:178:16: note: Null pointer dereference
        fclose(fpout);
               ^
src/appmake/ace-tap.c:189:19: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/ace-tap.c:185:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/ace-tap.c:189:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/ace-tap.c:193:21: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin);
                    ^
src/appmake/ace-tap.c:185:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/ace-tap.c:193:21: note: Null pointer dereference
        len = ftell(fpin);
                    ^
src/appmake/ace-tap.c:194:15: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/ace-tap.c:185:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/ace-tap.c:194:15: note: Null pointer dereference
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/ace-tap.c:207:22: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        while (ftell(fpin) < len) {
                     ^
src/appmake/ace-tap.c:185:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/ace-tap.c:207:22: note: Null pointer dereference
        while (ftell(fpin) < len) {
                     ^
src/appmake/ace-tap.c:235:16: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fclose(fpin);
               ^
src/appmake/ace-tap.c:185:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/ace-tap.c:235:16: note: Null pointer dereference
        fclose(fpin);
               ^
src/appmake/ace-tap.c:236:16: warning: Either the condition '(fpout=fopen(wavfile,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fclose(fpout);
               ^
src/appmake/ace-tap.c:198:44: note: Assuming that condition '(fpout=fopen(wavfile,"wb"))==NULL' is not redundant
        if ((fpout = fopen(wavfile, "wb")) == NULL) {
                                           ^
src/appmake/ace-tap.c:236:16: note: Null pointer dereference
        fclose(fpout);
               ^
src/appmake/ace-tap.c:47:10: style: The scope of the variable 'wavfile' can be reduced. [variableScope]
    char wavfile[FILENAME_MAX + 1];
         ^
src/appmake/ace-tap.c:48:10: style: The scope of the variable 'name' can be reduced. [variableScope]
    char name[11];
         ^
src/appmake/ace-tap.c:51:10: style: The scope of the variable 'command' can be reduced. [variableScope]
    char command[] = "0 0 BLOAD z88dk_code       CALL";
         ^
src/appmake/ace-tap.c:58:9: style: The scope of the variable 'pos' can be reduced. [variableScope]
    int pos;
        ^
src/appmake/ace-tap.c:59:9: style: The scope of the variable 'blocklen' can be reduced. [variableScope]
    int blocklen;
        ^
src/appmake/adam.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/adam.c:59:5: error: Resource handle 'bootstrap_fp' freed twice. [doubleFree]
    fclose(bootstrap_fp);
    ^
src/appmake/adam.c:46:9: note: Resource handle 'bootstrap_fp' freed twice.
        fclose(bootstrap_fp);
        ^
src/appmake/adam.c:59:5: note: Resource handle 'bootstrap_fp' freed twice.
    fclose(bootstrap_fp);
    ^
src/appmake/adam.c:75:44: error: Resource handle 'fpin' freed twice. [doubleFree]
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                           ^
src/appmake/adam.c:68:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/adam.c:75:44: note: Resource handle 'fpin' freed twice.
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                           ^
src/appmake/adam.c:76:5: error: Resource handle 'fpin' freed twice. [doubleFree]
    fclose(fpin);
    ^
src/appmake/adam.c:68:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/adam.c:76:5: note: Resource handle 'fpin' freed twice.
    fclose(fpin);
    ^
src/appmake/adam.c:45:16: warning: Either the condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: bootstrap_fp. [nullPointerRedundantCheck]
    if ( fseek(bootstrap_fp,0,SEEK_END) ) {
               ^
src/appmake/adam.c:42:55: note: Assuming that condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (bootstrap_fp=fopen_bin(bootname, crtfile) ) == NULL ) {
                                                      ^
src/appmake/adam.c:45:16: note: Null pointer dereference
    if ( fseek(bootstrap_fp,0,SEEK_END) ) {
               ^
src/appmake/adam.c:49:21: warning: Either the condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: bootstrap_fp. [nullPointerRedundantCheck]
    bootlen = ftell(bootstrap_fp);
                    ^
src/appmake/adam.c:42:55: note: Assuming that condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (bootstrap_fp=fopen_bin(bootname, crtfile) ) == NULL ) {
                                                      ^
src/appmake/adam.c:49:21: note: Null pointer dereference
    bootlen = ftell(bootstrap_fp);
                    ^
src/appmake/adam.c:50:11: warning: Either the condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: bootstrap_fp. [nullPointerRedundantCheck]
    fseek(bootstrap_fp,0L,SEEK_SET);
          ^
src/appmake/adam.c:42:55: note: Assuming that condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (bootstrap_fp=fopen_bin(bootname, crtfile) ) == NULL ) {
                                                      ^
src/appmake/adam.c:50:11: note: Null pointer dereference
    fseek(bootstrap_fp,0L,SEEK_SET);
          ^
src/appmake/adam.c:56:37: warning: Either the condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: bootstrap_fp. [nullPointerRedundantCheck]
    if ( fread(bootbuf, 1, bootlen, bootstrap_fp) != bootlen ) {
                                    ^
src/appmake/adam.c:42:55: note: Assuming that condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (bootstrap_fp=fopen_bin(bootname, crtfile) ) == NULL ) {
                                                      ^
src/appmake/adam.c:56:37: note: Null pointer dereference
    if ( fread(bootbuf, 1, bootlen, bootstrap_fp) != bootlen ) {
                                    ^
src/appmake/adam.c:59:12: warning: Either the condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: bootstrap_fp. [nullPointerRedundantCheck]
    fclose(bootstrap_fp);
           ^
src/appmake/adam.c:42:55: note: Assuming that condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (bootstrap_fp=fopen_bin(bootname, crtfile) ) == NULL ) {
                                                      ^
src/appmake/adam.c:59:12: note: Null pointer dereference
    fclose(bootstrap_fp);
           ^
src/appmake/adam.c:67:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/adam.c:63:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/adam.c:67:15: note: Null pointer dereference
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/adam.c:72:17: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    pos = ftell(fpin);
                ^
src/appmake/adam.c:63:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/adam.c:72:17: note: Null pointer dereference
    pos = ftell(fpin);
                ^
src/appmake/adam.c:73:11: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/adam.c:63:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/adam.c:73:11: note: Null pointer dereference
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/adam.c:75:35: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                  ^
src/appmake/adam.c:63:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/adam.c:75:35: note: Null pointer dereference
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                  ^
src/appmake/adam.c:76:12: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/adam.c:63:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/adam.c:76:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/adam.c:84:46: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    if ( fwrite(bootbuf, sizeof(char), 1024, fpout) != 1024) {
                                             ^
src/appmake/adam.c:80:43: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ( ( fpout = fopen(filename, "wb")) == NULL ) {
                                          ^
src/appmake/adam.c:84:46: note: Null pointer dereference
    if ( fwrite(bootbuf, sizeof(char), 1024, fpout) != 1024) {
                                             ^
src/appmake/adam.c:88:48: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    if ( fwrite(buf, sizeof(char), 255 * 1024, fpout) != 255 * 1024) {
                                               ^
src/appmake/adam.c:80:43: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ( ( fpout = fopen(filename, "wb")) == NULL ) {
                                          ^
src/appmake/adam.c:88:48: note: Null pointer dereference
    if ( fwrite(buf, sizeof(char), 255 * 1024, fpout) != 255 * 1024) {
                                               ^
src/appmake/adam.c:91:12: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/adam.c:80:43: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ( ( fpout = fopen(filename, "wb")) == NULL ) {
                                          ^
src/appmake/adam.c:91:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/appmake.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 21 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/appmake.c:1179:13: warning: sscanf() without field width limits can crash with huge input data. [invalidscanf]
        if (sscanf(buffer, "%s = $%lx", symbol_name, (long unsigned int *) &symbol_value) == 2)
            ^
src/appmake/appmake.c:1121:5: error: Common realloc mistake: 'temp_files' nulled but not freed upon failure [memleakOnRealloc]
    temp_files = realloc(temp_files, num_temp_files * sizeof(temp_files[0]));
    ^
src/appmake/appmake.c:549:13: style: Variable 'ret' is reassigned a value before the old one has been used. [redundantAssignment]
        ret = pos + 1;
            ^
src/appmake/appmake.c:543:9: note: ret is assigned
    ret = pos;
        ^
src/appmake/appmake.c:549:13: note: ret is overwritten
        ret = pos + 1;
            ^
src/appmake/appmake.c:800:14: style: The scope of the variable 'c' can be reduced. [variableScope]
    int      c;
             ^
src/appmake/appmake.c:1184:17: style: The scope of the variable 'type' can be reduced. [variableScope]
            int type = 0;
                ^
src/appmake/appmake.c:1439:12: style: The scope of the variable 'p' can be reduced. [variableScope]
    char  *p;
           ^
src/appmake/appmake.c:1594:9: style: The scope of the variable 'k' can be reduced. [variableScope]
    int k;
        ^
src/appmake/appmake.c:1667:11: style: The scope of the variable 'fin' can be reduced. [variableScope]
    FILE *fin;
          ^
src/appmake/appmake.c:1668:11: style: The scope of the variable 'c' can be reduced. [variableScope]
    int   c, i, total, size;
          ^
src/appmake/appmake.c:412:61: style:inconclusive: Function 'any_suffix_change' argument 3 names different: declaration 'schar' definition 'suffix_delimiter'. [funcArgNamesDifferent]
void any_suffix_change(char *name, const char *suffix, char suffix_delimiter)
                                                            ^
src/appmake/appmake.h:651:76: note: Function 'any_suffix_change' argument 3 names different: declaration 'schar' definition 'suffix_delimiter'.
extern void         any_suffix_change(char *name, const char *suffix, char schar);
                                                                           ^
src/appmake/appmake.c:412:61: note: Function 'any_suffix_change' argument 3 names different: declaration 'schar' definition 'suffix_delimiter'.
void any_suffix_change(char *name, const char *suffix, char suffix_delimiter)
                                                            ^
src/appmake/appmake.c:538:65: style:inconclusive: Function 'option_set' argument 4 names different: declaration 'opt' definition 'option'. [funcArgNamesDifferent]
static int option_set(int pos, int max, char *argv[], option_t *option)
                                                                ^
src/appmake/appmake.c:44:74: note: Function 'option_set' argument 4 names different: declaration 'opt' definition 'option'.
static int          option_set(int pos, int max, char *argv[], option_t *opt);
                                                                         ^
src/appmake/appmake.c:538:65: note: Function 'option_set' argument 4 names different: declaration 'opt' definition 'option'.
static int option_set(int pos, int max, char *argv[], option_t *option)
                                                                ^
src/appmake/appmake.c:796:20: style:inconclusive: Function 'raw2wav' argument 1 names different: declaration 'rawfilename' definition 'wavfile'. [funcArgNamesDifferent]
void raw2wav(char *wavfile)
                   ^
src/appmake/appmake.h:682:35: note: Function 'raw2wav' argument 1 names different: declaration 'rawfilename' definition 'wavfile'.
extern void         raw2wav(char *rawfilename);
                                  ^
src/appmake/appmake.c:796:20: note: Function 'raw2wav' argument 1 names different: declaration 'rawfilename' definition 'wavfile'.
void raw2wav(char *wavfile)
                   ^
src/appmake/appmake.c:852:24: style:inconclusive: Function 'raw2wav_22k' argument 1 names different: declaration 'rawfilename' definition 'wavfile'. [funcArgNamesDifferent]
void raw2wav_22k(char *wavfile, int mode)
                       ^
src/appmake/appmake.h:683:39: note: Function 'raw2wav_22k' argument 1 names different: declaration 'rawfilename' definition 'wavfile'.
extern void         raw2wav_22k(char *rawfilename, int mode);
                                      ^
src/appmake/appmake.c:852:24: note: Function 'raw2wav_22k' argument 1 names different: declaration 'rawfilename' definition 'wavfile'.
void raw2wav_22k(char *wavfile, int mode)
                       ^
src/appmake/aquarius.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/aquarius.c:406:14: warning: Either the condition 'fpin==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
   if (fseek(fpin, 0, SEEK_END)) {
             ^
src/appmake/aquarius.c:402:13: note: Assuming that condition 'fpin==NULL' is not redundant
   if (fpin == NULL) {
            ^
src/appmake/aquarius.c:406:14: note: Null pointer dereference
   if (fseek(fpin, 0, SEEK_END)) {
             ^
src/appmake/aquarius.c:410:16: warning: Either the condition 'fpin==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
   len = ftell(fpin);
               ^
src/appmake/aquarius.c:402:13: note: Assuming that condition 'fpin==NULL' is not redundant
   if (fpin == NULL) {
            ^
src/appmake/aquarius.c:410:16: note: Null pointer dereference
   len = ftell(fpin);
               ^
src/appmake/aquarius.c:411:10: warning: Either the condition 'fpin==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
   fseek(fpin, 0L, SEEK_SET);
         ^
src/appmake/aquarius.c:402:13: note: Assuming that condition 'fpin==NULL' is not redundant
   if (fpin == NULL) {
            ^
src/appmake/aquarius.c:411:10: note: Null pointer dereference
   fseek(fpin, 0L, SEEK_SET);
         ^
src/appmake/aquarius.c:422:17: warning: Either the condition 'fpin==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
   while (ftell(fpin) < len)
                ^
src/appmake/aquarius.c:402:13: note: Assuming that condition 'fpin==NULL' is not redundant
   if (fpin == NULL) {
            ^
src/appmake/aquarius.c:422:17: note: Null pointer dereference
   while (ftell(fpin) < len)
                ^
src/appmake/aquarius.c:514:11: warning: Either the condition 'fpin==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
   fclose(fpin);
          ^
src/appmake/aquarius.c:402:13: note: Assuming that condition 'fpin==NULL' is not redundant
   if (fpin == NULL) {
            ^
src/appmake/aquarius.c:514:11: note: Null pointer dereference
   fclose(fpin);
          ^
src/appmake/aquarius.c:517:16: warning: Either the condition '(fpout=fopen(wavfile,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fclose(fpout);
               ^
src/appmake/aquarius.c:380:38: note: Assuming that condition '(fpout=fopen(wavfile,"wb"))==NULL' is not redundant
  if ((fpout = fopen(wavfile, "wb")) == NULL) {
                                     ^
src/appmake/aquarius.c:517:16: note: Null pointer dereference
        fclose(fpout);
               ^
src/appmake/aquarius.c:125:13: style: The scope of the variable 'wavfile' can be reduced. [variableScope]
    char    wavfile[FILENAME_MAX+1];
            ^
src/appmake/aquarius.c:128:10: style: The scope of the variable 'mybuf' can be reduced. [variableScope]
    char mybuf[20];
         ^
src/appmake/aquarius.c:129:14: style: The scope of the variable 'copy1' can be reduced. [variableScope]
    char    *copy1, *copy2;
             ^
src/appmake/aquarius.c:129:22: style: The scope of the variable 'copy2' can be reduced. [variableScope]
    char    *copy1, *copy2;
                     ^
src/appmake/aquarius.c:131:9: style: The scope of the variable 'c' can be reduced. [variableScope]
    int c;
        ^
src/appmake/aquarius.c:132:11: style: The scope of the variable 'j' can be reduced. [variableScope]
    int i,j;
          ^
src/appmake/aquarius.c:134:9: style: The scope of the variable 'dlen' can be reduced. [variableScope]
    int dlen;
        ^
src/appmake/aquarius.c:135:6: style: The scope of the variable 'step' can be reduced. [variableScope]
 int step;
     ^
src/appmake/aquarius.c:137:6: style: The scope of the variable 'ncharin' can be reduced. [variableScope]
 int ncharin;
     ^
src/appmake/aquarius.c:138:17: style: The scope of the variable 'cmin' can be reduced. [variableScope]
 static uint8_t cmin, cmout;
                ^
src/appmake/aquarius.c:138:23: style: The scope of the variable 'cmout' can be reduced. [variableScope]
 static uint8_t cmin, cmout;
                      ^
src/appmake/aquarius.c:140:10: style: The scope of the variable 'WriteSilence' can be reduced. [variableScope]
    int  WriteSilence;
         ^
src/appmake/aquarius.c:141:10: style: The scope of the variable 'nmode' can be reduced. [variableScope]
    int  nmode;
         ^
src/appmake/aquarius.c:142:10: style: The scope of the variable 'nbyteinblock' can be reduced. [variableScope]
    int  nbyteinblock;  // Could be used for logging
         ^
src/appmake/asm/turbo.c:292:18: error: There is an unknown macro here somewhere. Configuration is required. If was is a macro then please configure it. [unknownMacro]
   LD A,0Dh   ; (was 16 in ROM) Wait 358 T states before entering the sampling loop
                 ^
src/appmake/c128.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/c128.c:98:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin,0,SEEK_END)) {
              ^
src/appmake/c128.c:94:43: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
 if ( (fpin=fopen_bin(binname, crtfile) ) == NULL ) {
                                          ^
src/appmake/c128.c:98:15: note: Null pointer dereference
    if (fseek(fpin,0,SEEK_END)) {
              ^
src/appmake/c128.c:103:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    len=ftell(fpin);
              ^
src/appmake/c128.c:94:43: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
 if ( (fpin=fopen_bin(binname, crtfile) ) == NULL ) {
                                          ^
src/appmake/c128.c:103:15: note: Null pointer dereference
    len=ftell(fpin);
              ^
src/appmake/c128.c:105:11: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin,0L,SEEK_SET);
          ^
src/appmake/c128.c:94:43: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
 if ( (fpin=fopen_bin(binname, crtfile) ) == NULL ) {
                                          ^
src/appmake/c128.c:105:11: note: Null pointer dereference
    fseek(fpin,0L,SEEK_SET);
          ^
src/appmake/c128.c:127:11: warning: Either the condition '(fpout=fopen(tapfile,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
  fprintf(fpout,"C64S tape file appmake generated");
          ^
src/appmake/c128.c:122:37: note: Assuming that condition '(fpout=fopen(tapfile,"wb"))==NULL' is not redundant
  if ( (fpout=fopen(tapfile,"wb") ) == NULL ) {
                                    ^
src/appmake/c128.c:127:11: note: Null pointer dereference
  fprintf(fpout,"C64S tape file appmake generated");
          ^
src/appmake/c128.c:135:11: warning: Either the condition '(fpout=fopen(tapfile,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
  fprintf(fpout,"Z88DK COMPILED PROGRAM  ");
          ^
src/appmake/c128.c:122:37: note: Assuming that condition '(fpout=fopen(tapfile,"wb"))==NULL' is not redundant
  if ( (fpout=fopen(tapfile,"wb") ) == NULL ) {
                                    ^
src/appmake/c128.c:135:11: note: Null pointer dereference
  fprintf(fpout,"Z88DK COMPILED PROGRAM  ");
          ^
src/appmake/c128.c:180:12: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/c128.c:94:43: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
 if ( (fpin=fopen_bin(binname, crtfile) ) == NULL ) {
                                          ^
src/appmake/c128.c:180:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/c128.c:238:13: warning: Either the condition '(fpout=fopen(tapfile,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fprintf(fpout,"%05i",(int)pos);      /* Location for SYS */
            ^
src/appmake/c128.c:122:37: note: Assuming that condition '(fpout=fopen(tapfile,"wb"))==NULL' is not redundant
  if ( (fpout=fopen(tapfile,"wb") ) == NULL ) {
                                    ^
src/appmake/c128.c:238:13: note: Null pointer dereference
    fprintf(fpout,"%05i",(int)pos);      /* Location for SYS */
            ^
src/appmake/c128.c:246:12: warning: Either the condition '(fpout=fopen(tapfile,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/c128.c:122:37: note: Assuming that condition '(fpout=fopen(tapfile,"wb"))==NULL' is not redundant
  if ( (fpout=fopen(tapfile,"wb") ) == NULL ) {
                                    ^
src/appmake/c128.c:246:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/c128.c:47:13: style: The scope of the variable 'tapfile' can be reduced. [variableScope]
    char    tapfile[FILENAME_MAX+1];
            ^
src/appmake/c128.c:52:13: style: The scope of the variable 'c' can be reduced. [variableScope]
    int     c,i;
            ^
src/appmake/c7420.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/c7420.c:84:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/c7420.c:75:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/c7420.c:84:15: note: Null pointer dereference
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/c7420.c:36:10: style: The scope of the variable 'mybuf' can be reduced. [variableScope]
    char mybuf[20];
         ^
src/appmake/c7420.c:37:10: style: The scope of the variable 'lsbbuf' can be reduced. [variableScope]
    char lsbbuf[5];
         ^
src/appmake/c7420.c:38:10: style: The scope of the variable 'msbbuf' can be reduced. [variableScope]
    char msbbuf[5];
         ^
src/appmake/c7420.c:41:9: style: The scope of the variable 'c' can be reduced. [variableScope]
    int c;
        ^
src/appmake/cpc.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/cpc.c:352:9: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
        printf("Need %d blocks.\n", blocks);
        ^
src/appmake/cpc.c:374:13: warning: %d in format string (no. 2) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
            printf("Processing file %s block %d ", header, currentblock);
            ^
src/appmake/cpc.c:662:9: warning: %ld in format string (no. 1) requires 'long' but the argument type is 'unsigned long'. [invalidPrintfArgType_sint]
        printf("Wav file size : %ld\n", wavSize);
        ^
src/appmake/cpc.c:486:9: error: Resource handle 'fpin' freed twice. [doubleFree]
        fclose(fpin);
        ^
src/appmake/cpc.c:476:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/cpc.c:486:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/cpc.c:489:5: error: Resource handle 'fpin' freed twice. [doubleFree]
    fclose(fpin);
    ^
src/appmake/cpc.c:476:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/cpc.c:489:5: note: Resource handle 'fpin' freed twice.
    fclose(fpin);
    ^
src/appmake/cpc.c:519:5: error: Resource handle 'fpout' freed twice. [doubleFree]
    fclose(fpout);
    ^
src/appmake/cpc.c:515:9: note: Resource handle 'fpout' freed twice.
        fclose(fpout);
        ^
src/appmake/cpc.c:519:5: note: Resource handle 'fpout' freed twice.
    fclose(fpout);
    ^
src/appmake/cpc.c:777:9: error: Memory pointed to by 'outFileBuff' is freed twice. [doubleFree]
        free(outFileBuff);
        ^
src/appmake/cpc.c:772:13: note: Memory pointed to by 'outFileBuff' is freed twice.
            free(outFileBuff);
            ^
src/appmake/cpc.c:777:9: note: Memory pointed to by 'outFileBuff' is freed twice.
        free(outFileBuff);
        ^
src/appmake/cpc.c:151:30: warning: Either the condition '(fpWav=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: f. [nullPointerRedundantCheck]
    fwrite(WavHeader, 1, 44, f);
                             ^
src/appmake/cpc.c:650:45: note: Assuming that condition '(fpWav=fopen(filename,"wb"))==NULL' is not redundant
        if ((fpWav = fopen(filename, "wb")) == NULL)
                                            ^
src/appmake/cpc.c:655:22: note: Calling function 'putWavHeader', 1st argument 'fpWav' value is 0
        putWavHeader(fpWav, &wavSize);
                     ^
src/appmake/cpc.c:151:30: note: Null pointer dereference
    fwrite(WavHeader, 1, 44, f);
                             ^
src/appmake/cpc.c:165:11: warning: Either the condition '(fpWav=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: f. [nullPointerRedundantCheck]
    fseek(f, 40, SEEK_SET);
          ^
src/appmake/cpc.c:650:45: note: Assuming that condition '(fpWav=fopen(filename,"wb"))==NULL' is not redundant
        if ((fpWav = fopen(filename, "wb")) == NULL)
                                            ^
src/appmake/cpc.c:659:19: note: Calling function 'writesize', 1st argument 'fpWav' value is 0
        writesize(fpWav, wavSize);
                  ^
src/appmake/cpc.c:165:11: note: Null pointer dereference
    fseek(f, 40, SEEK_SET);
          ^
src/appmake/cpc.c:171:11: warning: Either the condition '(fpWav=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: f. [nullPointerRedundantCheck]
    fseek(f, 4, SEEK_SET);
          ^
src/appmake/cpc.c:650:45: note: Assuming that condition '(fpWav=fopen(filename,"wb"))==NULL' is not redundant
        if ((fpWav = fopen(filename, "wb")) == NULL)
                                            ^
src/appmake/cpc.c:659:19: note: Calling function 'writesize', 1st argument 'fpWav' value is 0
        writesize(fpWav, wavSize);
                  ^
src/appmake/cpc.c:171:11: note: Null pointer dereference
    fseek(f, 4, SEEK_SET);
          ^
src/appmake/cpc.c:330:38: warning: Either the condition '(fpBin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpBin. [nullPointerRedundantCheck]
    if (1 != fread(srchead, 0x80, 1, fpBin))
                                     ^
src/appmake/cpc.c:325:41: note: Assuming that condition '(fpBin=fopen(filename,"rb"))==NULL' is not redundant
    if ((fpBin = fopen(filename, "rb")) == NULL)
                                        ^
src/appmake/cpc.c:330:38: note: Null pointer dereference
    if (1 != fread(srchead, 0x80, 1, fpBin))
                                     ^
src/appmake/cpc.c:448:12: warning: Either the condition '(fpBin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpBin. [nullPointerRedundantCheck]
    fclose(fpBin);
           ^
src/appmake/cpc.c:325:41: note: Assuming that condition '(fpBin=fopen(filename,"rb"))==NULL' is not redundant
    if ((fpBin = fopen(filename, "rb")) == NULL)
                                        ^
src/appmake/cpc.c:448:12: note: Null pointer dereference
    fclose(fpBin);
           ^
src/appmake/cpc.c:474:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin, 0, SEEK_END))
              ^
src/appmake/cpc.c:467:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL)
                                             ^
src/appmake/cpc.c:474:15: note: Null pointer dereference
    if (fseek(fpin, 0, SEEK_END))
              ^
src/appmake/cpc.c:480:27: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    binary_length = ftell(fpin);
                          ^
src/appmake/cpc.c:467:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL)
                                             ^
src/appmake/cpc.c:480:27: note: Null pointer dereference
    binary_length = ftell(fpin);
                          ^
src/appmake/cpc.c:481:11: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/cpc.c:467:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL)
                                             ^
src/appmake/cpc.c:481:11: note: Null pointer dereference
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/cpc.c:484:62: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (binary_length != fread(inFileBuff, 1, binary_length, fpin))
                                                             ^
src/appmake/cpc.c:467:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL)
                                             ^
src/appmake/cpc.c:484:62: note: Null pointer dereference
    if (binary_length != fread(inFileBuff, 1, binary_length, fpin))
                                                             ^
src/appmake/cpc.c:489:12: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/cpc.c:467:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL)
                                             ^
src/appmake/cpc.c:489:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/cpc.c:513:43: warning: Either the condition '(fpout=fopen(cpm_filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    if ((fwrite(outFileBuff, 1, file_len, fpout)) != file_len)
                                          ^
src/appmake/cpc.c:508:45: note: Assuming that condition '(fpout=fopen(cpm_filename,"wb"))==NULL' is not redundant
    if ((fpout = fopen(cpm_filename, "wb")) == NULL)
                                            ^
src/appmake/cpc.c:513:43: note: Null pointer dereference
    if ((fwrite(outFileBuff, 1, file_len, fpout)) != file_len)
                                          ^
src/appmake/cpc.c:519:12: warning: Either the condition '(fpout=fopen(cpm_filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/cpc.c:508:45: note: Assuming that condition '(fpout=fopen(cpm_filename,"wb"))==NULL' is not redundant
    if ((fpout = fopen(cpm_filename, "wb")) == NULL)
                                            ^
src/appmake/cpc.c:519:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/cpc.c:660:16: warning: Either the condition '(fpWav=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpWav. [nullPointerRedundantCheck]
        fclose(fpWav);
               ^
src/appmake/cpc.c:650:45: note: Assuming that condition '(fpWav=fopen(filename,"wb"))==NULL' is not redundant
        if ((fpWav = fopen(filename, "wb")) == NULL)
                                            ^
src/appmake/cpc.c:660:16: note: Null pointer dereference
        fclose(fpWav);
               ^
src/appmake/cpc.c:892:16: warning: Either the condition '(fpWav=fopen(wavfile,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpWav. [nullPointerRedundantCheck]
        fclose(fpWav);
               ^
src/appmake/cpc.c:839:44: note: Assuming that condition '(fpWav=fopen(wavfile,"wb"))==NULL' is not redundant
        if ((fpWav = fopen(wavfile, "wb")) == NULL)
                                           ^
src/appmake/cpc.c:892:16: note: Null pointer dereference
        fclose(fpWav);
               ^
src/appmake/cpc.c:229:16: style: The scope of the variable 'j' can be reduced. [variableScope]
    int i = 0, j = 0;
               ^
src/appmake/cpc.c:274:9: style: The scope of the variable 'bank' can be reduced. [variableScope]
    int bank, section;
        ^
src/appmake/cpc.c:274:15: style: The scope of the variable 'section' can be reduced. [variableScope]
    int bank, section;
              ^
src/appmake/cpc.c:317:9: style: The scope of the variable 'nchunks' can be reduced. [variableScope]
    int nchunks;
        ^
src/appmake/cpm2.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/cpm2.c:914:5: error: Common realloc mistake: 'c_additional_files' nulled but not freed upon failure [memleakOnRealloc]
    c_additional_files = realloc(c_additional_files, sizeof(c_additional_files[0]) * c_additional_files_num);
    ^
src/appmake/cpm2.c:969:19: warning: Either the condition '(binary_fp=fopen(c_additional_files[i],"rb"))==NULL' is redundant or there is possible null pointer dereference: binary_fp. [nullPointerRedundantCheck]
        if (fseek(binary_fp, 0, SEEK_END)) {
                  ^
src/appmake/cpm2.c:966:62: note: Assuming that condition '(binary_fp=fopen(c_additional_files[i],"rb"))==NULL' is not redundant
        if ((binary_fp = fopen(c_additional_files[i], "rb")) == NULL) {
                                                             ^
src/appmake/cpm2.c:969:19: note: Null pointer dereference
        if (fseek(binary_fp, 0, SEEK_END)) {
                  ^
src/appmake/cpm2.c:973:24: warning: Either the condition '(binary_fp=fopen(c_additional_files[i],"rb"))==NULL' is redundant or there is possible null pointer dereference: binary_fp. [nullPointerRedundantCheck]
        binlen = ftell(binary_fp);
                       ^
src/appmake/cpm2.c:966:62: note: Assuming that condition '(binary_fp=fopen(c_additional_files[i],"rb"))==NULL' is not redundant
        if ((binary_fp = fopen(c_additional_files[i], "rb")) == NULL) {
                                                             ^
src/appmake/cpm2.c:973:24: note: Null pointer dereference
        binlen = ftell(binary_fp);
                       ^
src/appmake/cpm2.c:974:15: warning: Either the condition '(binary_fp=fopen(c_additional_files[i],"rb"))==NULL' is redundant or there is possible null pointer dereference: binary_fp. [nullPointerRedundantCheck]
        fseek(binary_fp, 0L, SEEK_SET);
              ^
src/appmake/cpm2.c:966:62: note: Assuming that condition '(binary_fp=fopen(c_additional_files[i],"rb"))==NULL' is not redundant
        if ((binary_fp = fopen(c_additional_files[i], "rb")) == NULL) {
                                                             ^
src/appmake/cpm2.c:974:15: note: Null pointer dereference
        fseek(binary_fp, 0L, SEEK_SET);
              ^
src/appmake/cpm2.c:976:44: warning: Either the condition '(binary_fp=fopen(c_additional_files[i],"rb"))==NULL' is redundant or there is possible null pointer dereference: binary_fp. [nullPointerRedundantCheck]
        if (1 != fread(filebuf, binlen, 1, binary_fp))  { fclose(binary_fp); exit_log(1, "Could not read required data from <%s>\n",c_additional_files[i]); }
                                           ^
src/appmake/cpm2.c:966:62: note: Assuming that condition '(binary_fp=fopen(c_additional_files[i],"rb"))==NULL' is not redundant
        if ((binary_fp = fopen(c_additional_files[i], "rb")) == NULL) {
                                                             ^
src/appmake/cpm2.c:976:44: note: Null pointer dereference
        if (1 != fread(filebuf, binlen, 1, binary_fp))  { fclose(binary_fp); exit_log(1, "Could not read required data from <%s>\n",c_additional_files[i]); }
                                           ^
src/appmake/cpm2.c:977:16: warning: Either the condition '(binary_fp=fopen(c_additional_files[i],"rb"))==NULL' is redundant or there is possible null pointer dereference: binary_fp. [nullPointerRedundantCheck]
        fclose(binary_fp);
               ^
src/appmake/cpm2.c:966:62: note: Assuming that condition '(binary_fp=fopen(c_additional_files[i],"rb"))==NULL' is not redundant
        if ((binary_fp = fopen(c_additional_files[i], "rb")) == NULL) {
                                                             ^
src/appmake/cpm2.c:977:16: note: Null pointer dereference
        fclose(binary_fp);
               ^
src/appmake/cpm2.c:1027:15: warning: Either the condition '(binary_fp=fopen_bin(binary_name,crt_filename))==NULL' is redundant or there is possible null pointer dereference: binary_fp. [nullPointerRedundantCheck]
    if (fseek(binary_fp, 0, SEEK_END)) {
              ^
src/appmake/cpm2.c:1024:60: note: Assuming that condition '(binary_fp=fopen_bin(binary_name,crt_filename))==NULL' is not redundant
    if ((binary_fp = fopen_bin(binary_name, crt_filename)) == NULL) {
                                                           ^
src/appmake/cpm2.c:1027:15: note: Null pointer dereference
    if (fseek(binary_fp, 0, SEEK_END)) {
              ^
src/appmake/cpm2.c:1031:20: warning: Either the condition '(binary_fp=fopen_bin(binary_name,crt_filename))==NULL' is redundant or there is possible null pointer dereference: binary_fp. [nullPointerRedundantCheck]
    binlen = ftell(binary_fp);
                   ^
src/appmake/cpm2.c:1024:60: note: Assuming that condition '(binary_fp=fopen_bin(binary_name,crt_filename))==NULL' is not redundant
    if ((binary_fp = fopen_bin(binary_name, crt_filename)) == NULL) {
                                                           ^
src/appmake/cpm2.c:1031:20: note: Null pointer dereference
    binlen = ftell(binary_fp);
                   ^
src/appmake/cpm2.c:1032:11: warning: Either the condition '(binary_fp=fopen_bin(binary_name,crt_filename))==NULL' is redundant or there is possible null pointer dereference: binary_fp. [nullPointerRedundantCheck]
    fseek(binary_fp, 0L, SEEK_SET);
          ^
src/appmake/cpm2.c:1024:60: note: Assuming that condition '(binary_fp=fopen_bin(binary_name,crt_filename))==NULL' is not redundant
    if ((binary_fp = fopen_bin(binary_name, crt_filename)) == NULL) {
                                                           ^
src/appmake/cpm2.c:1032:11: note: Null pointer dereference
    fseek(binary_fp, 0L, SEEK_SET);
          ^
src/appmake/cpm2.c:1034:40: warning: Either the condition '(binary_fp=fopen_bin(binary_name,crt_filename))==NULL' is redundant or there is possible null pointer dereference: binary_fp. [nullPointerRedundantCheck]
    if (1 != fread(filebuf, binlen, 1, binary_fp))  { fclose(binary_fp); exit_log(1, "Could not read required data from <%s>\n",binary_name); }
                                       ^
src/appmake/cpm2.c:1024:60: note: Assuming that condition '(binary_fp=fopen_bin(binary_name,crt_filename))==NULL' is not redundant
    if ((binary_fp = fopen_bin(binary_name, crt_filename)) == NULL) {
                                                           ^
src/appmake/cpm2.c:1034:40: note: Null pointer dereference
    if (1 != fread(filebuf, binlen, 1, binary_fp))  { fclose(binary_fp); exit_log(1, "Could not read required data from <%s>\n",binary_name); }
                                       ^
src/appmake/cpm2.c:1035:12: warning: Either the condition '(binary_fp=fopen_bin(binary_name,crt_filename))==NULL' is redundant or there is possible null pointer dereference: binary_fp. [nullPointerRedundantCheck]
    fclose(binary_fp);
           ^
src/appmake/cpm2.c:1024:60: note: Assuming that condition '(binary_fp=fopen_bin(binary_name,crt_filename))==NULL' is not redundant
    if ((binary_fp = fopen_bin(binary_name, crt_filename)) == NULL) {
                                                           ^
src/appmake/cpm2.c:1035:12: note: Null pointer dereference
    fclose(binary_fp);
           ^
src/appmake/cpm2.c:1091:16: warning: Either the condition '(fpout=fopen(disc_name,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fclose(fpout);
               ^
src/appmake/cpm2.c:1084:46: note: Assuming that condition '(fpout=fopen(disc_name,"wb"))==NULL' is not redundant
        if ((fpout = fopen(disc_name, "wb")) == NULL) {
                                             ^
src/appmake/cpm2.c:1091:16: note: Null pointer dereference
        fclose(fpout);
               ^
src/appmake/cpm2.c:960:13: style: The scope of the variable 'filebuf' can be reduced. [variableScope]
    void   *filebuf;
            ^
src/appmake/cpm2.c:961:13: style: The scope of the variable 'binary_fp' can be reduced. [variableScope]
    FILE   *binary_fp;
            ^
src/appmake/cpm2.c:962:13: style: The scope of the variable 'binlen' can be reduced. [variableScope]
    size_t  binlen;
            ^
src/appmake/cpm2.c:1039:16: style: The scope of the variable 'bootlen' can be reduced. [variableScope]
        size_t bootlen;
               ^
src/appmake/cpm2.c:893:30: style:inconclusive: Function 'c_add_file' argument 1 names different: declaration 'option' definition 'param'. [funcArgNamesDifferent]
static void c_add_file(char *param)
                             ^
src/appmake/cpm2.c:26:30: note: Function 'c_add_file' argument 1 names different: declaration 'option' definition 'param'.
static void c_add_file(char *option);
                             ^
src/appmake/cpm2.c:893:30: note: Function 'c_add_file' argument 1 names different: declaration 'option' definition 'param'.
static void c_add_file(char *param)
                             ^
src/appmake/cpm2.c:1107:38: style:inconclusive: Function 'cpm_create_filename' argument 1 names different: declaration 'binary_name' definition 'binary'. [funcArgNamesDifferent]
void cpm_create_filename(const char* binary, char* cpm_filename, char force_com_extension, char include_dot)
                                     ^
src/appmake/cpmdisk.h:48:45: note: Function 'cpm_create_filename' argument 1 names different: declaration 'binary_name' definition 'binary'.
extern void cpm_create_filename(const char *binary_name, char *cpm_filename, char force_com_extension, char include_dot);
                                            ^
src/appmake/cpm2.c:1107:38: note: Function 'cpm_create_filename' argument 1 names different: declaration 'binary_name' definition 'binary'.
void cpm_create_filename(const char* binary, char* cpm_filename, char force_com_extension, char include_dot)
                                     ^
src/appmake/cpmdisk.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/cpmdisk.c:413:27: style: Local variable 'ptr' shadows outer variable [shadowVariable]
                 uint8_t *ptr = header;
                          ^
src/appmake/cpmdisk.c:355:14: note: Shadowed declaration
    uint8_t *ptr;
             ^
src/appmake/cpmdisk.c:413:27: note: Shadow variable
                 uint8_t *ptr = header;
                          ^
src/appmake/dai.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/dai.c:201:12: warning: Either the condition '(fpwav=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpwav. [nullPointerRedundantCheck]
    fclose(fpwav);
           ^
src/appmake/dai.c:131:43: note: Assuming that condition '(fpwav=fopen(filename,"wb"))==NULL' is not redundant
    if ( ( fpwav = fopen(filename, "wb")) == NULL ) {
                                          ^
src/appmake/dai.c:201:12: note: Null pointer dereference
    fclose(fpwav);
           ^
src/appmake/dai.c:203:12: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/dai.c:126:43: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ( ( fpout = fopen(filename, "wb")) == NULL ) {
                                          ^
src/appmake/dai.c:203:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/dai.c:221:16: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
   fputc(byte, fp);
               ^
src/appmake/dai.c:126:43: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ( ( fpout = fopen(filename, "wb")) == NULL ) {
                                          ^
src/appmake/dai.c:161:25: note: Calling function 'writebyte_dai', 2nd argument 'fpout' value is 0
    writebyte_dai(0x31, fpout,fpwav,&cksum);  // File type
                        ^
src/appmake/dai.c:221:16: note: Null pointer dereference
   fputc(byte, fp);
               ^
src/appmake/dai.c:163:10: style: Variable 'size' is reassigned a value before the old one has been used. [redundantAssignment]
    size = strlen(blockname);
         ^
src/appmake/dai.c:160:10: note: size is assigned
    size = binname_sb.st_size;
         ^
src/appmake/dai.c:163:10: note: size is overwritten
    size = strlen(blockname);
         ^
src/appmake/dai.c:91:15: style: The scope of the variable 'c' can be reduced. [variableScope]
    int     i,c;
              ^
src/appmake/dai.c:216:57: style:inconclusive: Function 'writebyte_dai' argument 3 names different: declaration 'wavfile' definition 'fpwav'. [funcArgNamesDifferent]
static void writebyte_dai(uint8_t byte, FILE *fp, FILE *fpwav, uint8_t *cksump)
                                                        ^
src/appmake/dai.c:16:57: note: Function 'writebyte_dai' argument 3 names different: declaration 'wavfile' definition 'fpwav'.
static void writebyte_dai(uint8_t byte, FILE *fp, FILE *wavfile, uint8_t *cksump);
                                                        ^
src/appmake/dai.c:216:57: note: Function 'writebyte_dai' argument 3 names different: declaration 'wavfile' definition 'fpwav'.
static void writebyte_dai(uint8_t byte, FILE *fp, FILE *fpwav, uint8_t *cksump)
                                                        ^
src/appmake/enterprise.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/enterprise.c:74:9: error: Resource handle 'fpin' freed twice. [doubleFree]
        fclose(fpin);
        ^
src/appmake/enterprise.c:65:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/enterprise.c:74:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/enterprise.c:64:15: warning: Either the condition '(fpin=fopen_bin(binname,NULL))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin,0,SEEK_END)) {
              ^
src/appmake/enterprise.c:58:40: note: Assuming that condition '(fpin=fopen_bin(binname,NULL))==NULL' is not redundant
 if ( (fpin=fopen_bin(binname, NULL) ) == NULL ) {
                                       ^
src/appmake/enterprise.c:64:15: note: Null pointer dereference
    if (fseek(fpin,0,SEEK_END)) {
              ^
src/appmake/enterprise.c:69:15: warning: Either the condition '(fpin=fopen_bin(binname,NULL))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    len=ftell(fpin);
              ^
src/appmake/enterprise.c:58:40: note: Assuming that condition '(fpin=fopen_bin(binname,NULL))==NULL' is not redundant
 if ( (fpin=fopen_bin(binname, NULL) ) == NULL ) {
                                       ^
src/appmake/enterprise.c:69:15: note: Null pointer dereference
    len=ftell(fpin);
              ^
src/appmake/enterprise.c:71:11: warning: Either the condition '(fpin=fopen_bin(binname,NULL))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin,0L,SEEK_SET);
          ^
src/appmake/enterprise.c:58:40: note: Assuming that condition '(fpin=fopen_bin(binname,NULL))==NULL' is not redundant
 if ( (fpin=fopen_bin(binname, NULL) ) == NULL ) {
                                       ^
src/appmake/enterprise.c:71:11: note: Null pointer dereference
    fseek(fpin,0L,SEEK_SET);
          ^
src/appmake/enterprise.c:90:12: warning: Either the condition '(fpin=fopen_bin(binname,NULL))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/enterprise.c:58:40: note: Assuming that condition '(fpin=fopen_bin(binname,NULL))==NULL' is not redundant
 if ( (fpin=fopen_bin(binname, NULL) ) == NULL ) {
                                       ^
src/appmake/enterprise.c:90:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/enterprise.c:91:12: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/enterprise.c:73:40: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                       ^
src/appmake/enterprise.c:91:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/enterprise.c:42:13: style: The scope of the variable 'c' can be reduced. [variableScope]
    int     c,i;
            ^
src/appmake/extract.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/extract.c:62:9: error: Resource handle 'fpin' freed twice. [doubleFree]
        fclose(fpin);
        ^
src/appmake/extract.c:55:13: note: Resource handle 'fpin' freed twice.
            fclose(fpin);
            ^
src/appmake/extract.c:62:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/extract.c:60:15: warning: Either the condition '(fpin=fopen_bin(binname,NULL))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin, offset, SEEK_SET))
              ^
src/appmake/extract.c:44:47: note: Assuming that condition '(fpin=fopen_bin(binname,NULL))==NULL' is not redundant
        if ( (fpin=fopen_bin(binname, NULL) ) == NULL ) {
                                              ^
src/appmake/extract.c:60:15: note: Null pointer dereference
    if (fseek(fpin, offset, SEEK_SET))
              ^
src/appmake/fat.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/fat.c:125:5: error: Common realloc mistake: 'c_additional_files' nulled but not freed upon failure [memleakOnRealloc]
    c_additional_files = realloc(c_additional_files, sizeof(c_additional_files[0]) * c_additional_files_num);
    ^
src/appmake/fat.c:243:17: error: Common realloc mistake: 'filebuf' nulled but not freed upon failure [memleakOnRealloc]
                filebuf = realloc(filebuf, mb->secbin->size);
                ^
src/appmake/fat.c:188:15: warning: Either the condition '(binary_fp=fopen_bin(binary_name,crt_filename))==NULL' is redundant or there is possible null pointer dereference: binary_fp. [nullPointerRedundantCheck]
    if (fseek(binary_fp, 0, SEEK_END)) {
              ^
src/appmake/fat.c:185:60: note: Assuming that condition '(binary_fp=fopen_bin(binary_name,crt_filename))==NULL' is not redundant
    if ((binary_fp = fopen_bin(binary_name, crt_filename)) == NULL) {
                                                           ^
src/appmake/fat.c:188:15: note: Null pointer dereference
    if (fseek(binary_fp, 0, SEEK_END)) {
              ^
src/appmake/fat.c:192:20: warning: Either the condition '(binary_fp=fopen_bin(binary_name,crt_filename))==NULL' is redundant or there is possible null pointer dereference: binary_fp. [nullPointerRedundantCheck]
    binlen = ftell(binary_fp);
                   ^
src/appmake/fat.c:185:60: note: Assuming that condition '(binary_fp=fopen_bin(binary_name,crt_filename))==NULL' is not redundant
    if ((binary_fp = fopen_bin(binary_name, crt_filename)) == NULL) {
                                                           ^
src/appmake/fat.c:192:20: note: Null pointer dereference
    binlen = ftell(binary_fp);
                   ^
src/appmake/fat.c:193:11: warning: Either the condition '(binary_fp=fopen_bin(binary_name,crt_filename))==NULL' is redundant or there is possible null pointer dereference: binary_fp. [nullPointerRedundantCheck]
    fseek(binary_fp, 0L, SEEK_SET);
          ^
src/appmake/fat.c:185:60: note: Assuming that condition '(binary_fp=fopen_bin(binary_name,crt_filename))==NULL' is not redundant
    if ((binary_fp = fopen_bin(binary_name, crt_filename)) == NULL) {
                                                           ^
src/appmake/fat.c:193:11: note: Null pointer dereference
    fseek(binary_fp, 0L, SEEK_SET);
          ^
src/appmake/fat.c:195:40: warning: Either the condition '(binary_fp=fopen_bin(binary_name,crt_filename))==NULL' is redundant or there is possible null pointer dereference: binary_fp. [nullPointerRedundantCheck]
    if (1 != fread(filebuf, binlen, 1, binary_fp)) { fclose(binary_fp); exit_log(1, "Could not read required data from <%s>\n",binary_name); }
                                       ^
src/appmake/fat.c:185:60: note: Assuming that condition '(binary_fp=fopen_bin(binary_name,crt_filename))==NULL' is not redundant
    if ((binary_fp = fopen_bin(binary_name, crt_filename)) == NULL) {
                                                           ^
src/appmake/fat.c:195:40: note: Null pointer dereference
    if (1 != fread(filebuf, binlen, 1, binary_fp)) { fclose(binary_fp); exit_log(1, "Could not read required data from <%s>\n",binary_name); }
                                       ^
src/appmake/fat.c:196:12: warning: Either the condition '(binary_fp=fopen_bin(binary_name,crt_filename))==NULL' is redundant or there is possible null pointer dereference: binary_fp. [nullPointerRedundantCheck]
    fclose(binary_fp);
           ^
src/appmake/fat.c:185:60: note: Assuming that condition '(binary_fp=fopen_bin(binary_name,crt_filename))==NULL' is not redundant
    if ((binary_fp = fopen_bin(binary_name, crt_filename)) == NULL) {
                                                           ^
src/appmake/fat.c:196:12: note: Null pointer dereference
    fclose(binary_fp);
           ^
src/appmake/fat.c:244:62: warning: Either the condition '(binary_fp=fopen(mb->secbin->filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: binary_fp. [nullPointerRedundantCheck]
                if (1 != fread(filebuf, mb->secbin->size, 1, binary_fp)) {
                                                             ^
src/appmake/fat.c:240:69: note: Assuming that condition '(binary_fp=fopen(mb->secbin->filename,"rb"))==NULL' is not redundant
                if ((binary_fp = fopen(mb->secbin->filename, "rb")) == NULL) {
                                                                    ^
src/appmake/fat.c:244:62: note: Null pointer dereference
                if (1 != fread(filebuf, mb->secbin->size, 1, binary_fp)) {
                                                             ^
src/appmake/fat.c:248:24: warning: Either the condition '(binary_fp=fopen(mb->secbin->filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: binary_fp. [nullPointerRedundantCheck]
                fclose(binary_fp);
                       ^
src/appmake/fat.c:240:69: note: Assuming that condition '(binary_fp=fopen(mb->secbin->filename,"rb"))==NULL' is not redundant
                if ((binary_fp = fopen(mb->secbin->filename, "rb")) == NULL) {
                                                                    ^
src/appmake/fat.c:248:24: note: Null pointer dereference
                fclose(binary_fp);
                       ^
src/appmake/fat.c:306:19: warning: Either the condition '(binary_fp=fopen(c_additional_files[i],"rb"))==NULL' is redundant or there is possible null pointer dereference: binary_fp. [nullPointerRedundantCheck]
        if (fseek(binary_fp, 0, SEEK_END)) {
                  ^
src/appmake/fat.c:303:62: note: Assuming that condition '(binary_fp=fopen(c_additional_files[i],"rb"))==NULL' is not redundant
        if ((binary_fp = fopen(c_additional_files[i], "rb")) == NULL) {
                                                             ^
src/appmake/fat.c:306:19: note: Null pointer dereference
        if (fseek(binary_fp, 0, SEEK_END)) {
                  ^
src/appmake/fat.c:310:24: warning: Either the condition '(binary_fp=fopen(c_additional_files[i],"rb"))==NULL' is redundant or there is possible null pointer dereference: binary_fp. [nullPointerRedundantCheck]
        binlen = ftell(binary_fp);
                       ^
src/appmake/fat.c:303:62: note: Assuming that condition '(binary_fp=fopen(c_additional_files[i],"rb"))==NULL' is not redundant
        if ((binary_fp = fopen(c_additional_files[i], "rb")) == NULL) {
                                                             ^
src/appmake/fat.c:310:24: note: Null pointer dereference
        binlen = ftell(binary_fp);
                       ^
src/appmake/fat.c:311:15: warning: Either the condition '(binary_fp=fopen(c_additional_files[i],"rb"))==NULL' is redundant or there is possible null pointer dereference: binary_fp. [nullPointerRedundantCheck]
        fseek(binary_fp, 0L, SEEK_SET);
              ^
src/appmake/fat.c:303:62: note: Assuming that condition '(binary_fp=fopen(c_additional_files[i],"rb"))==NULL' is not redundant
        if ((binary_fp = fopen(c_additional_files[i], "rb")) == NULL) {
                                                             ^
src/appmake/fat.c:311:15: note: Null pointer dereference
        fseek(binary_fp, 0L, SEEK_SET);
              ^
src/appmake/fat.c:313:44: warning: Either the condition '(binary_fp=fopen(c_additional_files[i],"rb"))==NULL' is redundant or there is possible null pointer dereference: binary_fp. [nullPointerRedundantCheck]
        if (1 != fread(filebuf, binlen, 1, binary_fp))  { fclose(binary_fp); exit_log(1, "Could not read required data from <%s>\n",c_additional_files[i]); }
                                           ^
src/appmake/fat.c:303:62: note: Assuming that condition '(binary_fp=fopen(c_additional_files[i],"rb"))==NULL' is not redundant
        if ((binary_fp = fopen(c_additional_files[i], "rb")) == NULL) {
                                                             ^
src/appmake/fat.c:313:44: note: Null pointer dereference
        if (1 != fread(filebuf, binlen, 1, binary_fp))  { fclose(binary_fp); exit_log(1, "Could not read required data from <%s>\n",c_additional_files[i]); }
                                           ^
src/appmake/fat.c:314:16: warning: Either the condition '(binary_fp=fopen(c_additional_files[i],"rb"))==NULL' is redundant or there is possible null pointer dereference: binary_fp. [nullPointerRedundantCheck]
        fclose(binary_fp);
               ^
src/appmake/fat.c:303:62: note: Assuming that condition '(binary_fp=fopen(c_additional_files[i],"rb"))==NULL' is not redundant
        if ((binary_fp = fopen(c_additional_files[i], "rb")) == NULL) {
                                                             ^
src/appmake/fat.c:314:16: note: Null pointer dereference
        fclose(binary_fp);
               ^
src/appmake/fat.c:272:9: style: The scope of the variable 'bank' can be reduced. [variableScope]
    int bank, section;
        ^
src/appmake/fat.c:272:15: style: The scope of the variable 'section' can be reduced. [variableScope]
    int bank, section;
              ^
src/appmake/fat.c:297:13: style: The scope of the variable 'filebuf' can be reduced. [variableScope]
    void   *filebuf;
            ^
src/appmake/fat.c:298:13: style: The scope of the variable 'binary_fp' can be reduced. [variableScope]
    FILE   *binary_fp;
            ^
src/appmake/fat.c:299:13: style: The scope of the variable 'binlen' can be reduced. [variableScope]
    size_t  binlen;
            ^
src/appmake/fat.c:105:30: style:inconclusive: Function 'c_add_file' argument 1 names different: declaration 'option' definition 'param'. [funcArgNamesDifferent]
static void c_add_file(char *param)
                             ^
src/appmake/fat.c:18:30: note: Function 'c_add_file' argument 1 names different: declaration 'option' definition 'param'.
static void c_add_file(char *option);
                             ^
src/appmake/fat.c:105:30: note: Function 'c_add_file' argument 1 names different: declaration 'option' definition 'param'.
static void c_add_file(char *param)
                             ^
src/appmake/ff.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 73 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/ff.c:2976:14: warning: The address of local variable 'path' might be accessed at non-zero index. [objectIndex]
  c = (BYTE)p[si++];    /* Get a byte */
             ^
src/appmake/ff.c:3066:26: note: Address of variable taken here.
   res = create_name(dp, &path); /* Get a segment name of the path */
                         ^
src/appmake/ff.c:3066:26: note: Calling function 'create_name', 2nd argument '&path' value is lifetime=path
   res = create_name(dp, &path); /* Get a segment name of the path */
                         ^
src/appmake/ff.c:2976:14: note: The address of local variable 'path' might be accessed at non-zero index.
  c = (BYTE)p[si++];    /* Get a byte */
             ^
src/appmake/ff.c:3670:11: style: The if condition is the same as the previous if condition [duplicateCondition]
  if (res == FR_OK) {
          ^
src/appmake/ff.c:3649:11: note: First condition
  if (res == FR_OK) {
          ^
src/appmake/ff.c:3670:11: note: Second condition
  if (res == FR_OK) {
          ^
src/appmake/ff.c:3277:9: style: Condition 'i!=0' is always false [knownConditionTrueFalse]
  if (i != 0) i--;
        ^
src/appmake/ff.c:3276:7: note: Assignment 'i=0', assigned value is 0
  i = LD2PT(vol);     /* Partition number: 0:auto, 1-4:forced */
      ^
src/appmake/ff.c:3277:9: note: Condition 'i!=0' is always false
  if (i != 0) i--;
        ^
src/appmake/ff.c:4929:13: style: Condition 'res==FR_OK' is always true [knownConditionTrueFalse]
    if (res == FR_OK) {
            ^
src/appmake/ff.c:4911:12: note: Assuming that condition 'res==FR_OK' is not redundant
   if (res == FR_OK) {
           ^
src/appmake/ff.c:4929:13: note: Condition 'res==FR_OK' is always true
    if (res == FR_OK) {
            ^
src/appmake/ff.c:1688:8: style: The scope of the variable 'csz' can be reduced. [variableScope]
 DWORD csz, clst;
       ^
src/appmake/ff.c:733:9: style: Unsigned expression 'c' can't be negative so it is unnecessary to test it. [unsignedPositive]
  if (c >= DbcTbl[8] && c <= DbcTbl[9]) return 1;
        ^
src/appmake/ff.c:733:27: style: Checking if unsigned expression 'c' is less than zero. [unsignedLessThanZero]
  if (c >= DbcTbl[8] && c <= DbcTbl[9]) return 1;
                          ^
src/appmake/ff.c:5536:14: style:inconclusive: Function 'f_mkfs' argument 7 names different: declaration 'num_directory_entries' definition 'n_rootdir'. [funcArgNamesDifferent]
        UINT n_rootdir   /* Number of root directory entries */
             ^
src/appmake/ff.h:310:96: note: Function 'f_mkfs' argument 7 names different: declaration 'num_directory_entries' definition 'n_rootdir'.
FRESULT f_mkfs (const TCHAR* path, BYTE opt, DWORD au, void* work, UINT len, UINT n_fats, UINT num_directory_entries); /* Create a FAT volume */
                                                                                               ^
src/appmake/ff.c:5536:14: note: Function 'f_mkfs' argument 7 names different: declaration 'num_directory_entries' definition 'n_rootdir'.
        UINT n_rootdir   /* Number of root directory entries */
             ^
src/appmake/ff.c:1422:14: style: Variable 'res' is assigned a value that is never used. [unreadVariable]
 FRESULT res = FR_OK;
             ^
src/appmake/fp1100.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/fp1100.c:74:5: error: Resource handle 'bootstrap_fp' freed twice. [doubleFree]
    fclose(bootstrap_fp);
    ^
src/appmake/fp1100.c:61:9: note: Resource handle 'bootstrap_fp' freed twice.
        fclose(bootstrap_fp);
        ^
src/appmake/fp1100.c:74:5: note: Resource handle 'bootstrap_fp' freed twice.
    fclose(bootstrap_fp);
    ^
src/appmake/fp1100.c:90:44: error: Resource handle 'fpin' freed twice. [doubleFree]
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                           ^
src/appmake/fp1100.c:83:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/fp1100.c:90:44: note: Resource handle 'fpin' freed twice.
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                           ^
src/appmake/fp1100.c:91:5: error: Resource handle 'fpin' freed twice. [doubleFree]
    fclose(fpin);
    ^
src/appmake/fp1100.c:83:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/fp1100.c:91:5: note: Resource handle 'fpin' freed twice.
    fclose(fpin);
    ^
src/appmake/fp1100.c:60:16: warning: Either the condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: bootstrap_fp. [nullPointerRedundantCheck]
    if ( fseek(bootstrap_fp,0,SEEK_END) ) {
               ^
src/appmake/fp1100.c:57:55: note: Assuming that condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (bootstrap_fp=fopen_bin(bootname, crtfile) ) == NULL ) {
                                                      ^
src/appmake/fp1100.c:60:16: note: Null pointer dereference
    if ( fseek(bootstrap_fp,0,SEEK_END) ) {
               ^
src/appmake/fp1100.c:64:21: warning: Either the condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: bootstrap_fp. [nullPointerRedundantCheck]
    bootlen = ftell(bootstrap_fp);
                    ^
src/appmake/fp1100.c:57:55: note: Assuming that condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (bootstrap_fp=fopen_bin(bootname, crtfile) ) == NULL ) {
                                                      ^
src/appmake/fp1100.c:64:21: note: Null pointer dereference
    bootlen = ftell(bootstrap_fp);
                    ^
src/appmake/fp1100.c:65:11: warning: Either the condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: bootstrap_fp. [nullPointerRedundantCheck]
    fseek(bootstrap_fp,0L,SEEK_SET);
          ^
src/appmake/fp1100.c:57:55: note: Assuming that condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (bootstrap_fp=fopen_bin(bootname, crtfile) ) == NULL ) {
                                                      ^
src/appmake/fp1100.c:65:11: note: Null pointer dereference
    fseek(bootstrap_fp,0L,SEEK_SET);
          ^
src/appmake/fp1100.c:71:37: warning: Either the condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: bootstrap_fp. [nullPointerRedundantCheck]
    if ( fread(bootbuf, 1, bootlen, bootstrap_fp) != bootlen ) {
                                    ^
src/appmake/fp1100.c:57:55: note: Assuming that condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (bootstrap_fp=fopen_bin(bootname, crtfile) ) == NULL ) {
                                                      ^
src/appmake/fp1100.c:71:37: note: Null pointer dereference
    if ( fread(bootbuf, 1, bootlen, bootstrap_fp) != bootlen ) {
                                    ^
src/appmake/fp1100.c:74:12: warning: Either the condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: bootstrap_fp. [nullPointerRedundantCheck]
    fclose(bootstrap_fp);
           ^
src/appmake/fp1100.c:57:55: note: Assuming that condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (bootstrap_fp=fopen_bin(bootname, crtfile) ) == NULL ) {
                                                      ^
src/appmake/fp1100.c:74:12: note: Null pointer dereference
    fclose(bootstrap_fp);
           ^
src/appmake/fp1100.c:82:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/fp1100.c:78:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/fp1100.c:82:15: note: Null pointer dereference
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/fp1100.c:87:17: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    pos = ftell(fpin);
                ^
src/appmake/fp1100.c:78:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/fp1100.c:87:17: note: Null pointer dereference
    pos = ftell(fpin);
                ^
src/appmake/fp1100.c:88:11: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/fp1100.c:78:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/fp1100.c:88:11: note: Null pointer dereference
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/fp1100.c:90:35: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                  ^
src/appmake/fp1100.c:78:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/fp1100.c:90:35: note: Null pointer dereference
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                  ^
src/appmake/fp1100.c:91:12: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/fp1100.c:78:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/fp1100.c:91:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/galaksija.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/galaksija.c:188:19: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/galaksija.c:184:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/galaksija.c:188:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/galaksija.c:192:21: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin);
                    ^
src/appmake/galaksija.c:184:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/galaksija.c:192:21: note: Null pointer dereference
        len = ftell(fpin);
                    ^
src/appmake/galaksija.c:193:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/galaksija.c:184:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/galaksija.c:193:15: note: Null pointer dereference
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/galaksija.c:212:31: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fputc(GTP_BLOCK_NAME, fpout); /* Block ID: NAME    */
                              ^
src/appmake/galaksija.c:197:45: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
        if ((fpout = fopen(filename, "wb")) == NULL) {
                                            ^
src/appmake/galaksija.c:212:31: note: Null pointer dereference
        fputc(GTP_BLOCK_NAME, fpout); /* Block ID: NAME    */
                              ^
src/appmake/galaksija.c:214:18: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fputc(0, fpout);
                 ^
src/appmake/galaksija.c:197:45: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
        if ((fpout = fopen(filename, "wb")) == NULL) {
                                            ^
src/appmake/galaksija.c:214:18: note: Null pointer dereference
        fputc(0, fpout);
                 ^
src/appmake/galaksija.c:215:18: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fputc(0, fpout);
                 ^
src/appmake/galaksija.c:197:45: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
        if ((fpout = fopen(filename, "wb")) == NULL) {
                                            ^
src/appmake/galaksija.c:215:18: note: Null pointer dereference
        fputc(0, fpout);
                 ^
src/appmake/galaksija.c:222:35: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fputc(GTP_BLOCK_STANDARD, fpout); /* Block ID: STD SPEED DATA */
                                  ^
src/appmake/galaksija.c:197:45: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
        if ((fpout = fopen(filename, "wb")) == NULL) {
                                            ^
src/appmake/galaksija.c:222:35: note: Null pointer dereference
        fputc(GTP_BLOCK_STANDARD, fpout); /* Block ID: STD SPEED DATA */
                                  ^
src/appmake/galaksija.c:224:18: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fputc(0, fpout);
                 ^
src/appmake/galaksija.c:197:45: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
        if ((fpout = fopen(filename, "wb")) == NULL) {
                                            ^
src/appmake/galaksija.c:224:18: note: Null pointer dereference
        fputc(0, fpout);
                 ^
src/appmake/galaksija.c:225:18: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fputc(0, fpout);
                 ^
src/appmake/galaksija.c:197:45: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
        if ((fpout = fopen(filename, "wb")) == NULL) {
                                            ^
src/appmake/galaksija.c:225:18: note: Null pointer dereference
        fputc(0, fpout);
                 ^
src/appmake/galaksija.c:228:30: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        after_header = ftell(fpout);
                             ^
src/appmake/galaksija.c:197:45: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
        if ((fpout = fopen(filename, "wb")) == NULL) {
                                            ^
src/appmake/galaksija.c:228:30: note: Null pointer dereference
        after_header = ftell(fpout);
                             ^
src/appmake/galaksija.c:264:19: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/galaksija.c:260:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/galaksija.c:264:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/galaksija.c:268:21: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin) - after_header;
                    ^
src/appmake/galaksija.c:260:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/galaksija.c:268:21: note: Null pointer dereference
        len = ftell(fpin) - after_header;
                    ^
src/appmake/galaksija.c:269:15: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, after_header, SEEK_SET);
              ^
src/appmake/galaksija.c:260:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/galaksija.c:269:15: note: Null pointer dereference
        fseek(fpin, after_header, SEEK_SET);
              ^
src/appmake/galaksija.c:302:16: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fclose(fpin);
               ^
src/appmake/galaksija.c:260:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/galaksija.c:302:16: note: Null pointer dereference
        fclose(fpin);
               ^
src/appmake/galaksija.c:303:16: warning: Either the condition '(fpout=fopen(wavfile,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fclose(fpout);
               ^
src/appmake/galaksija.c:275:44: note: Assuming that condition '(fpout=fopen(wavfile,"wb"))==NULL' is not redundant
        if ((fpout = fopen(wavfile, "wb")) == NULL) {
                                           ^
src/appmake/galaksija.c:303:16: note: Null pointer dereference
        fclose(fpout);
               ^
src/appmake/gb.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/gb.c:101:9: error: Resource handle 'fpin' freed twice. [doubleFree]
        fclose(fpin);
        ^
src/appmake/gb.c:91:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/gb.c:101:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/gb.c:107:78: error: Resource handle 'fpin' freed twice. [doubleFree]
    if (main_length != fread(memory, sizeof(memory[0]), main_length, fpin)){ fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                                                             ^
src/appmake/gb.c:91:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/gb.c:107:78: note: Resource handle 'fpin' freed twice.
    if (main_length != fread(memory, sizeof(memory[0]), main_length, fpin)){ fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                                                             ^
src/appmake/gb.c:108:5: error: Resource handle 'fpin' freed twice. [doubleFree]
    fclose(fpin);
    ^
src/appmake/gb.c:91:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/gb.c:108:5: note: Resource handle 'fpin' freed twice.
    fclose(fpin);
    ^
src/appmake/gb.c:100:30: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if ((main_length = ftell(fpin)) > 0x8000) {
                             ^
src/appmake/gb.c:88:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL)
                                             ^
src/appmake/gb.c:100:30: note: Null pointer dereference
    if ((main_length = ftell(fpin)) > 0x8000) {
                             ^
src/appmake/gb.c:104:12: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    rewind(fpin);
           ^
src/appmake/gb.c:88:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL)
                                             ^
src/appmake/gb.c:104:12: note: Null pointer dereference
    rewind(fpin);
           ^
src/appmake/gb.c:107:70: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (main_length != fread(memory, sizeof(memory[0]), main_length, fpin)){ fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                                                     ^
src/appmake/gb.c:88:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL)
                                             ^
src/appmake/gb.c:107:70: note: Null pointer dereference
    if (main_length != fread(memory, sizeof(memory[0]), main_length, fpin)){ fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                                                     ^
src/appmake/gb.c:108:12: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/gb.c:88:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL)
                                             ^
src/appmake/gb.c:108:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/gb.c:323:25: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fwrite(memory,len,1,fpout);
                        ^
src/appmake/gb.c:310:41: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ((fpout = fopen(filename, "wb")) == NULL)
                                        ^
src/appmake/gb.c:323:25: note: Null pointer dereference
    fwrite(memory,len,1,fpout);
                        ^
src/appmake/gb.c:324:12: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/gb.c:310:41: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ((fpout = fopen(filename, "wb")) == NULL)
                                        ^
src/appmake/gb.c:324:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/glue.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/glue.c:104:12: warning: Either the condition '(fmap=fopen(filename,"r"))==NULL' is redundant or there is possible null pointer dereference: fmap. [nullPointerRedundantCheck]
    fclose(fmap);
           ^
src/appmake/glue.c:99:39: note: Assuming that condition '(fmap=fopen(filename,"r"))==NULL' is not redundant
    if ((fmap = fopen(filename, "r")) == NULL)
                                      ^
src/appmake/glue.c:104:12: note: Null pointer dereference
    fclose(fmap);
           ^
src/appmake/glue.c:158:17: style: The scope of the variable 'i' can be reduced. [variableScope]
            int i;
                ^
src/appmake/hex.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/hex.c:141:12: warning: Either the condition '(input=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: input. [nullPointerRedundantCheck]
    fclose(input);
           ^
src/appmake/hex.c:70:47: note: Assuming that condition '(input=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( (input=fopen_bin(binname, crtfile) ) == NULL ) {
                                              ^
src/appmake/hex.c:141:12: note: Null pointer dereference
    fclose(input);
           ^
src/appmake/hex.c:142:12: warning: Either the condition '(output=fopen(filename,"w"))==NULL' is redundant or there is possible null pointer dereference: output. [nullPointerRedundantCheck]
    fclose(output);
           ^
src/appmake/hex.c:74:42: note: Assuming that condition '(output=fopen(filename,"w"))==NULL' is not redundant
    if ( (output = fopen(filename,"w") ) == NULL ) {
                                         ^
src/appmake/hex.c:142:12: note: Null pointer dereference
    fclose(output);
           ^
src/appmake/homelab.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/homelab.c:102:12: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/homelab.c:79:43: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ( ( fpout = fopen(filename, "wb")) == NULL ) {
                                          ^
src/appmake/homelab.c:102:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/homelab.c:43:15: style: The scope of the variable 'c' can be reduced. [variableScope]
    int     i,c;
              ^
src/appmake/inject.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/inject.c:97:12: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/inject.c:75:43: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ( ( fpout = fopen(filename, "wb")) == NULL ) {
                                          ^
src/appmake/inject.c:97:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/kc.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/kc.c:94:9: error: Used file that is not opened. [useClosedFile]
        fclose(fpin);
        ^
src/appmake/kc.c:91:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/kc.c:87:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/kc.c:91:15: note: Null pointer dereference
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/kc.c:97:17: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    len = ftell(fpin);
                ^
src/appmake/kc.c:87:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/kc.c:97:17: note: Null pointer dereference
    len = ftell(fpin);
                ^
src/appmake/kc.c:99:11: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/kc.c:87:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/kc.c:99:11: note: Null pointer dereference
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/kc.c:148:12: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/kc.c:87:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/kc.c:148:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/kc.c:149:12: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/kc.c:101:41: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ((fpout = fopen(filename, "wb")) == NULL) {
                                        ^
src/appmake/kc.c:149:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/kc.c:46:9: style: The scope of the variable 'c' can be reduced. [variableScope]
    int c, i;
        ^
src/appmake/lviv.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/lviv.c:267:16: warning: Either the condition '(fpwav=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpwav. [nullPointerRedundantCheck]
        fclose(fpwav);
               ^
src/appmake/lviv.c:220:47: note: Assuming that condition '(fpwav=fopen(filename,"wb"))==NULL' is not redundant
        if ( ( fpwav = fopen(filename, "wb")) == NULL ) {
                                              ^
src/appmake/lviv.c:267:16: note: Null pointer dereference
        fclose(fpwav);
               ^
src/appmake/lviv.c:277:12: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/lviv.c:144:43: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ( ( fpout = fopen(filename, "wb")) == NULL ) {
                                          ^
src/appmake/lviv.c:277:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/lviv.c:110:13: style: The scope of the variable 'fpwav' can be reduced. [variableScope]
    FILE   *fpwav;
            ^
src/appmake/lynx.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/lynx.c:84:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/lynx.c:80:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/lynx.c:84:15: note: Null pointer dereference
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/lynx.c:89:17: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    len = ftell(fpin);
                ^
src/appmake/lynx.c:80:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/lynx.c:89:17: note: Null pointer dereference
    len = ftell(fpin);
                ^
src/appmake/lynx.c:91:11: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/lynx.c:80:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/lynx.c:91:11: note: Null pointer dereference
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/lynx.c:100:11: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/lynx.c:80:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/lynx.c:100:11: note: Null pointer dereference
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/lz49.c:56:8: style: The scope of the variable 'startscan' can be reduced. [variableScope]
 int i,startscan,current=1,token,ioutput=1,curscan;
       ^
src/appmake/lz49.c:56:28: style: The scope of the variable 'token' can be reduced. [variableScope]
 int i,startscan,current=1,token,ioutput=1,curscan;
                           ^
src/appmake/lz49.c:57:16: style: The scope of the variable 'maxlength' can be reduced. [variableScope]
 int maxoffset,maxlength,matchlength,literal=0,literaloffset=1;
               ^
src/appmake/lz49.c:117:6: style: The scope of the variable 'extendedoffset' can be reduced. [variableScope]
 int extendedoffset;
     ^
src/appmake/lz49.c:118:6: style: The scope of the variable 'literallength' can be reduced. [variableScope]
 int literallength,matchlength,HLmatch;
     ^
src/appmake/lz49.c:118:20: style: The scope of the variable 'matchlength' can be reduced. [variableScope]
 int literallength,matchlength,HLmatch;
                   ^
src/appmake/lz49.c:118:32: style: The scope of the variable 'HLmatch' can be reduced. [variableScope]
 int literallength,matchlength,HLmatch;
                               ^
src/appmake/lz49.c:167:6: style: The scope of the variable 'extendedoffset' can be reduced. [variableScope]
 int extendedoffset;
     ^
src/appmake/lz49.c:168:6: style: The scope of the variable 'literallength' can be reduced. [variableScope]
 int literallength,matchlength;
     ^
src/appmake/lz49.c:168:20: style: The scope of the variable 'matchlength' can be reduced. [variableScope]
 int literallength,matchlength;
                   ^
src/appmake/lz49.c:290:14: style: The scope of the variable 'i' can be reduced. [variableScope]
 int newsize,i,cr;
             ^
src/appmake/lz49.c:290:16: style: The scope of the variable 'cr' can be reduced. [variableScope]
 int newsize,i,cr;
               ^
src/appmake/m5.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/m5.c:132:9: error: Resource handle 'fpin' freed twice. [doubleFree]
        fclose(fpin);
        ^
src/appmake/m5.c:123:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/m5.c:132:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/m5.c:122:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/m5.c:114:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/m5.c:122:15: note: Null pointer dereference
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/m5.c:127:17: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    len = ftell(fpin);
                ^
src/appmake/m5.c:114:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/m5.c:127:17: note: Null pointer dereference
    len = ftell(fpin);
                ^
src/appmake/m5.c:129:11: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/m5.c:114:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/m5.c:129:11: note: Null pointer dereference
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/m5.c:193:12: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/m5.c:114:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/m5.c:193:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/m5.c:194:12: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/m5.c:131:41: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ((fpout = fopen(filename, "wb")) == NULL) {
                                        ^
src/appmake/m5.c:194:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/m5.c:204:19: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/m5.c:200:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/m5.c:204:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/m5.c:208:21: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin) - 16 - 32;
                    ^
src/appmake/m5.c:200:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/m5.c:208:21: note: Null pointer dereference
        len = ftell(fpin) - 16 - 32;
                    ^
src/appmake/m5.c:209:15: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 16L, SEEK_SET);
              ^
src/appmake/m5.c:200:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/m5.c:209:15: note: Null pointer dereference
        fseek(fpin, 16L, SEEK_SET);
              ^
src/appmake/m5.c:226:22: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        while (ftell(fpin) < len) {
                     ^
src/appmake/m5.c:200:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/m5.c:226:22: note: Null pointer dereference
        while (ftell(fpin) < len) {
                     ^
src/appmake/m5.c:261:16: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fclose(fpin);
               ^
src/appmake/m5.c:200:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/m5.c:261:16: note: Null pointer dereference
        fclose(fpin);
               ^
src/appmake/m5.c:262:16: warning: Either the condition '(fpout=fopen(wavfile,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fclose(fpout);
               ^
src/appmake/m5.c:213:44: note: Assuming that condition '(fpout=fopen(wavfile,"wb"))==NULL' is not redundant
        if ((fpout = fopen(wavfile, "wb")) == NULL) {
                                           ^
src/appmake/m5.c:262:16: note: Null pointer dereference
        fclose(fpout);
               ^
src/appmake/m5.c:81:10: style: The scope of the variable 'wavfile' can be reduced. [variableScope]
    char wavfile[FILENAME_MAX + 1];
         ^
src/appmake/m5.c:87:14: style: The scope of the variable 'blocklen' can be reduced. [variableScope]
    int len, blocklen;
             ^
src/appmake/mamepp.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/mamepp.c:94:12: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/mamepp.c:79:43: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ( ( fpout = fopen(filename, "wb")) == NULL ) {
                                          ^
src/appmake/mamepp.c:94:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/mamepp.c:43:15: style: The scope of the variable 'c' can be reduced. [variableScope]
    int     i,c;
              ^
src/appmake/mameql.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/mameql.c:110:12: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/mameql.c:79:43: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ( ( fpout = fopen(filename, "wb")) == NULL ) {
                                          ^
src/appmake/mameql.c:110:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/mameql.c:43:15: style: The scope of the variable 'c' can be reduced. [variableScope]
    int     i,c;
              ^
src/appmake/mc.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/mc.c:130:9: error: Resource handle 'fpin' freed twice. [doubleFree]
        fclose(fpin);
        ^
src/appmake/mc.c:122:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/mc.c:130:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/mc.c:121:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/mc.c:113:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/mc.c:121:15: note: Null pointer dereference
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/mc.c:126:17: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    len = ftell(fpin);
                ^
src/appmake/mc.c:113:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/mc.c:126:17: note: Null pointer dereference
    len = ftell(fpin);
                ^
src/appmake/mc.c:127:11: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin, 0, SEEK_SET);
          ^
src/appmake/mc.c:113:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/mc.c:127:11: note: Null pointer dereference
    fseek(fpin, 0, SEEK_SET);
          ^
src/appmake/mc.c:163:16: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fputc(255, fpout);
               ^
src/appmake/mc.c:129:41: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ((fpout = fopen(filename, "wb")) == NULL) {
                                        ^
src/appmake/mc.c:163:16: note: Null pointer dereference
    fputc(255, fpout);
               ^
src/appmake/mc.c:165:12: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/mc.c:113:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/mc.c:165:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/mc.c:166:12: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/mc.c:129:41: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ((fpout = fopen(filename, "wb")) == NULL) {
                                        ^
src/appmake/mc.c:166:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/mc.c:176:19: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/mc.c:172:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/mc.c:176:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/mc.c:180:21: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin);
                    ^
src/appmake/mc.c:172:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/mc.c:180:21: note: Null pointer dereference
        len = ftell(fpin);
                    ^
src/appmake/mc.c:181:15: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/mc.c:172:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/mc.c:181:15: note: Null pointer dereference
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/mc.c:229:16: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fclose(fpin);
               ^
src/appmake/mc.c:172:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/mc.c:229:16: note: Null pointer dereference
        fclose(fpin);
               ^
src/appmake/mc.c:230:16: warning: Either the condition '(fpout=fopen(wavfile,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fclose(fpout);
               ^
src/appmake/mc.c:185:44: note: Assuming that condition '(fpout=fopen(wavfile,"wb"))==NULL' is not redundant
        if ((fpout = fopen(wavfile, "wb")) == NULL) {
                                           ^
src/appmake/mc.c:230:16: note: Null pointer dereference
        fclose(fpout);
               ^
src/appmake/mc.c:82:10: style: The scope of the variable 'wavfile' can be reduced. [variableScope]
    char wavfile[FILENAME_MAX + 1];
         ^
src/appmake/mc.c:83:10: style: The scope of the variable 'name' can be reduced. [variableScope]
    char name[18];
         ^
src/appmake/mc.c:87:14: style: The scope of the variable 'hdlen' can be reduced. [variableScope]
    int len, hdlen;
             ^
src/appmake/mgt.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/mgt.c:99:5: error: Resource handle 'fpin' freed twice. [doubleFree]
    fclose(fpin);
    ^
src/appmake/mgt.c:98:44: note: Resource handle 'fpin' freed twice.
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",c_binary_name); }
                                           ^
src/appmake/mgt.c:99:5: note: Resource handle 'fpin' freed twice.
    fclose(fpin);
    ^
src/appmake/mgt.c:98:35: warning: Either the condition '(fpin=fopen_bin(c_binary_name,c_crt_filename))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",c_binary_name); }
                                  ^
src/appmake/mgt.c:84:62: note: Assuming that condition '(fpin=fopen_bin(c_binary_name,c_crt_filename))==NULL' is not redundant
    if ( ( fpin = fopen_bin(c_binary_name, c_crt_filename) ) == NULL ) {
                                                             ^
src/appmake/mgt.c:98:35: note: Null pointer dereference
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",c_binary_name); }
                                  ^
src/appmake/mgt.c:99:12: warning: Either the condition '(fpin=fopen_bin(c_binary_name,c_crt_filename))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/mgt.c:84:62: note: Assuming that condition '(fpin=fopen_bin(c_binary_name,c_crt_filename))==NULL' is not redundant
    if ( ( fpin = fopen_bin(c_binary_name, c_crt_filename) ) == NULL ) {
                                                             ^
src/appmake/mgt.c:99:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/mgt.c:150:5: warning: Either the condition '(writer=disc_get_writer(c_disc_container,&container_extension))==NULL' is redundant or there is possible null pointer dereference: writer. [nullPointerRedundantCheck]
    writer(h, filename);
    ^
src/appmake/mgt.c:75:77: note: Assuming that condition '(writer=disc_get_writer(c_disc_container,&container_extension))==NULL' is not redundant
    if ( (writer = disc_get_writer(c_disc_container, &container_extension)) == NULL ) {
                                                                            ^
src/appmake/mgt.c:150:5: note: Null pointer dereference
    writer(h, filename);
    ^
src/appmake/mgt.c:190:21: error: Uninitialized variable: sectmap [uninitvar]
                    sectmap[i] |= entry[i + 15];
                    ^
src/appmake/msx.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/msx.c:252:19: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/msx.c:248:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/msx.c:252:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/msx.c:256:21: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin);
                    ^
src/appmake/msx.c:248:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/msx.c:256:21: note: Null pointer dereference
        len = ftell(fpin);
                    ^
src/appmake/msx.c:257:15: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0, SEEK_SET);
              ^
src/appmake/msx.c:248:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/msx.c:257:15: note: Null pointer dereference
        fseek(fpin, 0, SEEK_SET);
              ^
src/appmake/msx.c:313:16: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fclose(fpin);
               ^
src/appmake/msx.c:248:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/msx.c:313:16: note: Null pointer dereference
        fclose(fpin);
               ^
src/appmake/msx.c:314:16: warning: Either the condition '(fpout=fopen(wavfile,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fclose(fpout);
               ^
src/appmake/msx.c:263:44: note: Assuming that condition '(fpout=fopen(wavfile,"wb"))==NULL' is not redundant
        if ((fpout = fopen(wavfile, "wb")) == NULL) {
                                           ^
src/appmake/msx.c:314:16: note: Null pointer dereference
        fclose(fpout);
               ^
src/appmake/msx.c:120:10: style: The scope of the variable 'wavfile' can be reduced. [variableScope]
    char wavfile[FILENAME_MAX + 1];
         ^
src/appmake/msx.c:123:10: style: The scope of the variable 'name' can be reduced. [variableScope]
    char name[11];
         ^
src/appmake/msx.c:276:19: style: Variable 'c' is assigned a value that is never used. [unreadVariable]
                c = getc(fpin);
                  ^
src/appmake/msxrom.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/msxrom.c:55:9: error: Resource handle 'fpin' freed twice. [doubleFree]
        fclose(fpin);
        ^
src/appmake/msxrom.c:48:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/msxrom.c:55:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/msxrom.c:61:78: error: Resource handle 'fpin' freed twice. [doubleFree]
    if (main_length != fread(memory, sizeof(memory[0]), main_length, fpin)){ fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                                                             ^
src/appmake/msxrom.c:48:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/msxrom.c:61:78: note: Resource handle 'fpin' freed twice.
    if (main_length != fread(memory, sizeof(memory[0]), main_length, fpin)){ fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                                                             ^
src/appmake/msxrom.c:62:5: error: Resource handle 'fpin' freed twice. [doubleFree]
    fclose(fpin);
    ^
src/appmake/msxrom.c:48:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/msxrom.c:62:5: note: Resource handle 'fpin' freed twice.
    fclose(fpin);
    ^
src/appmake/msxrom.c:54:30: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if ((main_length = ftell(fpin)) > 0x8000) {
                             ^
src/appmake/msxrom.c:45:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL)
                                             ^
src/appmake/msxrom.c:54:30: note: Null pointer dereference
    if ((main_length = ftell(fpin)) > 0x8000) {
                             ^
src/appmake/msxrom.c:58:12: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    rewind(fpin);
           ^
src/appmake/msxrom.c:45:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL)
                                             ^
src/appmake/msxrom.c:58:12: note: Null pointer dereference
    rewind(fpin);
           ^
src/appmake/msxrom.c:61:70: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (main_length != fread(memory, sizeof(memory[0]), main_length, fpin)){ fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                                                     ^
src/appmake/msxrom.c:45:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL)
                                             ^
src/appmake/msxrom.c:61:70: note: Null pointer dereference
    if (main_length != fread(memory, sizeof(memory[0]), main_length, fpin)){ fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                                                     ^
src/appmake/msxrom.c:62:12: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/msxrom.c:45:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL)
                                             ^
src/appmake/msxrom.c:62:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/msxrom.c:143:25: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fwrite(memory,len,1,fpout);
                        ^
src/appmake/msxrom.c:129:41: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ((fpout = fopen(filename, "wb")) == NULL)
                                        ^
src/appmake/msxrom.c:143:25: note: Null pointer dereference
    fwrite(memory,len,1,fpout);
                        ^
src/appmake/msxrom.c:144:12: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/msxrom.c:129:41: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ((fpout = fopen(filename, "wb")) == NULL)
                                        ^
src/appmake/msxrom.c:144:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/mtx.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/mtx.c:470:13: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
            printf("System Variables block length ........... %d byte(s)\n", varblklen);
            ^
src/appmake/mtx.c:493:13: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
            printf("$FACC (prg block length) ................ %d byte(s)\n", prgblklen);
            ^
src/appmake/mtx.c:496:13: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
            printf("Variables block length .................. %d byte(s)\n", varblklen);
            ^
src/appmake/mtx.c:175:13: error: Resource handle 'fpin' freed twice. [doubleFree]
            fclose(fpin);
            ^
src/appmake/mtx.c:166:13: note: Resource handle 'fpin' freed twice.
            fclose(fpin);
            ^
src/appmake/mtx.c:175:13: note: Resource handle 'fpin' freed twice.
            fclose(fpin);
            ^
src/appmake/mtx.c:392:13: error: Resource handle 'fpin' freed twice. [doubleFree]
            fclose(fpin);
            ^
src/appmake/mtx.c:375:13: note: Resource handle 'fpin' freed twice.
            fclose(fpin);
            ^
src/appmake/mtx.c:392:13: note: Resource handle 'fpin' freed twice.
            fclose(fpin);
            ^
src/appmake/mtx.c:165:19: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/mtx.c:161:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/mtx.c:165:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/mtx.c:170:21: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin);
                    ^
src/appmake/mtx.c:161:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/mtx.c:170:21: note: Null pointer dereference
        len = ftell(fpin);
                    ^
src/appmake/mtx.c:172:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/mtx.c:161:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/mtx.c:172:15: note: Null pointer dereference
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/mtx.c:362:16: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fclose(fpin);
               ^
src/appmake/mtx.c:161:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/mtx.c:362:16: note: Null pointer dereference
        fclose(fpin);
               ^
src/appmake/mtx.c:363:16: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fclose(fpout);
               ^
src/appmake/mtx.c:174:45: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
        if ((fpout = fopen(filename, "wb")) == NULL) {
                                            ^
src/appmake/mtx.c:363:16: note: Null pointer dereference
        fclose(fpout);
               ^
src/appmake/mtx.c:374:19: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/mtx.c:370:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/mtx.c:374:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/mtx.c:378:21: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin);
                    ^
src/appmake/mtx.c:370:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/mtx.c:378:21: note: Null pointer dereference
        len = ftell(fpin);
                    ^
src/appmake/mtx.c:379:15: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0, SEEK_SET);
              ^
src/appmake/mtx.c:370:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/mtx.c:379:15: note: Null pointer dereference
        fseek(fpin, 0, SEEK_SET);
              ^
src/appmake/mtx.c:389:18: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        c = getc(fpin);
                 ^
src/appmake/mtx.c:370:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/mtx.c:389:18: note: Null pointer dereference
        c = getc(fpin);
                 ^
src/appmake/mtx.c:390:19: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        ungetc(c, fpin);
                  ^
src/appmake/mtx.c:370:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/mtx.c:390:19: note: Null pointer dereference
        ungetc(c, fpin);
                  ^
src/appmake/mtx.c:107:10: style: The scope of the variable 'wavfile' can be reduced. [variableScope]
    char wavfile[FILENAME_MAX + 1];
         ^
src/appmake/mtx.c:110:10: style: The scope of the variable 'mybuf' can be reduced. [variableScope]
    char mybuf[20];
         ^
src/appmake/mtx.c:113:14: style: The scope of the variable 'prglen' can be reduced. [variableScope]
    int len, prglen, rampos;
             ^
src/appmake/mtx.c:113:22: style: The scope of the variable 'rampos' can be reduced. [variableScope]
    int len, prglen, rampos;
                     ^
src/appmake/mtx.c:114:10: style: The scope of the variable 'pos' can be reduced. [variableScope]
    long pos;
         ^
src/appmake/mtx.c:117:18: style: The scope of the variable 'stklim' can be reduced. [variableScope]
    unsigned int stklim;
                 ^
src/appmake/mtx.c:118:18: style: The scope of the variable 'varblklen' can be reduced. [variableScope]
    unsigned int varblklen, calcst, varnam, prgblklen;
                 ^
src/appmake/mtx.c:118:29: style: The scope of the variable 'calcst' can be reduced. [variableScope]
    unsigned int varblklen, calcst, varnam, prgblklen;
                            ^
src/appmake/mtx.c:118:37: style: The scope of the variable 'varnam' can be reduced. [variableScope]
    unsigned int varblklen, calcst, varnam, prgblklen;
                                    ^
src/appmake/mtx.c:118:45: style: The scope of the variable 'prgblklen' can be reduced. [variableScope]
    unsigned int varblklen, calcst, varnam, prgblklen;
                                            ^
src/appmake/multi8.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/multi8.c:106:9: error: Resource handle 'bootstrap_fp' freed twice. [doubleFree]
        fclose(bootstrap_fp);
        ^
src/appmake/multi8.c:96:13: note: Resource handle 'bootstrap_fp' freed twice.
            fclose(bootstrap_fp);
            ^
src/appmake/multi8.c:106:9: note: Resource handle 'bootstrap_fp' freed twice.
        fclose(bootstrap_fp);
        ^
src/appmake/multi8.c:111:5: error: Resource handle 'fpin' freed twice. [doubleFree]
    fclose(fpin);
    ^
src/appmake/multi8.c:76:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/multi8.c:111:5: note: Resource handle 'fpin' freed twice.
    fclose(fpin);
    ^
src/appmake/multi8.c:74:16: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if ( fseek(fpin,0,SEEK_END) ) {
               ^
src/appmake/multi8.c:69:45: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
   if ( (fpin=fopen_bin(binname, crtfile) ) == NULL ) {
                                            ^
src/appmake/multi8.c:74:16: note: Null pointer dereference
    if ( fseek(fpin,0,SEEK_END) ) {
               ^
src/appmake/multi8.c:79:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    len=ftell(fpin);
              ^
src/appmake/multi8.c:69:45: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
   if ( (fpin=fopen_bin(binname, crtfile) ) == NULL ) {
                                            ^
src/appmake/multi8.c:79:15: note: Null pointer dereference
    len=ftell(fpin);
              ^
src/appmake/multi8.c:80:11: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin,0L,SEEK_SET);
          ^
src/appmake/multi8.c:69:45: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
   if ( (fpin=fopen_bin(binname, crtfile) ) == NULL ) {
                                            ^
src/appmake/multi8.c:80:11: note: Null pointer dereference
    fseek(fpin,0L,SEEK_SET);
          ^
src/appmake/multi8.c:95:20: warning: Either the condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: bootstrap_fp. [nullPointerRedundantCheck]
        if ( fseek(bootstrap_fp,0,SEEK_END) ) {
                   ^
src/appmake/multi8.c:92:59: note: Assuming that condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is not redundant
        if ( (bootstrap_fp=fopen_bin(bootname, crtfile) ) == NULL ) {
                                                          ^
src/appmake/multi8.c:95:20: note: Null pointer dereference
        if ( fseek(bootstrap_fp,0,SEEK_END) ) {
                   ^
src/appmake/multi8.c:99:25: warning: Either the condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: bootstrap_fp. [nullPointerRedundantCheck]
        bootlen = ftell(bootstrap_fp);
                        ^
src/appmake/multi8.c:92:59: note: Assuming that condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is not redundant
        if ( (bootstrap_fp=fopen_bin(bootname, crtfile) ) == NULL ) {
                                                          ^
src/appmake/multi8.c:99:25: note: Null pointer dereference
        bootlen = ftell(bootstrap_fp);
                        ^
src/appmake/multi8.c:100:15: warning: Either the condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: bootstrap_fp. [nullPointerRedundantCheck]
        fseek(bootstrap_fp,0L,SEEK_SET);
              ^
src/appmake/multi8.c:92:59: note: Assuming that condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is not redundant
        if ( (bootstrap_fp=fopen_bin(bootname, crtfile) ) == NULL ) {
                                                          ^
src/appmake/multi8.c:100:15: note: Null pointer dereference
        fseek(bootstrap_fp,0L,SEEK_SET);
              ^
src/appmake/multi8.c:111:12: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/multi8.c:69:45: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
   if ( (fpin=fopen_bin(binname, crtfile) ) == NULL ) {
                                            ^
src/appmake/multi8.c:111:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/multi8.c:112:12: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/multi8.c:83:40: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                       ^
src/appmake/multi8.c:112:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/mz.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/mz.c:684:54: style: Condition 'strcmp(dst,"80b")==0' is always false [knownConditionTrueFalse]
  if ((strcmp(dst,"80b") == 0) || (strcmp(dst,"80b") == 0))
                                                     ^
src/appmake/mz.c:684:26: note: Assuming that condition 'strcmp(dst,"80b")==0' is not redundant
  if ((strcmp(dst,"80b") == 0) || (strcmp(dst,"80b") == 0))
                         ^
src/appmake/mz.c:684:54: note: Condition 'strcmp(dst,"80b")==0' is always false
  if ((strcmp(dst,"80b") == 0) || (strcmp(dst,"80b") == 0))
                                                     ^
src/appmake/mz.c:706:54: style: Condition 'strcmp(src,"80b")==0' is always false [knownConditionTrueFalse]
  if ((strcmp(src,"80b") == 0) || (strcmp(src,"80b") == 0))
                                                     ^
src/appmake/mz.c:706:26: note: Assuming that condition 'strcmp(src,"80b")==0' is not redundant
  if ((strcmp(src,"80b") == 0) || (strcmp(src,"80b") == 0))
                         ^
src/appmake/mz.c:706:54: note: Condition 'strcmp(src,"80b")==0' is always false
  if ((strcmp(src,"80b") == 0) || (strcmp(src,"80b") == 0))
                                                     ^
src/appmake/mz.c:782:4: error: Resource handle 'fpin' freed twice. [doubleFree]
   fclose(fpin);
   ^
src/appmake/mz.c:773:4: note: Resource handle 'fpin' freed twice.
   fclose(fpin);
   ^
src/appmake/mz.c:782:4: note: Resource handle 'fpin' freed twice.
   fclose(fpin);
   ^
src/appmake/mz.c:793:11: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
  fputc(1,fpout);   /* MZ80K M/C progtam file type */
          ^
src/appmake/mz.c:781:38: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
  if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                     ^
src/appmake/mz.c:793:11: note: Null pointer dereference
  fputc(1,fpout);   /* MZ80K M/C progtam file type */
          ^
src/appmake/mz.c:848:19: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin,0,SEEK_END)) {
                  ^
src/appmake/mz.c:844:37: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
  if ( (fpin=fopen(filename,"rb") ) == NULL ) {
                                    ^
src/appmake/mz.c:848:19: note: Null pointer dereference
        if (fseek(fpin,0,SEEK_END)) {
                  ^
src/appmake/mz.c:852:19: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len=ftell(fpin);
                  ^
src/appmake/mz.c:844:37: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
  if ( (fpin=fopen(filename,"rb") ) == NULL ) {
                                    ^
src/appmake/mz.c:852:19: note: Null pointer dereference
        len=ftell(fpin);
                  ^
src/appmake/mz.c:853:15: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin,0L,SEEK_SET);
              ^
src/appmake/mz.c:844:37: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
  if ( (fpin=fopen(filename,"rb") ) == NULL ) {
                                    ^
src/appmake/mz.c:853:15: note: Null pointer dereference
        fseek(fpin,0L,SEEK_SET);
              ^
src/appmake/mz.c:882:10: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
  fclose(fpin);
         ^
src/appmake/mz.c:844:37: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
  if ( (fpin=fopen(filename,"rb") ) == NULL ) {
                                    ^
src/appmake/mz.c:882:10: note: Null pointer dereference
  fclose(fpin);
         ^
src/appmake/mz.c:885:8: warning: Either the condition '!image' is redundant or there is possible null pointer dereference: image. [nullPointerRedundantCheck]
  if ((image[0x12] + (image[0x13] * 256) + 0x80)!=len) {
       ^
src/appmake/mz.c:858:7: note: Assuming that condition '!image' is not redundant
  if (!image) {
      ^
src/appmake/mz.c:885:8: note: Null pointer dereference
  if ((image[0x12] + (image[0x13] * 256) + 0x80)!=len) {
       ^
src/appmake/mz.c:898:12: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/mz.c:894:40: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                       ^
src/appmake/mz.c:898:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/mz.c:684:32: style: Same expression on both sides of '||'. [duplicateExpression]
  if ((strcmp(dst,"80b") == 0) || (strcmp(dst,"80b") == 0))
                               ^
src/appmake/mz.c:706:32: style: Same expression on both sides of '||'. [duplicateExpression]
  if ((strcmp(src,"80b") == 0) || (strcmp(src,"80b") == 0))
                               ^
src/appmake/mz.c:663:13: style: The scope of the variable 'wavfile' can be reduced. [variableScope]
    char    wavfile[FILENAME_MAX+1];
            ^
src/appmake/mz.c:664:13: style: The scope of the variable 'name' can be reduced. [variableScope]
    char    name[18];
            ^
src/appmake/mz.c:666:13: style: The scope of the variable 'pos' can be reduced. [variableScope]
    long    pos;
            ^
src/appmake/mz.c:667:13: style: The scope of the variable 'c' can be reduced. [variableScope]
    int     c;
            ^
src/appmake/mz.c:446:19: style: Variable 'i' is assigned a value that is never used. [unreadVariable]
  unsigned char i = 0;
                  ^
src/appmake/mz2500.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/mz2500.c:102:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/mz2500.c:96:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/mz2500.c:102:15: note: Null pointer dereference
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/mz2500.c:107:17: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    len = ftell(fpin);
                ^
src/appmake/mz2500.c:96:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/mz2500.c:107:17: note: Null pointer dereference
    len = ftell(fpin);
                ^
src/appmake/mz2500.c:108:11: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/mz2500.c:96:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/mz2500.c:108:11: note: Null pointer dereference
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/mz2500.c:168:12: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/mz2500.c:96:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/mz2500.c:168:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/mz2500.c:68:12: style: The scope of the variable 'bytes_read' can be reduced. [variableScope]
    size_t bytes_read;
           ^
src/appmake/nascom.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/nascom.c:75:15: warning: Either the condition '(fpin=fopen_bin(binname,NULL))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/nascom.c:67:43: note: Assuming that condition '(fpin=fopen_bin(binname,NULL))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, NULL)) == NULL) {
                                          ^
src/appmake/nascom.c:75:15: note: Null pointer dereference
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/nascom.c:80:17: warning: Either the condition '(fpin=fopen_bin(binname,NULL))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    len = ftell(fpin);
                ^
src/appmake/nascom.c:67:43: note: Assuming that condition '(fpin=fopen_bin(binname,NULL))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, NULL)) == NULL) {
                                          ^
src/appmake/nascom.c:80:17: note: Null pointer dereference
    len = ftell(fpin);
                ^
src/appmake/nascom.c:82:11: warning: Either the condition '(fpin=fopen_bin(binname,NULL))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/nascom.c:67:43: note: Assuming that condition '(fpin=fopen_bin(binname,NULL))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, NULL)) == NULL) {
                                          ^
src/appmake/nascom.c:82:11: note: Null pointer dereference
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/nascom.c:39:9: style: The scope of the variable 'c' can be reduced. [variableScope]
    int c;
        ^
src/appmake/nec.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/nec.c:290:9: error: Resource handle 'fpin' freed twice. [doubleFree]
        fclose(fpin);
        ^
src/appmake/nec.c:274:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/nec.c:290:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/nec.c:273:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/nec.c:265:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/nec.c:273:15: note: Null pointer dereference
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/nec.c:278:17: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    len = ftell(fpin);
                ^
src/appmake/nec.c:265:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/nec.c:278:17: note: Null pointer dereference
    len = ftell(fpin);
                ^
src/appmake/nec.c:280:11: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/nec.c:265:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/nec.c:280:11: note: Null pointer dereference
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/nec.c:380:19: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/nec.c:376:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/nec.c:380:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/nec.c:384:21: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin);
                    ^
src/appmake/nec.c:376:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/nec.c:384:21: note: Null pointer dereference
        len = ftell(fpin);
                    ^
src/appmake/nec.c:385:15: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0, SEEK_SET);
              ^
src/appmake/nec.c:376:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/nec.c:385:15: note: Null pointer dereference
        fseek(fpin, 0, SEEK_SET);
              ^
src/appmake/nec.c:464:16: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fclose(fpin);
               ^
src/appmake/nec.c:376:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/nec.c:464:16: note: Null pointer dereference
        fclose(fpin);
               ^
src/appmake/nec.c:465:16: warning: Either the condition '(fpout=fopen(wavfile,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fclose(fpout);
               ^
src/appmake/nec.c:391:44: note: Assuming that condition '(fpout=fopen(wavfile,"wb"))==NULL' is not redundant
        if ((fpout = fopen(wavfile, "wb")) == NULL) {
                                           ^
src/appmake/nec.c:465:16: note: Null pointer dereference
        fclose(fpout);
               ^
src/appmake/nec.c:212:10: style: The scope of the variable 'wavfile' can be reduced. [variableScope]
    char wavfile[FILENAME_MAX + 1];
         ^
src/appmake/nec.c:214:15: style: The scope of the variable 'j' can be reduced. [variableScope]
    int c, i, j;
              ^
src/appmake/nec.c:215:14: style: The scope of the variable 'stage' can be reduced. [variableScope]
    int len, stage;
             ^
src/appmake/nec.c:216:9: style: The scope of the variable 'zerocount' can be reduced. [variableScope]
    int zerocount = 0;
        ^
src/appmake/nec.c:261:25: error: Uninitialized variable: filename [uninitvar]
    if (strcmp(binname, filename) == 0) {
                        ^
src/appmake/newbrain.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/newbrain.c:78:16: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if  (fseek(fpin,0,SEEK_END)) {
               ^
src/appmake/newbrain.c:69:43: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
 if ( (fpin=fopen_bin(binname, crtfile) ) == NULL ) {
                                          ^
src/appmake/newbrain.c:78:16: note: Null pointer dereference
    if  (fseek(fpin,0,SEEK_END)) {
               ^
src/appmake/newbrain.c:83:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    len=ftell(fpin);
              ^
src/appmake/newbrain.c:69:43: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
 if ( (fpin=fopen_bin(binname, crtfile) ) == NULL ) {
                                          ^
src/appmake/newbrain.c:83:15: note: Null pointer dereference
    len=ftell(fpin);
              ^
src/appmake/newbrain.c:86:11: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin,0L,SEEK_SET);
          ^
src/appmake/newbrain.c:69:43: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
 if ( (fpin=fopen_bin(binname, crtfile) ) == NULL ) {
                                          ^
src/appmake/newbrain.c:86:11: note: Null pointer dereference
    fseek(fpin,0L,SEEK_SET);
          ^
src/appmake/newbrain.c:97:21: warning: Either the condition '(fpout=fopen(filename,"w"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"10 IF TOP>%i THEN RESERVE TOP-%i\n",pos-1,pos-1);
                    ^
src/appmake/newbrain.c:93:47: note: Assuming that condition '(fpout=fopen(filename,"w"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"w") ) == NULL ) {
                                              ^
src/appmake/newbrain.c:97:21: note: Null pointer dereference
            fprintf(fpout,"10 IF TOP>%i THEN RESERVE TOP-%i\n",pos-1,pos-1);
                    ^
src/appmake/newbrain.c:98:21: warning: Either the condition '(fpout=fopen(filename,"w"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"20 FOR i=0TO%i:READa:POKE%i+i,a:NEXT i\n",len-1,pos);
                    ^
src/appmake/newbrain.c:93:47: note: Assuming that condition '(fpout=fopen(filename,"w"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"w") ) == NULL ) {
                                              ^
src/appmake/newbrain.c:98:21: note: Null pointer dereference
            fprintf(fpout,"20 FOR i=0TO%i:READa:POKE%i+i,a:NEXT i\n",len-1,pos);
                    ^
src/appmake/newbrain.c:99:21: warning: Either the condition '(fpout=fopen(filename,"w"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"30 CALL%i\n",pos);
                    ^
src/appmake/newbrain.c:93:47: note: Assuming that condition '(fpout=fopen(filename,"w"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"w") ) == NULL ) {
                                              ^
src/appmake/newbrain.c:99:21: note: Null pointer dereference
            fprintf(fpout,"30 CALL%i\n",pos);
                    ^
src/appmake/newbrain.c:100:21: warning: Either the condition '(fpout=fopen(filename,"w"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"40 END\n");
                    ^
src/appmake/newbrain.c:93:47: note: Assuming that condition '(fpout=fopen(filename,"w"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"w") ) == NULL ) {
                                              ^
src/appmake/newbrain.c:100:21: note: Null pointer dereference
            fprintf(fpout,"40 END\n");
                    ^
src/appmake/newbrain.c:114:21: warning: Either the condition '(fpout=fopen(filename,"w"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"\n");
                    ^
src/appmake/newbrain.c:93:47: note: Assuming that condition '(fpout=fopen(filename,"w"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"w") ) == NULL ) {
                                              ^
src/appmake/newbrain.c:114:21: note: Null pointer dereference
            fprintf(fpout,"\n");
                    ^
src/appmake/newbrain.c:117:20: warning: Either the condition '(fpout=fopen(filename,"w"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fclose(fpout);
                   ^
src/appmake/newbrain.c:93:47: note: Assuming that condition '(fpout=fopen(filename,"w"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"w") ) == NULL ) {
                                              ^
src/appmake/newbrain.c:117:20: note: Null pointer dereference
            fclose(fpout);
                   ^
src/appmake/newbrain.c:132:26: warning: Either the condition '(fpout2=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout2. [nullPointerRedundantCheck]
                fputc (0,fpout2);
                         ^
src/appmake/newbrain.c:127:49: note: Assuming that condition '(fpout2=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout2=fopen(filename,"wb") ) == NULL ) {
                                                ^
src/appmake/newbrain.c:132:26: note: Null pointer dereference
                fputc (0,fpout2);
                         ^
src/appmake/newbrain.c:174:20: warning: Either the condition '(fpout2=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout2. [nullPointerRedundantCheck]
            fclose(fpout2);
                   ^
src/appmake/newbrain.c:127:49: note: Assuming that condition '(fpout2=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout2=fopen(filename,"wb") ) == NULL ) {
                                                ^
src/appmake/newbrain.c:174:20: note: Null pointer dereference
            fclose(fpout2);
                   ^
src/appmake/newbrain.c:186:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x0d,fpout);
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:186:24: note: Null pointer dereference
            fputc(0x0d,fpout);
                       ^
src/appmake/newbrain.c:188:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"10 ");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:188:21: note: Null pointer dereference
            fprintf(fpout,"10 ");
                    ^
src/appmake/newbrain.c:189:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0xAC,fpout);        /* RESERVE */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:189:24: note: Null pointer dereference
            fputc(0xAC,fpout);        /* RESERVE */
                       ^
src/appmake/newbrain.c:190:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0xA8,fpout);        /* TOP */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:190:24: note: Null pointer dereference
            fputc(0xA8,fpout);        /* TOP */
                       ^
src/appmake/newbrain.c:191:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x82,fpout);        /* - */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:191:24: note: Null pointer dereference
            fputc(0x82,fpout);        /* - */
                       ^
src/appmake/newbrain.c:192:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"%i",pos);  /* memory location */
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:192:21: note: Null pointer dereference
            fprintf(fpout,"%i",pos);  /* memory location */
                    ^
src/appmake/newbrain.c:193:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x0d,fpout);
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:193:24: note: Null pointer dereference
            fputc(0x0d,fpout);
                       ^
src/appmake/newbrain.c:195:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"20 ");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:195:21: note: Null pointer dereference
            fprintf(fpout,"20 ");
                    ^
src/appmake/newbrain.c:196:23: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc('b',fpout);
                      ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:196:23: note: Null pointer dereference
            fputc('b',fpout);
                      ^
src/appmake/newbrain.c:197:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x8c,fpout);        /* = */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:197:24: note: Null pointer dereference
            fputc(0x8c,fpout);        /* = */
                       ^
src/appmake/newbrain.c:198:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"121:");  /* 121 */
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:198:21: note: Null pointer dereference
            fprintf(fpout,"121:");  /* 121 */
                    ^
src/appmake/newbrain.c:199:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x89,fpout);        /* IF */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:199:24: note: Null pointer dereference
            fputc(0x89,fpout);        /* IF */
                       ^
src/appmake/newbrain.c:200:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0xa4,fpout);        /* PEEK */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:200:24: note: Null pointer dereference
            fputc(0xa4,fpout);        /* PEEK */
                       ^
src/appmake/newbrain.c:201:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"(51)");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:201:21: note: Null pointer dereference
            fprintf(fpout,"(51)");
                    ^
src/appmake/newbrain.c:202:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x8d,fpout);        /* > */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:202:24: note: Null pointer dereference
            fputc(0x8d,fpout);        /* > */
                       ^
src/appmake/newbrain.c:203:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"127");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:203:21: note: Null pointer dereference
            fprintf(fpout,"127");
                    ^
src/appmake/newbrain.c:204:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0xb4,fpout);        /* THEN */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:204:24: note: Null pointer dereference
            fputc(0xb4,fpout);        /* THEN */
                       ^
src/appmake/newbrain.c:205:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"b");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:205:21: note: Null pointer dereference
            fprintf(fpout,"b");
                    ^
src/appmake/newbrain.c:206:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x8c,fpout);        /* = */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:206:24: note: Null pointer dereference
            fputc(0x8c,fpout);        /* = */
                       ^
src/appmake/newbrain.c:207:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0xa4,fpout);        /* PEEK */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:207:24: note: Null pointer dereference
            fputc(0xa4,fpout);        /* PEEK */
                       ^
src/appmake/newbrain.c:208:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"(168)");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:208:21: note: Null pointer dereference
            fprintf(fpout,"(168)");
                    ^
src/appmake/newbrain.c:209:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x81,fpout);        /* + */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:209:24: note: Null pointer dereference
            fputc(0x81,fpout);        /* + */
                       ^
src/appmake/newbrain.c:210:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"256");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:210:21: note: Null pointer dereference
            fprintf(fpout,"256");
                    ^
src/appmake/newbrain.c:211:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x83,fpout);        /* * */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:211:24: note: Null pointer dereference
            fputc(0x83,fpout);        /* * */
                       ^
src/appmake/newbrain.c:212:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0xa4,fpout);        /* PEEK */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:212:24: note: Null pointer dereference
            fputc(0xa4,fpout);        /* PEEK */
                       ^
src/appmake/newbrain.c:213:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"(169):");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:213:21: note: Null pointer dereference
            fprintf(fpout,"(169):");
                    ^
src/appmake/newbrain.c:214:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x9e,fpout);        /* POKE */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:214:24: note: Null pointer dereference
            fputc(0x9e,fpout);        /* POKE */
                       ^
src/appmake/newbrain.c:215:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"169,");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:215:21: note: Null pointer dereference
            fprintf(fpout,"169,");
                    ^
src/appmake/newbrain.c:216:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x96,fpout);        /* INT */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:216:24: note: Null pointer dereference
            fputc(0x96,fpout);        /* INT */
                       ^
src/appmake/newbrain.c:217:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"((b");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:217:21: note: Null pointer dereference
            fprintf(fpout,"((b");
                    ^
src/appmake/newbrain.c:218:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x81,fpout);        /* + */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:218:24: note: Null pointer dereference
            fputc(0x81,fpout);        /* + */
                       ^
src/appmake/newbrain.c:219:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"23)");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:219:21: note: Null pointer dereference
            fprintf(fpout,"23)");
                    ^
src/appmake/newbrain.c:220:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x84,fpout);        /* / */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:220:24: note: Null pointer dereference
            fputc(0x84,fpout);        /* / */
                       ^
src/appmake/newbrain.c:221:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"256):");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:221:21: note: Null pointer dereference
            fprintf(fpout,"256):");
                    ^
src/appmake/newbrain.c:222:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x9e,fpout);        /* POKE */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:222:24: note: Null pointer dereference
            fputc(0x9e,fpout);        /* POKE */
                       ^
src/appmake/newbrain.c:223:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"168,b");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:223:21: note: Null pointer dereference
            fprintf(fpout,"168,b");
                    ^
src/appmake/newbrain.c:224:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x81,fpout);        /* + */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:224:24: note: Null pointer dereference
            fputc(0x81,fpout);        /* + */
                       ^
src/appmake/newbrain.c:225:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"23");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:225:21: note: Null pointer dereference
            fprintf(fpout,"23");
                    ^
src/appmake/newbrain.c:226:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x82,fpout);        /* - */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:226:24: note: Null pointer dereference
            fputc(0x82,fpout);        /* - */
                       ^
src/appmake/newbrain.c:227:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"256");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:227:21: note: Null pointer dereference
            fprintf(fpout,"256");
                    ^
src/appmake/newbrain.c:228:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x83,fpout);        /* * */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:228:24: note: Null pointer dereference
            fputc(0x83,fpout);        /* * */
                       ^
src/appmake/newbrain.c:229:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0xa4,fpout);        /* PEEK */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:229:24: note: Null pointer dereference
            fputc(0xa4,fpout);        /* PEEK */
                       ^
src/appmake/newbrain.c:230:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"(169)");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:230:21: note: Null pointer dereference
            fprintf(fpout,"(169)");
                    ^
src/appmake/newbrain.c:231:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x0d,fpout);
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:231:24: note: Null pointer dereference
            fputc(0x0d,fpout);
                       ^
src/appmake/newbrain.c:233:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"30 ");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:233:21: note: Null pointer dereference
            fprintf(fpout,"30 ");
                    ^
src/appmake/newbrain.c:234:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x8b,fpout);        /* FOR */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:234:24: note: Null pointer dereference
            fputc(0x8b,fpout);        /* FOR */
                       ^
src/appmake/newbrain.c:235:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout," i ");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:235:21: note: Null pointer dereference
            fprintf(fpout," i ");
                    ^
src/appmake/newbrain.c:236:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x8c,fpout);        /* = */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:236:24: note: Null pointer dereference
            fputc(0x8c,fpout);        /* = */
                       ^
src/appmake/newbrain.c:237:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout," 0 ");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:237:21: note: Null pointer dereference
            fprintf(fpout," 0 ");
                    ^
src/appmake/newbrain.c:238:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0xb6,fpout);        /* TO */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:238:24: note: Null pointer dereference
            fputc(0xb6,fpout);        /* TO */
                       ^
src/appmake/newbrain.c:239:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout," 22:");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:239:21: note: Null pointer dereference
            fprintf(fpout," 22:");
                    ^
src/appmake/newbrain.c:240:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x9c,fpout);        /* READ */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:240:24: note: Null pointer dereference
            fputc(0x9c,fpout);        /* READ */
                       ^
src/appmake/newbrain.c:241:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout," c:");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:241:21: note: Null pointer dereference
            fprintf(fpout," c:");
                    ^
src/appmake/newbrain.c:242:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x9e,fpout);        /* POKE */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:242:24: note: Null pointer dereference
            fputc(0x9e,fpout);        /* POKE */
                       ^
src/appmake/newbrain.c:243:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout," b");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:243:21: note: Null pointer dereference
            fprintf(fpout," b");
                    ^
src/appmake/newbrain.c:244:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x81,fpout);        /* + */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:244:24: note: Null pointer dereference
            fputc(0x81,fpout);        /* + */
                       ^
src/appmake/newbrain.c:245:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"i,c:");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:245:21: note: Null pointer dereference
            fprintf(fpout,"i,c:");
                    ^
src/appmake/newbrain.c:246:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x8c,fpout);        /* NEXT */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:246:24: note: Null pointer dereference
            fputc(0x8c,fpout);        /* NEXT */
                       ^
src/appmake/newbrain.c:247:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout," i:");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:247:21: note: Null pointer dereference
            fprintf(fpout," i:");
                    ^
src/appmake/newbrain.c:248:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x9d,fpout);        /* DATA */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:248:24: note: Null pointer dereference
            fputc(0x9d,fpout);        /* DATA */
                       ^
src/appmake/newbrain.c:249:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout," 253,110,32,253,102,33,22,0,30,1,1,");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:249:21: note: Null pointer dereference
            fprintf(fpout," 253,110,32,253,102,33,22,0,30,1,1,");
                    ^
src/appmake/newbrain.c:250:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"%i",len%256);  /* LSB for Length */
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:250:21: note: Null pointer dereference
            fprintf(fpout,"%i",len%256);  /* LSB for Length */
                    ^
src/appmake/newbrain.c:251:23: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(',',fpout);
                      ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:251:23: note: Null pointer dereference
            fputc(',',fpout);
                      ^
src/appmake/newbrain.c:252:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"%i",len/256);  /* MSB for Length */
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:252:21: note: Null pointer dereference
            fprintf(fpout,"%i",len/256);  /* MSB for Length */
                    ^
src/appmake/newbrain.c:253:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,",231,49,119,35,11,120,177,200,24,246");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:253:21: note: Null pointer dereference
            fprintf(fpout,",231,49,119,35,11,120,177,200,24,246");
                    ^
src/appmake/newbrain.c:254:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x0d,fpout);
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:254:24: note: Null pointer dereference
            fputc(0x0d,fpout);
                       ^
src/appmake/newbrain.c:256:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"40 ");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:256:21: note: Null pointer dereference
            fprintf(fpout,"40 ");
                    ^
src/appmake/newbrain.c:257:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x97,fpout);        /* OPEN */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:257:24: note: Null pointer dereference
            fputc(0x97,fpout);        /* OPEN */
                       ^
src/appmake/newbrain.c:259:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0xb3,fpout);        /* # */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:259:24: note: Null pointer dereference
            fputc(0xb3,fpout);        /* # */
                       ^
src/appmake/newbrain.c:260:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"1,");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:260:21: note: Null pointer dereference
            fprintf(fpout,"1,");
                    ^
src/appmake/newbrain.c:261:23: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc('"',fpout);
                      ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:261:23: note: Null pointer dereference
            fputc('"',fpout);
                      ^
src/appmake/newbrain.c:262:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"%s",blockname);
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:262:21: note: Null pointer dereference
            fprintf(fpout,"%s",blockname);
                    ^
src/appmake/newbrain.c:263:23: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc('"',fpout);
                      ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:263:23: note: Null pointer dereference
            fputc('"',fpout);
                      ^
src/appmake/newbrain.c:264:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x0d,fpout);
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:264:24: note: Null pointer dereference
            fputc(0x0d,fpout);
                       ^
src/appmake/newbrain.c:266:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"50 ");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:266:21: note: Null pointer dereference
            fprintf(fpout,"50 ");
                    ^
src/appmake/newbrain.c:267:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x9f,fpout);        /* CALL */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:267:24: note: Null pointer dereference
            fputc(0x9f,fpout);        /* CALL */
                       ^
src/appmake/newbrain.c:268:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout," b : ");
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:268:21: note: Null pointer dereference
            fprintf(fpout," b : ");
                    ^
src/appmake/newbrain.c:269:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x9f,fpout);        /* CALL */
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:269:24: note: Null pointer dereference
            fputc(0x9f,fpout);        /* CALL */
                       ^
src/appmake/newbrain.c:270:21: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout," %i",pos);
                    ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:270:21: note: Null pointer dereference
            fprintf(fpout," %i",pos);
                    ^
src/appmake/newbrain.c:271:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x0d,fpout);
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:271:24: note: Null pointer dereference
            fputc(0x0d,fpout);
                       ^
src/appmake/newbrain.c:273:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x04,fpout);
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:273:24: note: Null pointer dereference
            fputc(0x04,fpout);
                       ^
src/appmake/newbrain.c:274:24: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fputc(0x0d,fpout);
                       ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:274:24: note: Null pointer dereference
            fputc(0x0d,fpout);
                       ^
src/appmake/newbrain.c:275:20: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fclose(fpout);
                   ^
src/appmake/newbrain.c:182:48: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                               ^
src/appmake/newbrain.c:275:20: note: Null pointer dereference
            fclose(fpout);
                   ^
src/appmake/newbrain.c:285:24: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
            if  (fseek(fpin,0,SEEK_END)) {
                       ^
src/appmake/newbrain.c:281:47: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
            if ( (fpin=fopen(filename,"rb") ) == NULL ) {
                                              ^
src/appmake/newbrain.c:285:24: note: Null pointer dereference
            if  (fseek(fpin,0,SEEK_END)) {
                       ^
src/appmake/newbrain.c:290:23: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
            len=ftell(fpin);
                      ^
src/appmake/newbrain.c:281:47: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
            if ( (fpin=fopen(filename,"rb") ) == NULL ) {
                                              ^
src/appmake/newbrain.c:290:23: note: Null pointer dereference
            len=ftell(fpin);
                      ^
src/appmake/newbrain.c:302:22: warning: Either the condition '(fpout2=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout2. [nullPointerRedundantCheck]
            fputc (0,fpout2);
                     ^
src/appmake/newbrain.c:294:49: note: Assuming that condition '(fpout2=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout2=fopen(filename,"wb") ) == NULL ) {
                                                ^
src/appmake/newbrain.c:302:22: note: Null pointer dereference
            fputc (0,fpout2);
                     ^
src/appmake/newbrain.c:332:20: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
            fclose(fpin);
                   ^
src/appmake/newbrain.c:281:47: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
            if ( (fpin=fopen(filename,"rb") ) == NULL ) {
                                              ^
src/appmake/newbrain.c:332:20: note: Null pointer dereference
            fclose(fpin);
                   ^
src/appmake/newbrain.c:333:20: warning: Either the condition '(fpout2=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout2. [nullPointerRedundantCheck]
            fclose(fpout2);
                   ^
src/appmake/newbrain.c:294:49: note: Assuming that condition '(fpout2=fopen(filename,"wb"))==NULL' is not redundant
            if ( (fpout2=fopen(filename,"wb") ) == NULL ) {
                                                ^
src/appmake/newbrain.c:333:20: note: Null pointer dereference
            fclose(fpout2);
                   ^
src/appmake/newbrain.c:341:21: warning: Either the condition '(fpout=fopen("_dir.txt","w"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"%s\n",filename);
                    ^
src/appmake/newbrain.c:338:49: note: Assuming that condition '(fpout=fopen("_dir.txt","w"))==NULL' is not redundant
            if ( (fpout=fopen("_dir.txt","w") ) == NULL ) {
                                                ^
src/appmake/newbrain.c:341:21: note: Null pointer dereference
            fprintf(fpout,"%s\n",filename);
                    ^
src/appmake/newbrain.c:343:21: warning: Either the condition '(fpout=fopen("_dir.txt","w"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fprintf(fpout,"%s\n",filename);
                    ^
src/appmake/newbrain.c:338:49: note: Assuming that condition '(fpout=fopen("_dir.txt","w"))==NULL' is not redundant
            if ( (fpout=fopen("_dir.txt","w") ) == NULL ) {
                                                ^
src/appmake/newbrain.c:343:21: note: Null pointer dereference
            fprintf(fpout,"%s\n",filename);
                    ^
src/appmake/newbrain.c:344:20: warning: Either the condition '(fpout=fopen("_dir.txt","w"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
            fclose(fpout);
                   ^
src/appmake/newbrain.c:338:49: note: Assuming that condition '(fpout=fopen("_dir.txt","w"))==NULL' is not redundant
            if ( (fpout=fopen("_dir.txt","w") ) == NULL ) {
                                                ^
src/appmake/newbrain.c:344:20: note: Null pointer dereference
            fclose(fpout);
                   ^
src/appmake/newbrain.c:35:29: style: The scope of the variable 'fpout2' can be reduced. [variableScope]
    FILE    *fpin, *fpout, *fpout2;
                            ^
src/appmake/newbrain.c:39:18: style: The scope of the variable 'p' can be reduced. [variableScope]
    int        i,p,l,b;
                 ^
src/appmake/newbrain.c:39:20: style: The scope of the variable 'l' can be reduced. [variableScope]
    int        i,p,l,b;
                   ^
src/appmake/newbrain.c:39:22: style: The scope of the variable 'b' can be reduced. [variableScope]
    int        i,p,l,b;
                     ^
src/appmake/newbrain.c:41:16: style: The scope of the variable 'lnum' can be reduced. [variableScope]
    int        lnum;
               ^
src/appmake/newext.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/newext.c:73:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/newext.c:69:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/newext.c:73:15: note: Null pointer dereference
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/newext.c:80:17: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    len = ftell(fpin);
                ^
src/appmake/newext.c:69:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/newext.c:80:17: note: Null pointer dereference
    len = ftell(fpin);
                ^
src/appmake/newext.c:82:11: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/newext.c:69:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/newext.c:82:11: note: Null pointer dereference
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/newext.c:93:12: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/newext.c:69:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/newext.c:93:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/newext.c:94:12: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/newext.c:83:41: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ((fpout = fopen(filename, "wb")) == NULL) {
                                        ^
src/appmake/newext.c:94:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/newext.c:46:9: style: The scope of the variable 'c' can be reduced. [variableScope]
    int c, i;
        ^
src/appmake/noop.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/ondra.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/ondra.c:214:12: warning: Either the condition '(fpwav=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpwav. [nullPointerRedundantCheck]
    fclose(fpwav);
           ^
src/appmake/ondra.c:145:43: note: Assuming that condition '(fpwav=fopen(filename,"wb"))==NULL' is not redundant
    if ( ( fpwav = fopen(filename, "wb")) == NULL ) {
                                          ^
src/appmake/ondra.c:214:12: note: Null pointer dereference
    fclose(fpwav);
           ^
src/appmake/ondra.c:216:12: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/ondra.c:140:43: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ( ( fpout = fopen(filename, "wb")) == NULL ) {
                                          ^
src/appmake/ondra.c:216:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/ondra.c:86:33: style: Same expression on both sides of '&'. [duplicateExpression]
    ondra_bit(fpout, (b & 0x01) & 0x01);
                                ^
src/appmake/ondra.c:229:59: style:inconclusive: Function 'writebyte_ondra' argument 3 names different: declaration 'wavfile' definition 'fpwav'. [funcArgNamesDifferent]
static void writebyte_ondra(uint8_t byte, FILE *fp, FILE *fpwav, uint8_t *cksump)
                                                          ^
src/appmake/ondra.c:16:59: note: Function 'writebyte_ondra' argument 3 names different: declaration 'wavfile' definition 'fpwav'.
static void writebyte_ondra(uint8_t byte, FILE *fp, FILE *wavfile, uint8_t *cksump);
                                                          ^
src/appmake/ondra.c:229:59: note: Function 'writebyte_ondra' argument 3 names different: declaration 'wavfile' definition 'fpwav'.
static void writebyte_ondra(uint8_t byte, FILE *fp, FILE *fpwav, uint8_t *cksump)
                                                          ^
src/appmake/p2000.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/p2000.c:68:9: error: Resource handle 'fpin' freed twice. [doubleFree]
        fclose(fpin);
        ^
src/appmake/p2000.c:58:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/p2000.c:68:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/p2000.c:57:15: warning: Either the condition '(fpin=fopen_bin(binname,NULL))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/p2000.c:53:43: note: Assuming that condition '(fpin=fopen_bin(binname,NULL))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, NULL)) == NULL) {
                                          ^
src/appmake/p2000.c:57:15: note: Null pointer dereference
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/p2000.c:62:17: warning: Either the condition '(fpin=fopen_bin(binname,NULL))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    len = ftell(fpin);
                ^
src/appmake/p2000.c:53:43: note: Assuming that condition '(fpin=fopen_bin(binname,NULL))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, NULL)) == NULL) {
                                          ^
src/appmake/p2000.c:62:17: note: Null pointer dereference
    len = ftell(fpin);
                ^
src/appmake/p2000.c:65:11: warning: Either the condition '(fpin=fopen_bin(binname,NULL))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/p2000.c:53:43: note: Assuming that condition '(fpin=fopen_bin(binname,NULL))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, NULL)) == NULL) {
                                          ^
src/appmake/p2000.c:65:11: note: Null pointer dereference
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/p2000.c:248:12: warning: Either the condition '(fpin=fopen_bin(binname,NULL))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/p2000.c:53:43: note: Assuming that condition '(fpin=fopen_bin(binname,NULL))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, NULL)) == NULL) {
                                          ^
src/appmake/p2000.c:248:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/p2000.c:249:12: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/p2000.c:67:41: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ((fpout = fopen(filename, "wb")) == NULL) {
                                        ^
src/appmake/p2000.c:249:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/p2000.c:38:9: style: The scope of the variable 'c' can be reduced. [variableScope]
    int c;
        ^
src/appmake/pasopia7.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/pasopia7.c:81:5: error: Resource handle 'bootstrap_fp' freed twice. [doubleFree]
    fclose(bootstrap_fp);
    ^
src/appmake/pasopia7.c:68:9: note: Resource handle 'bootstrap_fp' freed twice.
        fclose(bootstrap_fp);
        ^
src/appmake/pasopia7.c:81:5: note: Resource handle 'bootstrap_fp' freed twice.
    fclose(bootstrap_fp);
    ^
src/appmake/pasopia7.c:97:44: error: Resource handle 'fpin' freed twice. [doubleFree]
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                           ^
src/appmake/pasopia7.c:90:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/pasopia7.c:97:44: note: Resource handle 'fpin' freed twice.
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                           ^
src/appmake/pasopia7.c:98:5: error: Resource handle 'fpin' freed twice. [doubleFree]
    fclose(fpin);
    ^
src/appmake/pasopia7.c:90:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/pasopia7.c:98:5: note: Resource handle 'fpin' freed twice.
    fclose(fpin);
    ^
src/appmake/pasopia7.c:67:16: warning: Either the condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: bootstrap_fp. [nullPointerRedundantCheck]
    if ( fseek(bootstrap_fp,0,SEEK_END) ) {
               ^
src/appmake/pasopia7.c:64:55: note: Assuming that condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (bootstrap_fp=fopen_bin(bootname, crtfile) ) == NULL ) {
                                                      ^
src/appmake/pasopia7.c:67:16: note: Null pointer dereference
    if ( fseek(bootstrap_fp,0,SEEK_END) ) {
               ^
src/appmake/pasopia7.c:71:21: warning: Either the condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: bootstrap_fp. [nullPointerRedundantCheck]
    bootlen = ftell(bootstrap_fp);
                    ^
src/appmake/pasopia7.c:64:55: note: Assuming that condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (bootstrap_fp=fopen_bin(bootname, crtfile) ) == NULL ) {
                                                      ^
src/appmake/pasopia7.c:71:21: note: Null pointer dereference
    bootlen = ftell(bootstrap_fp);
                    ^
src/appmake/pasopia7.c:72:11: warning: Either the condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: bootstrap_fp. [nullPointerRedundantCheck]
    fseek(bootstrap_fp,0L,SEEK_SET);
          ^
src/appmake/pasopia7.c:64:55: note: Assuming that condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (bootstrap_fp=fopen_bin(bootname, crtfile) ) == NULL ) {
                                                      ^
src/appmake/pasopia7.c:72:11: note: Null pointer dereference
    fseek(bootstrap_fp,0L,SEEK_SET);
          ^
src/appmake/pasopia7.c:78:37: warning: Either the condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: bootstrap_fp. [nullPointerRedundantCheck]
    if ( fread(bootbuf, 1, bootlen, bootstrap_fp) != bootlen ) {
                                    ^
src/appmake/pasopia7.c:64:55: note: Assuming that condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (bootstrap_fp=fopen_bin(bootname, crtfile) ) == NULL ) {
                                                      ^
src/appmake/pasopia7.c:78:37: note: Null pointer dereference
    if ( fread(bootbuf, 1, bootlen, bootstrap_fp) != bootlen ) {
                                    ^
src/appmake/pasopia7.c:81:12: warning: Either the condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: bootstrap_fp. [nullPointerRedundantCheck]
    fclose(bootstrap_fp);
           ^
src/appmake/pasopia7.c:64:55: note: Assuming that condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (bootstrap_fp=fopen_bin(bootname, crtfile) ) == NULL ) {
                                                      ^
src/appmake/pasopia7.c:81:12: note: Null pointer dereference
    fclose(bootstrap_fp);
           ^
src/appmake/pasopia7.c:89:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/pasopia7.c:85:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/pasopia7.c:89:15: note: Null pointer dereference
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/pasopia7.c:94:17: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    pos = ftell(fpin);
                ^
src/appmake/pasopia7.c:85:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/pasopia7.c:94:17: note: Null pointer dereference
    pos = ftell(fpin);
                ^
src/appmake/pasopia7.c:95:11: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/pasopia7.c:85:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/pasopia7.c:95:11: note: Null pointer dereference
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/pasopia7.c:97:35: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                  ^
src/appmake/pasopia7.c:85:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/pasopia7.c:97:35: note: Null pointer dereference
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                  ^
src/appmake/pasopia7.c:98:12: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/pasopia7.c:85:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/pasopia7.c:98:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/pc88.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/pc88.c:139:13: error: Resource handle 'fpin' freed twice. [doubleFree]
            fclose(fpin);
            ^
src/appmake/pc88.c:130:13: note: Resource handle 'fpin' freed twice.
            fclose(fpin);
            ^
src/appmake/pc88.c:139:13: note: Resource handle 'fpin' freed twice.
            fclose(fpin);
            ^
src/appmake/pc88.c:129:19: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/pc88.c:125:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/pc88.c:129:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/pc88.c:134:21: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin);
                    ^
src/appmake/pc88.c:125:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/pc88.c:134:21: note: Null pointer dereference
        len = ftell(fpin);
                    ^
src/appmake/pc88.c:136:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/pc88.c:125:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/pc88.c:136:15: note: Null pointer dereference
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/pc88.c:225:16: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fclose(fpin);
               ^
src/appmake/pc88.c:125:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/pc88.c:225:16: note: Null pointer dereference
        fclose(fpin);
               ^
src/appmake/pc88.c:226:16: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fclose(fpout);
               ^
src/appmake/pc88.c:138:45: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
        if ((fpout = fopen(filename, "wb")) == NULL) {
                                            ^
src/appmake/pc88.c:226:16: note: Null pointer dereference
        fclose(fpout);
               ^
src/appmake/pc88.c:243:9: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
  fgetc(fpin);
        ^
src/appmake/pc88.c:233:37: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
  if ( (fpin=fopen(filename,"rb") ) == NULL ) {
                                    ^
src/appmake/pc88.c:243:9: note: Null pointer dereference
  fgetc(fpin);
        ^
src/appmake/pc88.c:345:16: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fclose(fpin);
               ^
src/appmake/pc88.c:233:37: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
  if ( (fpin=fopen(filename,"rb") ) == NULL ) {
                                    ^
src/appmake/pc88.c:345:16: note: Null pointer dereference
        fclose(fpin);
               ^
src/appmake/pc88.c:346:16: warning: Either the condition '(fpout=fopen(wavfile,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fclose(fpout);
               ^
src/appmake/pc88.c:249:37: note: Assuming that condition '(fpout=fopen(wavfile,"wb"))==NULL' is not redundant
  if ( (fpout=fopen(wavfile,"wb") ) == NULL ) {
                                    ^
src/appmake/pc88.c:346:16: note: Null pointer dereference
        fclose(fpout);
               ^
src/appmake/pc88.c:81:10: style: The scope of the variable 'wavfile' can be reduced. [variableScope]
    char wavfile[FILENAME_MAX+1];
         ^
src/appmake/pc88.c:82:10: style: The scope of the variable 'name' can be reduced. [variableScope]
    char name[10];
         ^
src/appmake/pc88.c:83:10: style: The scope of the variable 'buf' can be reduced. [variableScope]
    char buf[25];
         ^
src/appmake/pc88.c:86:9: style: The scope of the variable 'len' can be reduced. [variableScope]
    int len, len2;
        ^
src/appmake/pc88.c:86:14: style: The scope of the variable 'len2' can be reduced. [variableScope]
    int len, len2;
             ^
src/appmake/pc88.c:87:10: style: The scope of the variable 'pos' can be reduced. [variableScope]
    long pos;
         ^
src/appmake/pc88.c:88:29: style: The scope of the variable 'ticks' can be reduced. [variableScope]
    unsigned long checksum, ticks;
                            ^
src/appmake/pc88.c:191:39: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
  writebyte_cksum((unsigned char)(pos >> 8), fpout, &checksum);    // MSB
                                      ^
src/appmake/pc88disc.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/pc88disc.c:72:5: error: Resource handle 'bootstrap_fp' freed twice. [doubleFree]
    fclose(bootstrap_fp);
    ^
src/appmake/pc88disc.c:59:9: note: Resource handle 'bootstrap_fp' freed twice.
        fclose(bootstrap_fp);
        ^
src/appmake/pc88disc.c:72:5: note: Resource handle 'bootstrap_fp' freed twice.
    fclose(bootstrap_fp);
    ^
src/appmake/pc88disc.c:88:44: error: Resource handle 'fpin' freed twice. [doubleFree]
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                           ^
src/appmake/pc88disc.c:81:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/pc88disc.c:88:44: note: Resource handle 'fpin' freed twice.
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                           ^
src/appmake/pc88disc.c:89:5: error: Resource handle 'fpin' freed twice. [doubleFree]
    fclose(fpin);
    ^
src/appmake/pc88disc.c:81:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/pc88disc.c:89:5: note: Resource handle 'fpin' freed twice.
    fclose(fpin);
    ^
src/appmake/pc88disc.c:58:16: warning: Either the condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: bootstrap_fp. [nullPointerRedundantCheck]
    if ( fseek(bootstrap_fp,0,SEEK_END) ) {
               ^
src/appmake/pc88disc.c:55:55: note: Assuming that condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (bootstrap_fp=fopen_bin(bootname, crtfile) ) == NULL ) {
                                                      ^
src/appmake/pc88disc.c:58:16: note: Null pointer dereference
    if ( fseek(bootstrap_fp,0,SEEK_END) ) {
               ^
src/appmake/pc88disc.c:62:21: warning: Either the condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: bootstrap_fp. [nullPointerRedundantCheck]
    bootlen = ftell(bootstrap_fp);
                    ^
src/appmake/pc88disc.c:55:55: note: Assuming that condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (bootstrap_fp=fopen_bin(bootname, crtfile) ) == NULL ) {
                                                      ^
src/appmake/pc88disc.c:62:21: note: Null pointer dereference
    bootlen = ftell(bootstrap_fp);
                    ^
src/appmake/pc88disc.c:63:11: warning: Either the condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: bootstrap_fp. [nullPointerRedundantCheck]
    fseek(bootstrap_fp,0L,SEEK_SET);
          ^
src/appmake/pc88disc.c:55:55: note: Assuming that condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (bootstrap_fp=fopen_bin(bootname, crtfile) ) == NULL ) {
                                                      ^
src/appmake/pc88disc.c:63:11: note: Null pointer dereference
    fseek(bootstrap_fp,0L,SEEK_SET);
          ^
src/appmake/pc88disc.c:69:37: warning: Either the condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: bootstrap_fp. [nullPointerRedundantCheck]
    if ( fread(bootbuf, 1, bootlen, bootstrap_fp) != bootlen ) {
                                    ^
src/appmake/pc88disc.c:55:55: note: Assuming that condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (bootstrap_fp=fopen_bin(bootname, crtfile) ) == NULL ) {
                                                      ^
src/appmake/pc88disc.c:69:37: note: Null pointer dereference
    if ( fread(bootbuf, 1, bootlen, bootstrap_fp) != bootlen ) {
                                    ^
src/appmake/pc88disc.c:72:12: warning: Either the condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: bootstrap_fp. [nullPointerRedundantCheck]
    fclose(bootstrap_fp);
           ^
src/appmake/pc88disc.c:55:55: note: Assuming that condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (bootstrap_fp=fopen_bin(bootname, crtfile) ) == NULL ) {
                                                      ^
src/appmake/pc88disc.c:72:12: note: Null pointer dereference
    fclose(bootstrap_fp);
           ^
src/appmake/pc88disc.c:80:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/pc88disc.c:76:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/pc88disc.c:80:15: note: Null pointer dereference
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/pc88disc.c:85:17: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    pos = ftell(fpin);
                ^
src/appmake/pc88disc.c:76:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/pc88disc.c:85:17: note: Null pointer dereference
    pos = ftell(fpin);
                ^
src/appmake/pc88disc.c:86:11: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/pc88disc.c:76:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/pc88disc.c:86:11: note: Null pointer dereference
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/pc88disc.c:88:35: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                  ^
src/appmake/pc88disc.c:76:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/pc88disc.c:88:35: note: Null pointer dereference
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                  ^
src/appmake/pc88disc.c:89:12: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/pc88disc.c:76:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/pc88disc.c:89:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/pmd85.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/pmd85.c:54:44: error: Resource handle 'fpin' freed twice. [doubleFree]
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                           ^
src/appmake/pmd85.c:47:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/pmd85.c:54:44: note: Resource handle 'fpin' freed twice.
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                           ^
src/appmake/pmd85.c:55:5: error: Resource handle 'fpin' freed twice. [doubleFree]
    fclose(fpin);
    ^
src/appmake/pmd85.c:47:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/pmd85.c:55:5: note: Resource handle 'fpin' freed twice.
    fclose(fpin);
    ^
src/appmake/pmd85.c:46:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/pmd85.c:42:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/pmd85.c:46:15: note: Null pointer dereference
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/pmd85.c:51:17: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    pos = ftell(fpin);
                ^
src/appmake/pmd85.c:42:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/pmd85.c:51:17: note: Null pointer dereference
    pos = ftell(fpin);
                ^
src/appmake/pmd85.c:52:11: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/pmd85.c:42:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/pmd85.c:52:11: note: Null pointer dereference
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/pmd85.c:54:35: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                  ^
src/appmake/pmd85.c:42:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/pmd85.c:54:35: note: Null pointer dereference
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                  ^
src/appmake/pmd85.c:55:12: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/pmd85.c:42:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/pmd85.c:55:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/pmd85.c:105:12: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/pmd85.c:64:43: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ( ( fpout = fopen(filename, "wb")) == NULL ) {
                                          ^
src/appmake/pmd85.c:105:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/primo.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/primo.c:335:9: error: Resource handle 'fpin' freed twice. [doubleFree]
        fclose(fpin);
        ^
src/appmake/primo.c:326:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/primo.c:335:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/primo.c:352:5: error: Resource handle 'fpin' freed twice. [doubleFree]
    fclose(fpin);
    ^
src/appmake/primo.c:326:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/primo.c:352:5: note: Resource handle 'fpin' freed twice.
    fclose(fpin);
    ^
src/appmake/primo.c:325:15: warning: Either the condition '(fpin=fopen_bin(binname,NULL))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin,0,SEEK_END)) {
              ^
src/appmake/primo.c:321:40: note: Assuming that condition '(fpin=fopen_bin(binname,NULL))==NULL' is not redundant
 if ( (fpin=fopen_bin(binname, NULL) ) == NULL ) {
                                       ^
src/appmake/primo.c:325:15: note: Null pointer dereference
    if (fseek(fpin,0,SEEK_END)) {
              ^
src/appmake/primo.c:330:15: warning: Either the condition '(fpin=fopen_bin(binname,NULL))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    len=ftell(fpin);
              ^
src/appmake/primo.c:321:40: note: Assuming that condition '(fpin=fopen_bin(binname,NULL))==NULL' is not redundant
 if ( (fpin=fopen_bin(binname, NULL) ) == NULL ) {
                                       ^
src/appmake/primo.c:330:15: note: Null pointer dereference
    len=ftell(fpin);
              ^
src/appmake/primo.c:332:11: warning: Either the condition '(fpin=fopen_bin(binname,NULL))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin,0L,SEEK_SET);
          ^
src/appmake/primo.c:321:40: note: Assuming that condition '(fpin=fopen_bin(binname,NULL))==NULL' is not redundant
 if ( (fpin=fopen_bin(binname, NULL) ) == NULL ) {
                                       ^
src/appmake/primo.c:332:11: note: Null pointer dereference
    fseek(fpin,0L,SEEK_SET);
          ^
src/appmake/primo.c:352:12: warning: Either the condition '(fpin=fopen_bin(binname,NULL))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/primo.c:321:40: note: Assuming that condition '(fpin=fopen_bin(binname,NULL))==NULL' is not redundant
 if ( (fpin=fopen_bin(binname, NULL) ) == NULL ) {
                                       ^
src/appmake/primo.c:352:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/primo.c:353:12: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/primo.c:334:40: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                       ^
src/appmake/primo.c:353:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/primo.c:234:14: style: Local variable 'type' shadows outer variable [shadowVariable]
        char type = *ptp_blks->block;
             ^
src/appmake/primo.c:12:26: note: Shadowed declaration
static char             *type         = "pri";
                         ^
src/appmake/primo.c:234:14: note: Shadow variable
        char type = *ptp_blks->block;
             ^
src/appmake/px.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/px.c:85:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/px.c:81:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/px.c:85:15: note: Null pointer dereference
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/px.c:90:17: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    len = ftell(fpin);
                ^
src/appmake/px.c:81:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/px.c:90:17: note: Null pointer dereference
    len = ftell(fpin);
                ^
src/appmake/px.c:92:11: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/px.c:81:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/px.c:92:11: note: Null pointer dereference
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/px.c:47:9: style: The scope of the variable 'c' can be reduced. [variableScope]
    int c, i;
        ^
src/appmake/residos.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/residos.c:88:9: error: Resource handle 'binfile' freed twice. [doubleFree]
        fclose(binfile);
        ^
src/appmake/residos.c:81:9: note: Resource handle 'binfile' freed twice.
        fclose(binfile);
        ^
src/appmake/residos.c:88:9: note: Resource handle 'binfile' freed twice.
        fclose(binfile);
        ^
src/appmake/residos.c:129:9: error: Resource handle 'binfile' freed twice. [doubleFree]
        fclose(binfile);
        ^
src/appmake/residos.c:81:9: note: Resource handle 'binfile' freed twice.
        fclose(binfile);
        ^
src/appmake/residos.c:129:9: note: Resource handle 'binfile' freed twice.
        fclose(binfile);
        ^
src/appmake/residos.c:133:5: error: Resource handle 'binfile' freed twice. [doubleFree]
    fclose(binfile);
    ^
src/appmake/residos.c:81:9: note: Resource handle 'binfile' freed twice.
        fclose(binfile);
        ^
src/appmake/residos.c:133:5: note: Resource handle 'binfile' freed twice.
    fclose(binfile);
    ^
src/appmake/residos.c:80:15: warning: Either the condition '(binfile=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: binfile. [nullPointerRedundantCheck]
    if (fseek(binfile, 0, SEEK_END)) {
              ^
src/appmake/residos.c:76:49: note: Assuming that condition '(binfile=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((binfile = fopen_bin(binname, crtfile)) == NULL) {
                                                ^
src/appmake/residos.c:80:15: note: Null pointer dereference
    if (fseek(binfile, 0, SEEK_END)) {
              ^
src/appmake/residos.c:85:22: warning: Either the condition '(binfile=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: binfile. [nullPointerRedundantCheck]
    filesize = ftell(binfile);
                     ^
src/appmake/residos.c:76:49: note: Assuming that condition '(binfile=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((binfile = fopen_bin(binname, crtfile)) == NULL) {
                                                ^
src/appmake/residos.c:85:22: note: Null pointer dereference
    filesize = ftell(binfile);
                     ^
src/appmake/residos.c:125:11: warning: Either the condition '(binfile=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: binfile. [nullPointerRedundantCheck]
    fseek(binfile, 0, SEEK_SET);
          ^
src/appmake/residos.c:76:49: note: Assuming that condition '(binfile=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((binfile = fopen_bin(binname, crtfile)) == NULL) {
                                                ^
src/appmake/residos.c:125:11: note: Null pointer dereference
    fseek(binfile, 0, SEEK_SET);
          ^
src/appmake/residos.c:126:56: warning: Either the condition '(binfile=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: binfile. [nullPointerRedundantCheck]
    readlen = fread(memory + HEADER_SIZE, 1, filesize, binfile);
                                                       ^
src/appmake/residos.c:76:49: note: Assuming that condition '(binfile=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((binfile = fopen_bin(binname, crtfile)) == NULL) {
                                                ^
src/appmake/residos.c:126:56: note: Null pointer dereference
    readlen = fread(memory + HEADER_SIZE, 1, filesize, binfile);
                                                       ^
src/appmake/residos.c:133:12: warning: Either the condition '(binfile=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: binfile. [nullPointerRedundantCheck]
    fclose(binfile);
           ^
src/appmake/residos.c:76:49: note: Assuming that condition '(binfile=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((binfile = fopen_bin(binname, crtfile)) == NULL) {
                                                ^
src/appmake/residos.c:133:12: note: Null pointer dereference
    fclose(binfile);
           ^
src/appmake/residos.c:152:37: warning: Either the condition '(fp=fopen(name,"wb"))==NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    if (fwrite(memory, 1, filesize, fp) != filesize) {
                                    ^
src/appmake/residos.c:148:34: note: Assuming that condition '(fp=fopen(name,"wb"))==NULL' is not redundant
    if ((fp = fopen(name, "wb")) == NULL) {
                                 ^
src/appmake/residos.c:152:37: note: Null pointer dereference
    if (fwrite(memory, 1, filesize, fp) != filesize) {
                                    ^
src/appmake/residos.c:155:12: warning: Either the condition '(fp=fopen(name,"wb"))==NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    fclose(fp);
           ^
src/appmake/residos.c:148:34: note: Assuming that condition '(fp=fopen(name,"wb"))==NULL' is not redundant
    if ((fp = fopen(name, "wb")) == NULL) {
                                 ^
src/appmake/residos.c:155:12: note: Null pointer dereference
    fclose(fp);
           ^
src/appmake/rex6000.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/rex6000.c:136:9: error: Resource handle 'binfile' freed twice. [doubleFree]
        fclose(binfile);
        ^
src/appmake/rex6000.c:130:9: note: Resource handle 'binfile' freed twice.
        fclose(binfile);
        ^
src/appmake/rex6000.c:136:9: note: Resource handle 'binfile' freed twice.
        fclose(binfile);
        ^
src/appmake/rex6000.c:144:9: error: Resource handle 'binfile' freed twice. [doubleFree]
        fclose(binfile);
        ^
src/appmake/rex6000.c:130:9: note: Resource handle 'binfile' freed twice.
        fclose(binfile);
        ^
src/appmake/rex6000.c:144:9: note: Resource handle 'binfile' freed twice.
        fclose(binfile);
        ^
src/appmake/rex6000.c:129:15: warning: Either the condition '(binfile=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: binfile. [nullPointerRedundantCheck]
    if (fseek(binfile, 0, SEEK_END)) {
              ^
src/appmake/rex6000.c:124:46: note: Assuming that condition '(binfile=fopen_bin(binname,crtfile))==NULL' is not redundant
 if ( (binfile=fopen_bin(binname, crtfile) ) == NULL ) {
                                             ^
src/appmake/rex6000.c:129:15: note: Null pointer dereference
    if (fseek(binfile, 0, SEEK_END)) {
              ^
src/appmake/rex6000.c:133:22: warning: Either the condition '(binfile=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: binfile. [nullPointerRedundantCheck]
    filesize = ftell(binfile);
                     ^
src/appmake/rex6000.c:124:46: note: Assuming that condition '(binfile=fopen_bin(binname,crtfile))==NULL' is not redundant
 if ( (binfile=fopen_bin(binname, crtfile) ) == NULL ) {
                                             ^
src/appmake/rex6000.c:133:22: note: Null pointer dereference
    filesize = ftell(binfile);
                     ^
src/appmake/rex6000.c:140:11: warning: Either the condition '(binfile=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: binfile. [nullPointerRedundantCheck]
    fseek(binfile, 0, SEEK_SET);
          ^
src/appmake/rex6000.c:124:46: note: Assuming that condition '(binfile=fopen_bin(binname,crtfile))==NULL' is not redundant
 if ( (binfile=fopen_bin(binname, crtfile) ) == NULL ) {
                                             ^
src/appmake/rex6000.c:140:11: note: Null pointer dereference
    fseek(binfile, 0, SEEK_SET);
          ^
src/appmake/rex6000.c:147:13: warning: Either the condition '(fp=fopen(output_name,"wb"))==NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    fprintf(fp,"ApplicationName:Addin\r\n");
            ^
src/appmake/rex6000.c:143:41: note: Assuming that condition '(fp=fopen(output_name,"wb"))==NULL' is not redundant
    if ( (fp = fopen(output_name,"wb")) == NULL ) {
                                        ^
src/appmake/rex6000.c:147:13: note: Null pointer dereference
    fprintf(fp,"ApplicationName:Addin\r\n");
            ^
src/appmake/rex6000.c:148:13: warning: Either the condition '(fp=fopen(output_name,"wb"))==NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    fprintf(fp,"%s\r\n",application_name);
            ^
src/appmake/rex6000.c:143:41: note: Assuming that condition '(fp=fopen(output_name,"wb"))==NULL' is not redundant
    if ( (fp = fopen(output_name,"wb")) == NULL ) {
                                        ^
src/appmake/rex6000.c:148:13: note: Null pointer dereference
    fprintf(fp,"%s\r\n",application_name);
            ^
src/appmake/rex6000.c:149:13: warning: Either the condition '(fp=fopen(output_name,"wb"))==NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    fprintf(fp,"%s",application_comment);
            ^
src/appmake/rex6000.c:143:41: note: Assuming that condition '(fp=fopen(output_name,"wb"))==NULL' is not redundant
    if ( (fp = fopen(output_name,"wb")) == NULL ) {
                                        ^
src/appmake/rex6000.c:149:13: note: Null pointer dereference
    fprintf(fp,"%s",application_comment);
            ^
src/appmake/rex6000.c:150:15: warning: Either the condition '(fp=fopen(output_name,"wb"))==NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    fputc( 0, fp);
              ^
src/appmake/rex6000.c:143:41: note: Assuming that condition '(fp=fopen(output_name,"wb"))==NULL' is not redundant
    if ( (fp = fopen(output_name,"wb")) == NULL ) {
                                        ^
src/appmake/rex6000.c:150:15: note: Null pointer dereference
    fputc( 0, fp);
              ^
src/appmake/rex6000.c:152:26: warning: Either the condition '(fp=fopen(output_name,"wb"))==NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    fputc( filesize%256, fp);
                         ^
src/appmake/rex6000.c:143:41: note: Assuming that condition '(fp=fopen(output_name,"wb"))==NULL' is not redundant
    if ( (fp = fopen(output_name,"wb")) == NULL ) {
                                        ^
src/appmake/rex6000.c:152:26: note: Null pointer dereference
    fputc( filesize%256, fp);
                         ^
src/appmake/rex6000.c:153:26: warning: Either the condition '(fp=fopen(output_name,"wb"))==NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    fputc( filesize/256, fp);
                         ^
src/appmake/rex6000.c:143:41: note: Assuming that condition '(fp=fopen(output_name,"wb"))==NULL' is not redundant
    if ( (fp = fopen(output_name,"wb")) == NULL ) {
                                        ^
src/appmake/rex6000.c:153:26: note: Null pointer dereference
    fputc( filesize/256, fp);
                         ^
src/appmake/rex6000.c:155:15: warning: Either the condition '(fp=fopen(output_name,"wb"))==NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    fputc( 0, fp);
              ^
src/appmake/rex6000.c:143:41: note: Assuming that condition '(fp=fopen(output_name,"wb"))==NULL' is not redundant
    if ( (fp = fopen(output_name,"wb")) == NULL ) {
                                        ^
src/appmake/rex6000.c:155:15: note: Null pointer dereference
    fputc( 0, fp);
              ^
src/appmake/rex6000.c:156:15: warning: Either the condition '(fp=fopen(output_name,"wb"))==NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    fputc( 0, fp);
              ^
src/appmake/rex6000.c:143:41: note: Assuming that condition '(fp=fopen(output_name,"wb"))==NULL' is not redundant
    if ( (fp = fopen(output_name,"wb")) == NULL ) {
                                        ^
src/appmake/rex6000.c:156:15: note: Null pointer dereference
    fputc( 0, fp);
              ^
src/appmake/rex6000.c:173:12: warning: Either the condition '(binfile=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: binfile. [nullPointerRedundantCheck]
    fclose(binfile);
           ^
src/appmake/rex6000.c:124:46: note: Assuming that condition '(binfile=fopen_bin(binname,crtfile))==NULL' is not redundant
 if ( (binfile=fopen_bin(binname, crtfile) ) == NULL ) {
                                             ^
src/appmake/rex6000.c:173:12: note: Null pointer dereference
    fclose(binfile);
           ^
src/appmake/rex6000.c:174:12: warning: Either the condition '(fp=fopen(output_name,"wb"))==NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    fclose(fp);
           ^
src/appmake/rex6000.c:143:41: note: Assuming that condition '(fp=fopen(output_name,"wb"))==NULL' is not redundant
    if ( (fp = fopen(output_name,"wb")) == NULL ) {
                                        ^
src/appmake/rex6000.c:174:12: note: Null pointer dereference
    fclose(fp);
           ^
src/appmake/rex6000.c:91:10: style: The scope of the variable 'rem' can be reduced. [variableScope]
    int  rem;
         ^
src/appmake/rex6000.c:92:12: style: The scope of the variable 'c' can be reduced. [variableScope]
    int  i,c;
           ^
src/appmake/rex6000.c:186:11: style: The scope of the variable 'b' can be reduced. [variableScope]
    int i,b,r,c,j;
          ^
src/appmake/rex6000.c:186:13: style: The scope of the variable 'r' can be reduced. [variableScope]
    int i,b,r,c,j;
            ^
src/appmake/rex6000.c:186:17: style: The scope of the variable 'j' can be reduced. [variableScope]
    int i,b,r,c,j;
                ^
src/appmake/rex6000.c:181:29: style:inconclusive: Function 'icon_form' argument 1 names different: declaration 'name' definition 'filen'. [funcArgNamesDifferent]
static void icon_form(char *filen)
                            ^
src/appmake/rex6000.c:78:29: note: Function 'icon_form' argument 1 names different: declaration 'name' definition 'filen'.
static void icon_form(char *name);
                            ^
src/appmake/rex6000.c:181:29: note: Function 'icon_form' argument 1 names different: declaration 'name' definition 'filen'.
static void icon_form(char *filen)
                            ^
src/appmake/rk.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/rk.c:133:12: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/rk.c:97:43: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ( ( fpout = fopen(filename, "wb")) == NULL ) {
                                          ^
src/appmake/rk.c:133:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/rom.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/rom.c:124:13: error: Resource handle 'fpin' freed twice. [doubleFree]
            fclose(fpin);
            ^
src/appmake/rom.c:101:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/rom.c:124:13: note: Resource handle 'fpin' freed twice.
            fclose(fpin);
            ^
src/appmake/rom.c:140:12: warning: Either the condition '(fpout=fopen(outname,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/rom.c:122:40: note: Assuming that condition '(fpout=fopen(outname,"wb"))==NULL' is not redundant
    if ((fpout = fopen(outname, "wb")) == NULL) {
                                       ^
src/appmake/rom.c:140:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/rom.c:240:24: warning: Either the condition '(fpout=fopen(chipname,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
                fclose(fpout);
                       ^
src/appmake/rom.c:229:53: note: Assuming that condition '(fpout=fopen(chipname,"wb"))==NULL' is not redundant
                if ((fpout = fopen(chipname, "wb")) == NULL) {
                                                    ^
src/appmake/rom.c:240:24: note: Null pointer dereference
                fclose(fpout);
                       ^
src/appmake/rom.c:245:20: warning: Either the condition '(fpin=fopen(outname,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
            fclose(fpin);
                   ^
src/appmake/rom.c:222:47: note: Assuming that condition '(fpin=fopen(outname,"rb"))==NULL' is not redundant
            if ((fpin = fopen(outname, "rb")) == NULL)
                                              ^
src/appmake/rom.c:245:20: note: Null pointer dereference
            fclose(fpin);
                   ^
src/appmake/sc3000.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/sc3000.c:152:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/sc3000.c:144:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/sc3000.c:152:15: note: Null pointer dereference
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/sc3000.c:157:17: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    len = ftell(fpin);
                ^
src/appmake/sc3000.c:144:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/sc3000.c:157:17: note: Null pointer dereference
    len = ftell(fpin);
                ^
src/appmake/sc3000.c:158:11: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin, 0, SEEK_SET);
          ^
src/appmake/sc3000.c:144:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/sc3000.c:158:11: note: Null pointer dereference
    fseek(fpin, 0, SEEK_SET);
          ^
src/appmake/sc3000.c:282:12: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/sc3000.c:144:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/sc3000.c:282:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/sc3000.c:283:12: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/sc3000.c:160:41: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ((fpout = fopen(filename, "wb")) == NULL) {
                                        ^
src/appmake/sc3000.c:283:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/sc3000.c:293:19: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/sc3000.c:289:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/sc3000.c:293:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/sc3000.c:297:21: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin);
                    ^
src/appmake/sc3000.c:289:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/sc3000.c:297:21: note: Null pointer dereference
        len = ftell(fpin);
                    ^
src/appmake/sc3000.c:298:15: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0, SEEK_SET);
              ^
src/appmake/sc3000.c:289:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/sc3000.c:298:15: note: Null pointer dereference
        fseek(fpin, 0, SEEK_SET);
              ^
src/appmake/sc3000.c:322:22: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        while (ftell(fpin) < len) {
                     ^
src/appmake/sc3000.c:289:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/sc3000.c:322:22: note: Null pointer dereference
        while (ftell(fpin) < len) {
                     ^
src/appmake/sc3000.c:343:16: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fclose(fpin);
               ^
src/appmake/sc3000.c:289:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/sc3000.c:343:16: note: Null pointer dereference
        fclose(fpin);
               ^
src/appmake/sc3000.c:344:16: warning: Either the condition '(fpout=fopen(wavfile,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fclose(fpout);
               ^
src/appmake/sc3000.c:307:44: note: Assuming that condition '(fpout=fopen(wavfile,"wb"))==NULL' is not redundant
        if ((fpout = fopen(wavfile, "wb")) == NULL) {
                                           ^
src/appmake/sc3000.c:344:16: note: Null pointer dereference
        fclose(fpout);
               ^
src/appmake/sc3000.c:49:9: style: The scope of the variable 'i' can be reduced. [variableScope]
    int i, period0, period1;
        ^
src/appmake/sc3000.c:49:12: style: The scope of the variable 'period0' can be reduced. [variableScope]
    int i, period0, period1;
           ^
src/appmake/sc3000.c:49:21: style: The scope of the variable 'period1' can be reduced. [variableScope]
    int i, period0, period1;
                    ^
src/appmake/sc3000.c:112:10: style: The scope of the variable 'wavfile' can be reduced. [variableScope]
    char wavfile[FILENAME_MAX + 1];
         ^
src/appmake/sc3000.c:115:17: style: The scope of the variable 'blocklen' can be reduced. [variableScope]
    long pos=0, blocklen;
                ^
src/appmake/smc777.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/smc777.c:74:5: error: Resource handle 'bootstrap_fp' freed twice. [doubleFree]
    fclose(bootstrap_fp);
    ^
src/appmake/smc777.c:61:9: note: Resource handle 'bootstrap_fp' freed twice.
        fclose(bootstrap_fp);
        ^
src/appmake/smc777.c:74:5: note: Resource handle 'bootstrap_fp' freed twice.
    fclose(bootstrap_fp);
    ^
src/appmake/smc777.c:90:44: error: Resource handle 'fpin' freed twice. [doubleFree]
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                           ^
src/appmake/smc777.c:83:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/smc777.c:90:44: note: Resource handle 'fpin' freed twice.
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                           ^
src/appmake/smc777.c:91:5: error: Resource handle 'fpin' freed twice. [doubleFree]
    fclose(fpin);
    ^
src/appmake/smc777.c:83:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/smc777.c:91:5: note: Resource handle 'fpin' freed twice.
    fclose(fpin);
    ^
src/appmake/smc777.c:60:16: warning: Either the condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: bootstrap_fp. [nullPointerRedundantCheck]
    if ( fseek(bootstrap_fp,0,SEEK_END) ) {
               ^
src/appmake/smc777.c:57:55: note: Assuming that condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (bootstrap_fp=fopen_bin(bootname, crtfile) ) == NULL ) {
                                                      ^
src/appmake/smc777.c:60:16: note: Null pointer dereference
    if ( fseek(bootstrap_fp,0,SEEK_END) ) {
               ^
src/appmake/smc777.c:64:21: warning: Either the condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: bootstrap_fp. [nullPointerRedundantCheck]
    bootlen = ftell(bootstrap_fp);
                    ^
src/appmake/smc777.c:57:55: note: Assuming that condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (bootstrap_fp=fopen_bin(bootname, crtfile) ) == NULL ) {
                                                      ^
src/appmake/smc777.c:64:21: note: Null pointer dereference
    bootlen = ftell(bootstrap_fp);
                    ^
src/appmake/smc777.c:65:11: warning: Either the condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: bootstrap_fp. [nullPointerRedundantCheck]
    fseek(bootstrap_fp,0L,SEEK_SET);
          ^
src/appmake/smc777.c:57:55: note: Assuming that condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (bootstrap_fp=fopen_bin(bootname, crtfile) ) == NULL ) {
                                                      ^
src/appmake/smc777.c:65:11: note: Null pointer dereference
    fseek(bootstrap_fp,0L,SEEK_SET);
          ^
src/appmake/smc777.c:71:37: warning: Either the condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: bootstrap_fp. [nullPointerRedundantCheck]
    if ( fread(bootbuf, 1, bootlen, bootstrap_fp) != bootlen ) {
                                    ^
src/appmake/smc777.c:57:55: note: Assuming that condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (bootstrap_fp=fopen_bin(bootname, crtfile) ) == NULL ) {
                                                      ^
src/appmake/smc777.c:71:37: note: Null pointer dereference
    if ( fread(bootbuf, 1, bootlen, bootstrap_fp) != bootlen ) {
                                    ^
src/appmake/smc777.c:74:12: warning: Either the condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: bootstrap_fp. [nullPointerRedundantCheck]
    fclose(bootstrap_fp);
           ^
src/appmake/smc777.c:57:55: note: Assuming that condition '(bootstrap_fp=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (bootstrap_fp=fopen_bin(bootname, crtfile) ) == NULL ) {
                                                      ^
src/appmake/smc777.c:74:12: note: Null pointer dereference
    fclose(bootstrap_fp);
           ^
src/appmake/smc777.c:82:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/smc777.c:78:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/smc777.c:82:15: note: Null pointer dereference
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/smc777.c:87:17: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    pos = ftell(fpin);
                ^
src/appmake/smc777.c:78:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/smc777.c:87:17: note: Null pointer dereference
    pos = ftell(fpin);
                ^
src/appmake/smc777.c:88:11: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/smc777.c:78:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/smc777.c:88:11: note: Null pointer dereference
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/smc777.c:90:35: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                  ^
src/appmake/smc777.c:78:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/smc777.c:90:35: note: Null pointer dereference
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                  ^
src/appmake/smc777.c:91:12: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/smc777.c:78:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/smc777.c:91:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/sms.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/sms.c:140:9: style: Condition 'sega_present' is always true [knownConditionTrueFalse]
    if (sega_present && (len > SMS_HEADER_ADDR))
        ^
src/appmake/sms.c:81:20: note: Assignment 'sega_present=1', assigned value is 1
    sega_present = 1;
                   ^
src/appmake/sms.c:140:9: note: Condition 'sega_present' is always true
    if (sega_present && (len > SMS_HEADER_ADDR))
        ^
src/appmake/sms.c:136:9: error: Resource handle 'fpin' freed twice. [doubleFree]
        fclose(fpin);
        ^
src/appmake/sms.c:130:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/sms.c:136:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/sms.c:155:63: error: Resource handle 'fpin' freed twice. [doubleFree]
    if (len != fread(memory, sizeof(memory[0]), len, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                                              ^
src/appmake/sms.c:130:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/sms.c:155:63: note: Resource handle 'fpin' freed twice.
    if (len != fread(memory, sizeof(memory[0]), len, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                                              ^
src/appmake/sms.c:157:5: error: Resource handle 'fpin' freed twice. [doubleFree]
    fclose(fpin);
    ^
src/appmake/sms.c:130:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/sms.c:157:5: note: Resource handle 'fpin' freed twice.
    fclose(fpin);
    ^
src/appmake/sms.c:134:22: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if ((len = ftell(fpin)) > 0xc000)
                     ^
src/appmake/sms.c:126:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL)
                                             ^
src/appmake/sms.c:134:22: note: Null pointer dereference
    if ((len = ftell(fpin)) > 0xc000)
                     ^
src/appmake/sms.c:63:9: style: The scope of the variable 'checksum' can be reduced. [variableScope]
    int checksum, len, sdsc_present, sega_present, i, c, count;
        ^
src/appmake/sol20.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/sol20.c:127:12: warning: Either the condition '(input=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: input. [nullPointerRedundantCheck]
    fclose(input);
           ^
src/appmake/sol20.c:56:47: note: Assuming that condition '(input=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( (input=fopen_bin(binname, crtfile) ) == NULL ) {
                                              ^
src/appmake/sol20.c:127:12: note: Null pointer dereference
    fclose(input);
           ^
src/appmake/sol20.c:128:12: warning: Either the condition '(output=fopen(filename,"w"))==NULL' is redundant or there is possible null pointer dereference: output. [nullPointerRedundantCheck]
    fclose(output);
           ^
src/appmake/sol20.c:60:42: note: Assuming that condition '(output=fopen(filename,"w"))==NULL' is not redundant
    if ( (output = fopen(filename,"w") ) == NULL ) {
                                         ^
src/appmake/sol20.c:128:12: note: Null pointer dereference
    fclose(output);
           ^
src/appmake/sorcerer.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/sorcerer.c:253:13: error: Resource handle 'fpin' freed twice. [doubleFree]
            fclose(fpin);
            ^
src/appmake/sorcerer.c:244:13: note: Resource handle 'fpin' freed twice.
            fclose(fpin);
            ^
src/appmake/sorcerer.c:253:13: note: Resource handle 'fpin' freed twice.
            fclose(fpin);
            ^
src/appmake/sorcerer.c:243:19: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/sorcerer.c:239:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/sorcerer.c:243:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/sorcerer.c:248:21: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin);
                    ^
src/appmake/sorcerer.c:239:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/sorcerer.c:248:21: note: Null pointer dereference
        len = ftell(fpin);
                    ^
src/appmake/sorcerer.c:250:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/sorcerer.c:239:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/sorcerer.c:250:15: note: Null pointer dereference
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/sorcerer.c:348:16: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fclose(fpin);
               ^
src/appmake/sorcerer.c:239:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/sorcerer.c:348:16: note: Null pointer dereference
        fclose(fpin);
               ^
src/appmake/sorcerer.c:349:16: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fclose(fpout);
               ^
src/appmake/sorcerer.c:252:45: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
        if ((fpout = fopen(filename, "wb")) == NULL) {
                                            ^
src/appmake/sorcerer.c:349:16: note: Null pointer dereference
        fclose(fpout);
               ^
src/appmake/sorcerer.c:360:19: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/sorcerer.c:356:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/sorcerer.c:360:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/sorcerer.c:364:21: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin);
                    ^
src/appmake/sorcerer.c:356:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/sorcerer.c:364:21: note: Null pointer dereference
        len = ftell(fpin);
                    ^
src/appmake/sorcerer.c:365:15: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0, SEEK_SET);
              ^
src/appmake/sorcerer.c:356:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/sorcerer.c:365:15: note: Null pointer dereference
        fseek(fpin, 0, SEEK_SET);
              ^
src/appmake/sorcerer.c:184:10: style: The scope of the variable 'wavfile' can be reduced. [variableScope]
    char wavfile[FILENAME_MAX + 1];
         ^
src/appmake/sorcerer.c:185:10: style: The scope of the variable 'name' can be reduced. [variableScope]
    char name[7];
         ^
src/appmake/sorcerer.c:189:10: style: The scope of the variable 'pos' can be reduced. [variableScope]
    long pos;
         ^
src/appmake/sos.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/sos.c:80:9: error: Resource handle 'fpin' freed twice. [doubleFree]
        fclose(fpin);
        ^
src/appmake/sos.c:71:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/sos.c:80:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/sos.c:70:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/sos.c:66:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/sos.c:70:15: note: Null pointer dereference
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/sos.c:75:17: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    len = ftell(fpin);
                ^
src/appmake/sos.c:66:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/sos.c:75:17: note: Null pointer dereference
    len = ftell(fpin);
                ^
src/appmake/sos.c:77:11: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/sos.c:66:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/sos.c:77:11: note: Null pointer dereference
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/sos.c:84:13: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fprintf(fpout, "_SOS 01 %4X %4X%c", (int)pos, (int)pos, 10);
            ^
src/appmake/sos.c:79:41: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ((fpout = fopen(filename, "wb")) == NULL) {
                                        ^
src/appmake/sos.c:84:13: note: Null pointer dereference
    fprintf(fpout, "_SOS 01 %4X %4X%c", (int)pos, (int)pos, 10);
            ^
src/appmake/sos.c:91:12: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/sos.c:66:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/sos.c:91:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/sos.c:92:12: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/sos.c:79:41: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ((fpout = fopen(filename, "wb")) == NULL) {
                                        ^
src/appmake/sos.c:92:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/sos.c:42:9: style: The scope of the variable 'c' can be reduced. [variableScope]
    int c, i;
        ^
src/appmake/spc1000.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/spc1000.c:72:9: error: Resource handle 'fpin' freed twice. [doubleFree]
        fclose(fpin);
        ^
src/appmake/spc1000.c:63:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/spc1000.c:72:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/spc1000.c:62:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/spc1000.c:57:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/spc1000.c:62:15: note: Null pointer dereference
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/spc1000.c:67:17: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    len = ftell(fpin);
                ^
src/appmake/spc1000.c:57:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/spc1000.c:67:17: note: Null pointer dereference
    len = ftell(fpin);
                ^
src/appmake/spc1000.c:69:11: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/spc1000.c:57:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/spc1000.c:69:11: note: Null pointer dereference
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/spc1000.c:125:12: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/spc1000.c:57:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/spc1000.c:125:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/spc1000.c:126:12: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/spc1000.c:71:41: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ((fpout = fopen(filename, "wb")) == NULL) {
                                        ^
src/appmake/spc1000.c:126:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/svi.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/svi.c:352:53: error: Resource handle 'fpin' freed twice. [doubleFree]
    if (binlen != fread(sectorbuf, 1, 128, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",bootname); }
                                                    ^
src/appmake/svi.c:342:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/svi.c:352:53: note: Resource handle 'fpin' freed twice.
    if (binlen != fread(sectorbuf, 1, 128, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",bootname); }
                                                    ^
src/appmake/svi.c:353:5: error: Resource handle 'fpin' freed twice. [doubleFree]
    fclose(fpin);
    ^
src/appmake/svi.c:342:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/svi.c:353:5: note: Resource handle 'fpin' freed twice.
    fclose(fpin);
    ^
src/appmake/svi.c:179:19: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/svi.c:171:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/svi.c:179:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/svi.c:184:21: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin);
                    ^
src/appmake/svi.c:171:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/svi.c:184:21: note: Null pointer dereference
        len = ftell(fpin);
                    ^
src/appmake/svi.c:186:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/svi.c:171:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/svi.c:186:15: note: Null pointer dereference
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/svi.c:238:19: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/svi.c:234:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/svi.c:238:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/svi.c:242:21: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin);
                    ^
src/appmake/svi.c:234:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/svi.c:242:21: note: Null pointer dereference
        len = ftell(fpin);
                    ^
src/appmake/svi.c:243:15: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0, SEEK_SET);
              ^
src/appmake/svi.c:234:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/svi.c:243:15: note: Null pointer dereference
        fseek(fpin, 0, SEEK_SET);
              ^
src/appmake/svi.c:303:16: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fclose(fpin);
               ^
src/appmake/svi.c:234:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/svi.c:303:16: note: Null pointer dereference
        fclose(fpin);
               ^
src/appmake/svi.c:304:16: warning: Either the condition '(fpout=fopen(wavfile,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fclose(fpout);
               ^
src/appmake/svi.c:249:44: note: Assuming that condition '(fpout=fopen(wavfile,"wb"))==NULL' is not redundant
        if ((fpout = fopen(wavfile, "wb")) == NULL) {
                                           ^
src/appmake/svi.c:304:16: note: Null pointer dereference
        fclose(fpout);
               ^
src/appmake/svi.c:341:16: warning: Either the condition '(fpin=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if ( fseek(fpin,0,SEEK_END) ) {
               ^
src/appmake/svi.c:338:47: note: Assuming that condition '(fpin=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (fpin=fopen_bin(bootname, crtfile) ) == NULL ) {
                                              ^
src/appmake/svi.c:341:16: note: Null pointer dereference
    if ( fseek(fpin,0,SEEK_END) ) {
               ^
src/appmake/svi.c:345:20: warning: Either the condition '(fpin=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    binlen = ftell(fpin);
                   ^
src/appmake/svi.c:338:47: note: Assuming that condition '(fpin=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (fpin=fopen_bin(bootname, crtfile) ) == NULL ) {
                                              ^
src/appmake/svi.c:345:20: note: Null pointer dereference
    binlen = ftell(fpin);
                   ^
src/appmake/svi.c:346:11: warning: Either the condition '(fpin=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin,0L,SEEK_SET);
          ^
src/appmake/svi.c:338:47: note: Assuming that condition '(fpin=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (fpin=fopen_bin(bootname, crtfile) ) == NULL ) {
                                              ^
src/appmake/svi.c:346:11: note: Null pointer dereference
    fseek(fpin,0L,SEEK_SET);
          ^
src/appmake/svi.c:352:44: warning: Either the condition '(fpin=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (binlen != fread(sectorbuf, 1, 128, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",bootname); }
                                           ^
src/appmake/svi.c:338:47: note: Assuming that condition '(fpin=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (fpin=fopen_bin(bootname, crtfile) ) == NULL ) {
                                              ^
src/appmake/svi.c:352:44: note: Null pointer dereference
    if (binlen != fread(sectorbuf, 1, 128, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",bootname); }
                                           ^
src/appmake/svi.c:353:12: warning: Either the condition '(fpin=fopen_bin(bootname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/svi.c:338:47: note: Assuming that condition '(fpin=fopen_bin(bootname,crtfile))==NULL' is not redundant
    if ( (fpin=fopen_bin(bootname, crtfile) ) == NULL ) {
                                              ^
src/appmake/svi.c:353:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/svi.c:364:31: warning: Either the condition '(fpout=fopen(disc_name,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fwrite(sectorbuf, 1, 128, fpout); // Track 0, sector 0
                              ^
src/appmake/svi.c:355:43: note: Assuming that condition '(fpout=fopen(disc_name,"wb"))==NULL' is not redundant
    if ( (fpout = fopen(disc_name, "wb")) == NULL ) {
                                          ^
src/appmake/svi.c:364:31: note: Null pointer dereference
    fwrite(sectorbuf, 1, 128, fpout); // Track 0, sector 0
                              ^
src/appmake/svi.c:377:12: warning: Either the condition '(fpout=fopen(disc_name,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/svi.c:355:43: note: Assuming that condition '(fpout=fopen(disc_name,"wb"))==NULL' is not redundant
    if ( (fpout = fopen(disc_name, "wb")) == NULL ) {
                                          ^
src/appmake/svi.c:377:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/svi.c:378:12: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/svi.c:359:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/svi.c:378:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/svi.c:121:10: style: The scope of the variable 'wavfile' can be reduced. [variableScope]
    char wavfile[FILENAME_MAX + 1];
         ^
src/appmake/svi.c:122:10: style: The scope of the variable 'name' can be reduced. [variableScope]
    char name[11];
         ^
src/appmake/svi.c:265:15: style: Variable 'c' is assigned a value that is never used. [unreadVariable]
            c = getc(fpin);
              ^
src/appmake/tixx.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 21 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/tixx.c:197:5: error: Resource handle 'fp' freed twice. [doubleFree]
    fclose(fp);
    ^
src/appmake/tixx.c:194:38: note: Resource handle 'fp' freed twice.
    if (1 != fread(buf, n, 1, fp)) { fclose(fp); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                     ^
src/appmake/tixx.c:197:5: note: Resource handle 'fp' freed twice.
    fclose(fp);
    ^
src/appmake/tixx.c:69:15: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    p = ftell(fp);
              ^
src/appmake/tixx.c:190:9: note: Assuming that condition '!fp' is not redundant
    if (!fp)
        ^
src/appmake/tixx.c:192:15: note: Calling function 'fsize', 1st argument 'fp' value is 0
    n = fsize(fp);
              ^
src/appmake/tixx.c:69:15: note: Null pointer dereference
    p = ftell(fp);
              ^
src/appmake/tixx.c:70:11: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    fseek(fp, 0L, SEEK_END);
          ^
src/appmake/tixx.c:190:9: note: Assuming that condition '!fp' is not redundant
    if (!fp)
        ^
src/appmake/tixx.c:192:15: note: Calling function 'fsize', 1st argument 'fp' value is 0
    n = fsize(fp);
              ^
src/appmake/tixx.c:70:11: note: Null pointer dereference
    fseek(fp, 0L, SEEK_END);
          ^
src/appmake/tixx.c:71:18: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    size = ftell(fp);
                 ^
src/appmake/tixx.c:190:9: note: Assuming that condition '!fp' is not redundant
    if (!fp)
        ^
src/appmake/tixx.c:192:15: note: Calling function 'fsize', 1st argument 'fp' value is 0
    n = fsize(fp);
              ^
src/appmake/tixx.c:71:18: note: Null pointer dereference
    size = ftell(fp);
                 ^
src/appmake/tixx.c:72:11: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    fseek(fp, p, SEEK_SET);
          ^
src/appmake/tixx.c:190:9: note: Assuming that condition '!fp' is not redundant
    if (!fp)
        ^
src/appmake/tixx.c:192:15: note: Calling function 'fsize', 1st argument 'fp' value is 0
    n = fsize(fp);
              ^
src/appmake/tixx.c:72:11: note: Null pointer dereference
    fseek(fp, p, SEEK_SET);
          ^
src/appmake/tixx.c:104:41: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    fwrite(comment, strlen(comment), 1, fp);
                                        ^
src/appmake/tixx.c:199:9: note: Assuming that condition '!fp' is not redundant
    if (!fp)
        ^
src/appmake/tixx.c:215:18: note: Calling function 'writecomment', 1st argument 'fp' value is 0
    writecomment(fp, comment);
                 ^
src/appmake/tixx.c:104:41: note: Null pointer dereference
    fwrite(comment, strlen(comment), 1, fp);
                                        ^
src/appmake/tixx.c:106:42: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    fwrite(str, 42 - strlen(comment), 1, fp);
                                         ^
src/appmake/tixx.c:199:9: note: Assuming that condition '!fp' is not redundant
    if (!fp)
        ^
src/appmake/tixx.c:215:18: note: Calling function 'writecomment', 1st argument 'fp' value is 0
    writecomment(fp, comment);
                 ^
src/appmake/tixx.c:106:42: note: Null pointer dereference
    fwrite(str, 42 - strlen(comment), 1, fp);
                                         ^
src/appmake/tixx.c:194:31: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    if (1 != fread(buf, n, 1, fp)) { fclose(fp); exit_log(1, "Could not read required data from <%s>\n",binname); }
                              ^
src/appmake/tixx.c:190:9: note: Assuming that condition '!fp' is not redundant
    if (!fp)
        ^
src/appmake/tixx.c:194:31: note: Null pointer dereference
    if (1 != fread(buf, n, 1, fp)) { fclose(fp); exit_log(1, "Could not read required data from <%s>\n",binname); }
                              ^
src/appmake/tixx.c:195:16: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    if (ferror(fp))
               ^
src/appmake/tixx.c:190:9: note: Assuming that condition '!fp' is not redundant
    if (!fp)
        ^
src/appmake/tixx.c:195:16: note: Null pointer dereference
    if (ferror(fp))
               ^
src/appmake/tixx.c:197:12: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    fclose(fp);
           ^
src/appmake/tixx.c:190:9: note: Assuming that condition '!fp' is not redundant
    if (!fp)
        ^
src/appmake/tixx.c:197:12: note: Null pointer dereference
    fclose(fp);
           ^
src/appmake/trs80.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/trs80.c:290:9: error: Resource handle 'fpin' freed twice. [doubleFree]
        fclose(fpin);
        ^
src/appmake/trs80.c:191:13: note: Resource handle 'fpin' freed twice.
            fclose(fpin);
            ^
src/appmake/trs80.c:290:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/trs80.c:190:19: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/trs80.c:182:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/trs80.c:190:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/trs80.c:195:21: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin);
                    ^
src/appmake/trs80.c:182:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/trs80.c:195:21: note: Null pointer dereference
        len = ftell(fpin);
                    ^
src/appmake/trs80.c:197:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/trs80.c:182:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/trs80.c:197:15: note: Null pointer dereference
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/trs80.c:290:16: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fclose(fpin);
               ^
src/appmake/trs80.c:182:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/trs80.c:290:16: note: Null pointer dereference
        fclose(fpin);
               ^
src/appmake/trs80.c:291:16: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fclose(fpout);
               ^
src/appmake/trs80.c:203:45: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
        if ((fpout = fopen(filename, "wb")) == NULL) {
                                            ^
src/appmake/trs80.c:291:16: note: Null pointer dereference
        fclose(fpout);
               ^
src/appmake/trs80.c:302:19: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/trs80.c:298:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/trs80.c:302:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/trs80.c:306:21: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin);
                    ^
src/appmake/trs80.c:298:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/trs80.c:306:21: note: Null pointer dereference
        len = ftell(fpin);
                    ^
src/appmake/trs80.c:307:15: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0, SEEK_SET);
              ^
src/appmake/trs80.c:298:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/trs80.c:307:15: note: Null pointer dereference
        fseek(fpin, 0, SEEK_SET);
              ^
src/appmake/trs80.c:131:10: style: The scope of the variable 'wavfile' can be reduced. [variableScope]
    char wavfile[FILENAME_MAX + 1];
         ^
src/appmake/trs80.c:132:10: style: The scope of the variable 'name' can be reduced. [variableScope]
    char name[11];
         ^
src/appmake/trs80.c:138:19: style: The scope of the variable 'cksum' can be reduced. [variableScope]
    unsigned char cksum = 0;
                  ^
src/appmake/trs80.c:139:10: style: The scope of the variable 'ckflag' can be reduced. [variableScope]
    char ckflag = 0;
         ^
src/appmake/tvc.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/tvc.c:99:9: error: Resource handle 'fpin' freed twice. [doubleFree]
        fclose(fpin);
        ^
src/appmake/tvc.c:90:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/tvc.c:99:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/tvc.c:89:15: warning: Either the condition '(fpin=fopen_bin(binname,NULL))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin,0,SEEK_END)) {
              ^
src/appmake/tvc.c:84:40: note: Assuming that condition '(fpin=fopen_bin(binname,NULL))==NULL' is not redundant
 if ( (fpin=fopen_bin(binname, NULL) ) == NULL ) {
                                       ^
src/appmake/tvc.c:89:15: note: Null pointer dereference
    if (fseek(fpin,0,SEEK_END)) {
              ^
src/appmake/tvc.c:94:15: warning: Either the condition '(fpin=fopen_bin(binname,NULL))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    len=ftell(fpin);
              ^
src/appmake/tvc.c:84:40: note: Assuming that condition '(fpin=fopen_bin(binname,NULL))==NULL' is not redundant
 if ( (fpin=fopen_bin(binname, NULL) ) == NULL ) {
                                       ^
src/appmake/tvc.c:94:15: note: Null pointer dereference
    len=ftell(fpin);
              ^
src/appmake/tvc.c:96:11: warning: Either the condition '(fpin=fopen_bin(binname,NULL))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin,0L,SEEK_SET);
          ^
src/appmake/tvc.c:84:40: note: Assuming that condition '(fpin=fopen_bin(binname,NULL))==NULL' is not redundant
 if ( (fpin=fopen_bin(binname, NULL) ) == NULL ) {
                                       ^
src/appmake/tvc.c:96:11: note: Null pointer dereference
    fseek(fpin,0L,SEEK_SET);
          ^
src/appmake/tvc.c:128:12: warning: Either the condition '(fpin=fopen_bin(binname,NULL))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/tvc.c:84:40: note: Assuming that condition '(fpin=fopen_bin(binname,NULL))==NULL' is not redundant
 if ( (fpin=fopen_bin(binname, NULL) ) == NULL ) {
                                       ^
src/appmake/tvc.c:128:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/tvc.c:129:12: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/tvc.c:98:40: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                       ^
src/appmake/tvc.c:129:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/tvc.c:68:13: style: The scope of the variable 'c' can be reduced. [variableScope]
    int     c,i;
            ^
src/appmake/tvc.c:107:13: style: Local variable 'i' shadows outer variable [shadowVariable]
    for(int i=0x05; i<0x80; i++) { // padding to 0x7f (inclusive)
            ^
src/appmake/tvc.c:68:15: note: Shadowed declaration
    int     c,i;
              ^
src/appmake/tvc.c:107:13: note: Shadow variable
    for(int i=0x05; i<0x80; i++) { // padding to 0x7f (inclusive)
            ^
src/appmake/tvc.c:114:10: style: Local variable 'i' shadows outer variable [shadowVariable]
 for(int i=0x85; i<0x8f; i++) { // padding to 0x8e (inclusive)
         ^
src/appmake/tvc.c:68:15: note: Shadowed declaration
    int     c,i;
              ^
src/appmake/tvc.c:114:10: note: Shadow variable
 for(int i=0x85; i<0x8f; i++) { // padding to 0x8e (inclusive)
         ^
src/appmake/vector06c.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/vector06c.c:56:44: error: Resource handle 'fpin' freed twice. [doubleFree]
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                           ^
src/appmake/vector06c.c:49:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/vector06c.c:56:44: note: Resource handle 'fpin' freed twice.
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                           ^
src/appmake/vector06c.c:57:5: error: Resource handle 'fpin' freed twice. [doubleFree]
    fclose(fpin);
    ^
src/appmake/vector06c.c:49:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/vector06c.c:57:5: note: Resource handle 'fpin' freed twice.
    fclose(fpin);
    ^
src/appmake/vector06c.c:48:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/vector06c.c:44:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/vector06c.c:48:15: note: Null pointer dereference
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/vector06c.c:53:17: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    pos = ftell(fpin);
                ^
src/appmake/vector06c.c:44:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/vector06c.c:53:17: note: Null pointer dereference
    pos = ftell(fpin);
                ^
src/appmake/vector06c.c:54:11: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/vector06c.c:44:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/vector06c.c:54:11: note: Null pointer dereference
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/vector06c.c:56:35: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                  ^
src/appmake/vector06c.c:44:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/vector06c.c:56:35: note: Null pointer dereference
    if (pos != fread(buf, 1, pos, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                  ^
src/appmake/vector06c.c:57:12: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/vector06c.c:44:49: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ( ( fpin = fopen_bin(binname, crtfile) ) == NULL ) {
                                                ^
src/appmake/vector06c.c:57:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/vg5k.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/vg5k.c:181:19: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/vg5k.c:177:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/vg5k.c:181:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/vg5k.c:186:21: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin);
                    ^
src/appmake/vg5k.c:177:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/vg5k.c:186:21: note: Null pointer dereference
        len = ftell(fpin);
                    ^
src/appmake/vg5k.c:188:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/vg5k.c:177:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/vg5k.c:188:15: note: Null pointer dereference
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/vg5k.c:200:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/vg5k.c:177:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/vg5k.c:200:15: note: Null pointer dereference
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/vg5k.c:275:16: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fclose(fpin);
               ^
src/appmake/vg5k.c:177:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/vg5k.c:275:16: note: Null pointer dereference
        fclose(fpin);
               ^
src/appmake/vg5k.c:276:16: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fclose(fpout);
               ^
src/appmake/vg5k.c:202:45: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
        if ((fpout = fopen(filename, "wb")) == NULL) {
                                            ^
src/appmake/vg5k.c:276:16: note: Null pointer dereference
        fclose(fpout);
               ^
src/appmake/vg5k.c:287:19: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/vg5k.c:283:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/vg5k.c:287:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/vg5k.c:291:21: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin);
                    ^
src/appmake/vg5k.c:283:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/vg5k.c:291:21: note: Null pointer dereference
        len = ftell(fpin);
                    ^
src/appmake/vg5k.c:292:15: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0, SEEK_SET);
              ^
src/appmake/vg5k.c:283:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/vg5k.c:292:15: note: Null pointer dereference
        fseek(fpin, 0, SEEK_SET);
              ^
src/appmake/vg5k.c:356:16: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fclose(fpin);
               ^
src/appmake/vg5k.c:283:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/vg5k.c:356:16: note: Null pointer dereference
        fclose(fpin);
               ^
src/appmake/vg5k.c:357:16: warning: Either the condition '(fpout=fopen(wavfile,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fclose(fpout);
               ^
src/appmake/vg5k.c:298:44: note: Assuming that condition '(fpout=fopen(wavfile,"wb"))==NULL' is not redundant
        if ((fpout = fopen(wavfile, "wb")) == NULL) {
                                           ^
src/appmake/vg5k.c:357:16: note: Null pointer dereference
        fclose(fpout);
               ^
src/appmake/vg5k.c:127:10: style: The scope of the variable 'wavfile' can be reduced. [variableScope]
    char wavfile[FILENAME_MAX + 1];
         ^
src/appmake/vg5k.c:128:10: style: The scope of the variable 'name' can be reduced. [variableScope]
    char name[8];
         ^
src/appmake/vg5k.c:132:10: style: The scope of the variable 'pos' can be reduced. [variableScope]
    long pos;
         ^
src/appmake/vg5k.c:133:19: style: The scope of the variable 'checksum' can be reduced. [variableScope]
    unsigned long checksum;
                  ^
src/appmake/vg5k.c:134:15: style: The scope of the variable 'j' can be reduced. [variableScope]
    int c, i, j;
              ^
src/appmake/vz.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/vz.c:154:9: error: Resource handle 'fpin' freed twice. [doubleFree]
        fclose(fpin);
        ^
src/appmake/vz.c:138:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/vz.c:154:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/vz.c:137:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/vz.c:129:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/vz.c:137:15: note: Null pointer dereference
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/vz.c:143:17: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    len = ftell(fpin);
                ^
src/appmake/vz.c:129:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/vz.c:143:17: note: Null pointer dereference
    len = ftell(fpin);
                ^
src/appmake/vz.c:205:12: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/vz.c:129:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/vz.c:205:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/vz.c:206:12: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/vz.c:153:41: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ((fpout = fopen(filename, "wb")) == NULL) {
                                        ^
src/appmake/vz.c:206:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/vz.c:216:19: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/vz.c:212:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/vz.c:216:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/vz.c:220:21: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin);
                    ^
src/appmake/vz.c:212:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/vz.c:220:21: note: Null pointer dereference
        len = ftell(fpin);
                    ^
src/appmake/vz.c:221:15: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/vz.c:212:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/vz.c:221:15: note: Null pointer dereference
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/vz.c:276:16: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fclose(fpin);
               ^
src/appmake/vz.c:212:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/vz.c:276:16: note: Null pointer dereference
        fclose(fpin);
               ^
src/appmake/vz.c:277:16: warning: Either the condition '(fpout=fopen(wavfile,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fclose(fpout);
               ^
src/appmake/vz.c:225:44: note: Assuming that condition '(fpout=fopen(wavfile,"wb"))==NULL' is not redundant
        if ((fpout = fopen(wavfile, "wb")) == NULL) {
                                           ^
src/appmake/vz.c:277:16: note: Null pointer dereference
        fclose(fpout);
               ^
src/appmake/vz.c:102:10: style: The scope of the variable 'wavfile' can be reduced. [variableScope]
    char wavfile[FILENAME_MAX + 1];
         ^
src/appmake/vz.c:107:14: style: The scope of the variable 'hdlen' can be reduced. [variableScope]
    int len, hdlen;
             ^
src/appmake/x07.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/x07.c:154:19: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/x07.c:146:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/x07.c:154:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/x07.c:159:21: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin);
                    ^
src/appmake/x07.c:146:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/x07.c:159:21: note: Null pointer dereference
        len = ftell(fpin);
                    ^
src/appmake/x07.c:160:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0, SEEK_SET);
              ^
src/appmake/x07.c:146:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/x07.c:160:15: note: Null pointer dereference
        fseek(fpin, 0, SEEK_SET);
              ^
src/appmake/x07.c:300:16: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fclose(fpin);
               ^
src/appmake/x07.c:146:50: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                                 ^
src/appmake/x07.c:300:16: note: Null pointer dereference
        fclose(fpin);
               ^
src/appmake/x07.c:301:16: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fclose(fpout);
               ^
src/appmake/x07.c:162:45: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
        if ((fpout = fopen(filename, "wb")) == NULL) {
                                            ^
src/appmake/x07.c:181:17: note: Assuming condition is true
        if (pos == 1380) {
                ^
src/appmake/x07.c:301:16: note: Null pointer dereference
        fclose(fpout);
               ^
src/appmake/x07.c:312:19: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/x07.c:308:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/x07.c:312:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/x07.c:316:21: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin);
                    ^
src/appmake/x07.c:308:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/x07.c:316:21: note: Null pointer dereference
        len = ftell(fpin);
                    ^
src/appmake/x07.c:317:15: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0, SEEK_SET);
              ^
src/appmake/x07.c:308:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/x07.c:317:15: note: Null pointer dereference
        fseek(fpin, 0, SEEK_SET);
              ^
src/appmake/x07.c:365:16: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fclose(fpin);
               ^
src/appmake/x07.c:308:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/x07.c:365:16: note: Null pointer dereference
        fclose(fpin);
               ^
src/appmake/x07.c:372:23: warning: Either the condition '(fpin=fopen(filename2,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
            if (fseek(fpin, 0, SEEK_END)) {
                      ^
src/appmake/x07.c:368:49: note: Assuming that condition '(fpin=fopen(filename2,"rb"))==NULL' is not redundant
            if ((fpin = fopen(filename2, "rb")) == NULL) {
                                                ^
src/appmake/x07.c:372:23: note: Null pointer dereference
            if (fseek(fpin, 0, SEEK_END)) {
                      ^
src/appmake/x07.c:376:25: warning: Either the condition '(fpin=fopen(filename2,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
            len = ftell(fpin);
                        ^
src/appmake/x07.c:368:49: note: Assuming that condition '(fpin=fopen(filename2,"rb"))==NULL' is not redundant
            if ((fpin = fopen(filename2, "rb")) == NULL) {
                                                ^
src/appmake/x07.c:376:25: note: Null pointer dereference
            len = ftell(fpin);
                        ^
src/appmake/x07.c:377:19: warning: Either the condition '(fpin=fopen(filename2,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
            fseek(fpin, 0, SEEK_SET);
                  ^
src/appmake/x07.c:368:49: note: Assuming that condition '(fpin=fopen(filename2,"rb"))==NULL' is not redundant
            if ((fpin = fopen(filename2, "rb")) == NULL) {
                                                ^
src/appmake/x07.c:377:19: note: Null pointer dereference
            fseek(fpin, 0, SEEK_SET);
                  ^
src/appmake/x07.c:401:16: warning: Either the condition '(fpout=fopen(wavfile,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fclose(fpout);
               ^
src/appmake/x07.c:323:44: note: Assuming that condition '(fpout=fopen(wavfile,"wb"))==NULL' is not redundant
        if ((fpout = fopen(wavfile, "wb")) == NULL) {
                                           ^
src/appmake/x07.c:401:16: note: Null pointer dereference
        fclose(fpout);
               ^
src/appmake/x07.c:105:10: style: The scope of the variable 'wavfile' can be reduced. [variableScope]
    char wavfile[FILENAME_MAX + 1];
         ^
src/appmake/x07.c:106:10: style: The scope of the variable 'name' can be reduced. [variableScope]
    char name[7];
         ^
src/appmake/x07.c:107:10: style: The scope of the variable 'addr' can be reduced. [variableScope]
    char addr[7];
         ^
src/appmake/x1.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/x1.c:101:44: error: Resource handle 'fpin' freed twice. [doubleFree]
    if (len != fread(buf, 1, len, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                           ^
src/appmake/x1.c:93:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/x1.c:101:44: note: Resource handle 'fpin' freed twice.
    if (len != fread(buf, 1, len, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                           ^
src/appmake/x1.c:102:5: error: Resource handle 'fpin' freed twice. [doubleFree]
    fclose(fpin);
    ^
src/appmake/x1.c:93:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/x1.c:102:5: note: Resource handle 'fpin' freed twice.
    fclose(fpin);
    ^
src/appmake/x1.c:92:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/x1.c:86:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/x1.c:92:15: note: Null pointer dereference
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/x1.c:97:17: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    len = ftell(fpin);
                ^
src/appmake/x1.c:86:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/x1.c:97:17: note: Null pointer dereference
    len = ftell(fpin);
                ^
src/appmake/x1.c:99:11: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/x1.c:86:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/x1.c:99:11: note: Null pointer dereference
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/x1.c:101:35: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (len != fread(buf, 1, len, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                  ^
src/appmake/x1.c:86:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/x1.c:101:35: note: Null pointer dereference
    if (len != fread(buf, 1, len, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",binname); }
                                  ^
src/appmake/x1.c:102:12: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/x1.c:86:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/x1.c:102:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/z1013.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/z1013.c:94:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/z1013.c:90:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/z1013.c:94:15: note: Null pointer dereference
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/z1013.c:99:17: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    len = ftell(fpin);
                ^
src/appmake/z1013.c:90:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/z1013.c:99:17: note: Null pointer dereference
    len = ftell(fpin);
                ^
src/appmake/z1013.c:101:11: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/z1013.c:90:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/z1013.c:101:11: note: Null pointer dereference
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/z1013.c:137:12: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/z1013.c:90:46: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(binname, crtfile)) == NULL) {
                                             ^
src/appmake/z1013.c:137:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/z1013.c:138:12: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/z1013.c:103:41: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ((fpout = fopen(filename, "wb")) == NULL) {
                                        ^
src/appmake/z1013.c:138:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/z1013.c:49:9: style: The scope of the variable 'c' can be reduced. [variableScope]
    int c, i;
        ^
src/appmake/z88.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/z88.c:191:15: warning: Either the condition '(binfile=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: binfile. [nullPointerRedundantCheck]
    if (fseek(binfile, 0, SEEK_END)) {
              ^
src/appmake/z88.c:187:49: note: Assuming that condition '(binfile=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((binfile = fopen_bin(binname, crtfile)) == NULL) {
                                                ^
src/appmake/z88.c:191:15: note: Null pointer dereference
    if (fseek(binfile, 0, SEEK_END)) {
              ^
src/appmake/z88.c:196:22: warning: Either the condition '(binfile=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: binfile. [nullPointerRedundantCheck]
    filesize = ftell(binfile);
                     ^
src/appmake/z88.c:187:49: note: Assuming that condition '(binfile=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((binfile = fopen_bin(binname, crtfile)) == NULL) {
                                                ^
src/appmake/z88.c:196:22: note: Null pointer dereference
    filesize = ftell(binfile);
                     ^
src/appmake/z88.c:202:11: warning: Either the condition '(binfile=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: binfile. [nullPointerRedundantCheck]
    fseek(binfile, 0, SEEK_SET);
          ^
src/appmake/z88.c:187:49: note: Assuming that condition '(binfile=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((binfile = fopen_bin(binname, crtfile)) == NULL) {
                                                ^
src/appmake/z88.c:202:11: note: Null pointer dereference
    fseek(binfile, 0, SEEK_SET);
          ^
src/appmake/z88.c:217:12: warning: Either the condition '(binfile=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: binfile. [nullPointerRedundantCheck]
    fclose(binfile);
           ^
src/appmake/z88.c:187:49: note: Assuming that condition '(binfile=fopen_bin(binname,crtfile))==NULL' is not redundant
    if ((binfile = fopen_bin(binname, crtfile)) == NULL) {
                                                ^
src/appmake/z88.c:217:12: note: Null pointer dereference
    fclose(binfile);
           ^
src/appmake/z88.c:372:44: warning: Either the condition '(fp=fopen(name,"wb"))==NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    if (fwrite(buffer + offset, 1, length, fp) != length) {
                                           ^
src/appmake/z88.c:368:34: note: Assuming that condition '(fp=fopen(name,"wb"))==NULL' is not redundant
    if ((fp = fopen(name, "wb")) == NULL) {
                                 ^
src/appmake/z88.c:372:44: note: Null pointer dereference
    if (fwrite(buffer + offset, 1, length, fp) != length) {
                                           ^
src/appmake/z88.c:375:12: warning: Either the condition '(fp=fopen(name,"wb"))==NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    fclose(fp);
           ^
src/appmake/z88.c:368:34: note: Assuming that condition '(fp=fopen(name,"wb"))==NULL' is not redundant
    if ((fp = fopen(name, "wb")) == NULL) {
                                 ^
src/appmake/z88.c:375:12: note: Null pointer dereference
    fclose(fp);
           ^
src/appmake/z88.c:122:9: style: The scope of the variable 'readlen' can be reduced. [variableScope]
    int readlen; /* Amount read in */
        ^
src/appmake/z88elf.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/z88elf.c:81:9: error: Resource handle 'binfile' freed twice. [doubleFree]
        fclose(binfile);
        ^
src/appmake/z88elf.c:75:9: note: Resource handle 'binfile' freed twice.
        fclose(binfile);
        ^
src/appmake/z88elf.c:81:9: note: Resource handle 'binfile' freed twice.
        fclose(binfile);
        ^
src/appmake/z88elf.c:90:9: error: Resource handle 'binfile' freed twice. [doubleFree]
        fclose(binfile);
        ^
src/appmake/z88elf.c:75:9: note: Resource handle 'binfile' freed twice.
        fclose(binfile);
        ^
src/appmake/z88elf.c:90:9: note: Resource handle 'binfile' freed twice.
        fclose(binfile);
        ^
src/appmake/z88elf.c:94:5: error: Resource handle 'binfile' freed twice. [doubleFree]
    fclose(binfile);
    ^
src/appmake/z88elf.c:75:9: note: Resource handle 'binfile' freed twice.
        fclose(binfile);
        ^
src/appmake/z88elf.c:94:5: note: Resource handle 'binfile' freed twice.
    fclose(binfile);
    ^
src/appmake/z88elf.c:74:15: warning: Either the condition 'binfile==NULL' is redundant or there is possible null pointer dereference: binfile. [nullPointerRedundantCheck]
    if (fseek(binfile, 0, SEEK_END)) {
              ^
src/appmake/z88elf.c:71:17: note: Assuming that condition 'binfile==NULL' is not redundant
    if (binfile == NULL)
                ^
src/appmake/z88elf.c:74:15: note: Null pointer dereference
    if (fseek(binfile, 0, SEEK_END)) {
              ^
src/appmake/z88elf.c:79:22: warning: Either the condition 'binfile==NULL' is redundant or there is possible null pointer dereference: binfile. [nullPointerRedundantCheck]
    filesize = ftell(binfile);
                     ^
src/appmake/z88elf.c:71:17: note: Assuming that condition 'binfile==NULL' is not redundant
    if (binfile == NULL)
                ^
src/appmake/z88elf.c:79:22: note: Null pointer dereference
    filesize = ftell(binfile);
                     ^
src/appmake/z88elf.c:85:11: warning: Either the condition 'binfile==NULL' is redundant or there is possible null pointer dereference: binfile. [nullPointerRedundantCheck]
    fseek(binfile, 0, SEEK_SET);
          ^
src/appmake/z88elf.c:71:17: note: Assuming that condition 'binfile==NULL' is not redundant
    if (binfile == NULL)
                ^
src/appmake/z88elf.c:85:11: note: Null pointer dereference
    fseek(binfile, 0, SEEK_SET);
          ^
src/appmake/z88elf.c:87:42: warning: Either the condition 'binfile==NULL' is redundant or there is possible null pointer dereference: binfile. [nullPointerRedundantCheck]
    readlen = fread(memory, 1, filesize, binfile);
                                         ^
src/appmake/z88elf.c:71:17: note: Assuming that condition 'binfile==NULL' is not redundant
    if (binfile == NULL)
                ^
src/appmake/z88elf.c:87:42: note: Null pointer dereference
    readlen = fread(memory, 1, filesize, binfile);
                                         ^
src/appmake/z88elf.c:94:12: warning: Either the condition 'binfile==NULL' is redundant or there is possible null pointer dereference: binfile. [nullPointerRedundantCheck]
    fclose(binfile);
           ^
src/appmake/z88elf.c:71:17: note: Assuming that condition 'binfile==NULL' is not redundant
    if (binfile == NULL)
                ^
src/appmake/z88elf.c:94:12: note: Null pointer dereference
    fclose(binfile);
           ^
src/appmake/z88elf.c:216:43: warning: Either the condition '(fp=fopen(name,"wb"))==NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
        if (fwrite(header, 1, ptr-header, fp) != ptr-header) {
                                          ^
src/appmake/z88elf.c:212:38: note: Assuming that condition '(fp=fopen(name,"wb"))==NULL' is not redundant
        if ((fp = fopen(name, "wb")) == NULL) {
                                     ^
src/appmake/z88elf.c:216:43: note: Null pointer dereference
        if (fwrite(header, 1, ptr-header, fp) != ptr-header) {
                                          ^
src/appmake/z88elf.c:219:41: warning: Either the condition '(fp=fopen(name,"wb"))==NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
        if (fwrite(memory, 1, filesize, fp) != filesize) {
                                        ^
src/appmake/z88elf.c:212:38: note: Assuming that condition '(fp=fopen(name,"wb"))==NULL' is not redundant
        if ((fp = fopen(name, "wb")) == NULL) {
                                     ^
src/appmake/z88elf.c:219:41: note: Null pointer dereference
        if (fwrite(memory, 1, filesize, fp) != filesize) {
                                        ^
src/appmake/z88elf.c:223:16: warning: Either the condition '(fp=fopen(name,"wb"))==NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
        fclose(fp);
               ^
src/appmake/z88elf.c:212:38: note: Assuming that condition '(fp=fopen(name,"wb"))==NULL' is not redundant
        if ((fp = fopen(name, "wb")) == NULL) {
                                     ^
src/appmake/z88elf.c:223:16: note: Null pointer dereference
        fclose(fp);
               ^
src/appmake/z88shell.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/z88shell.c:88:9: error: Resource handle 'binfile' freed twice. [doubleFree]
        fclose(binfile);
        ^
src/appmake/z88shell.c:82:9: note: Resource handle 'binfile' freed twice.
        fclose(binfile);
        ^
src/appmake/z88shell.c:88:9: note: Resource handle 'binfile' freed twice.
        fclose(binfile);
        ^
src/appmake/z88shell.c:97:9: error: Resource handle 'binfile' freed twice. [doubleFree]
        fclose(binfile);
        ^
src/appmake/z88shell.c:82:9: note: Resource handle 'binfile' freed twice.
        fclose(binfile);
        ^
src/appmake/z88shell.c:97:9: note: Resource handle 'binfile' freed twice.
        fclose(binfile);
        ^
src/appmake/z88shell.c:101:5: error: Resource handle 'binfile' freed twice. [doubleFree]
    fclose(binfile);
    ^
src/appmake/z88shell.c:82:9: note: Resource handle 'binfile' freed twice.
        fclose(binfile);
        ^
src/appmake/z88shell.c:101:5: note: Resource handle 'binfile' freed twice.
    fclose(binfile);
    ^
src/appmake/z88shell.c:81:15: warning: Either the condition 'binfile==NULL' is redundant or there is possible null pointer dereference: binfile. [nullPointerRedundantCheck]
    if (fseek(binfile, 0, SEEK_END)) {
              ^
src/appmake/z88shell.c:78:17: note: Assuming that condition 'binfile==NULL' is not redundant
    if (binfile == NULL)
                ^
src/appmake/z88shell.c:81:15: note: Null pointer dereference
    if (fseek(binfile, 0, SEEK_END)) {
              ^
src/appmake/z88shell.c:86:22: warning: Either the condition 'binfile==NULL' is redundant or there is possible null pointer dereference: binfile. [nullPointerRedundantCheck]
    filesize = ftell(binfile);
                     ^
src/appmake/z88shell.c:78:17: note: Assuming that condition 'binfile==NULL' is not redundant
    if (binfile == NULL)
                ^
src/appmake/z88shell.c:86:22: note: Null pointer dereference
    filesize = ftell(binfile);
                     ^
src/appmake/z88shell.c:92:11: warning: Either the condition 'binfile==NULL' is redundant or there is possible null pointer dereference: binfile. [nullPointerRedundantCheck]
    fseek(binfile, 0, SEEK_SET);
          ^
src/appmake/z88shell.c:78:17: note: Assuming that condition 'binfile==NULL' is not redundant
    if (binfile == NULL)
                ^
src/appmake/z88shell.c:92:11: note: Null pointer dereference
    fseek(binfile, 0, SEEK_SET);
          ^
src/appmake/z88shell.c:94:42: warning: Either the condition 'binfile==NULL' is redundant or there is possible null pointer dereference: binfile. [nullPointerRedundantCheck]
    readlen = fread(memory, 1, filesize, binfile);
                                         ^
src/appmake/z88shell.c:78:17: note: Assuming that condition 'binfile==NULL' is not redundant
    if (binfile == NULL)
                ^
src/appmake/z88shell.c:94:42: note: Null pointer dereference
    readlen = fread(memory, 1, filesize, binfile);
                                         ^
src/appmake/z88shell.c:101:12: warning: Either the condition 'binfile==NULL' is redundant or there is possible null pointer dereference: binfile. [nullPointerRedundantCheck]
    fclose(binfile);
           ^
src/appmake/z88shell.c:78:17: note: Assuming that condition 'binfile==NULL' is not redundant
    if (binfile == NULL)
                ^
src/appmake/z88shell.c:101:12: note: Null pointer dereference
    fclose(binfile);
           ^
src/appmake/z88shell.c:132:37: warning: Either the condition '(fp=fopen(name,"wb"))==NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    if (fwrite(memory, 1, filesize, fp) != filesize) {
                                    ^
src/appmake/z88shell.c:128:34: note: Assuming that condition '(fp=fopen(name,"wb"))==NULL' is not redundant
    if ((fp = fopen(name, "wb")) == NULL) {
                                 ^
src/appmake/z88shell.c:132:37: note: Null pointer dereference
    if (fwrite(memory, 1, filesize, fp) != filesize) {
                                    ^
src/appmake/z88shell.c:135:12: warning: Either the condition '(fp=fopen(name,"wb"))==NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    fclose(fp);
           ^
src/appmake/z88shell.c:128:34: note: Assuming that condition '(fp=fopen(name,"wb"))==NULL' is not redundant
    if ((fp = fopen(name, "wb")) == NULL) {
                                 ^
src/appmake/z88shell.c:135:12: note: Null pointer dereference
    fclose(fp);
           ^
src/appmake/z9001.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/z9001.c:92:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin,0,SEEK_END)) {
              ^
src/appmake/z9001.c:88:43: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
 if ( (fpin=fopen_bin(binname, crtfile) ) == NULL ) {
                                          ^
src/appmake/z9001.c:92:15: note: Null pointer dereference
    if (fseek(fpin,0,SEEK_END)) {
              ^
src/appmake/z9001.c:97:15: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    len=ftell(fpin);
              ^
src/appmake/z9001.c:88:43: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
 if ( (fpin=fopen_bin(binname, crtfile) ) == NULL ) {
                                          ^
src/appmake/z9001.c:97:15: note: Null pointer dereference
    len=ftell(fpin);
              ^
src/appmake/z9001.c:99:11: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin,0L,SEEK_SET);
          ^
src/appmake/z9001.c:88:43: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
 if ( (fpin=fopen_bin(binname, crtfile) ) == NULL ) {
                                          ^
src/appmake/z9001.c:99:11: note: Null pointer dereference
    fseek(fpin,0L,SEEK_SET);
          ^
src/appmake/z9001.c:107:31: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
 fputs("\xc3KC-TAPE by AF. ", fpout);
                              ^
src/appmake/z9001.c:101:40: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                       ^
src/appmake/z9001.c:107:31: note: Null pointer dereference
 fputs("\xc3KC-TAPE by AF. ", fpout);
                              ^
src/appmake/z9001.c:164:12: warning: Either the condition '(fpin=fopen_bin(binname,crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/z9001.c:88:43: note: Assuming that condition '(fpin=fopen_bin(binname,crtfile))==NULL' is not redundant
 if ( (fpin=fopen_bin(binname, crtfile) ) == NULL ) {
                                          ^
src/appmake/z9001.c:164:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/z9001.c:165:12: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
    fclose(fpout);
           ^
src/appmake/z9001.c:101:40: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
    if ( (fpout=fopen(filename,"wb") ) == NULL ) {
                                       ^
src/appmake/z9001.c:165:12: note: Null pointer dereference
    fclose(fpout);
           ^
src/appmake/zx-util.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/zx-util.c:235:9: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        fprintf(stderr, "Patching the turbo loader at position %u: ", zxt->patchpos);
        ^
src/appmake/zx-util.c:311:17: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
                printf("\nInfo: Position %u is too low, not relocating TS2068 BASIC.", (int)pos);
                ^
src/appmake/zx-util.c:305:13: error: Resource handle 'fpin' freed twice. [doubleFree]
            fclose(fpin);
            ^
src/appmake/zx-util.c:297:13: note: Resource handle 'fpin' freed twice.
            fclose(fpin);
            ^
src/appmake/zx-util.c:305:13: note: Resource handle 'fpin' freed twice.
            fclose(fpin);
            ^
src/appmake/zx-util.c:372:25: error: Resource handle 'fpin' freed twice. [doubleFree]
                        fclose(fpin);
                        ^
src/appmake/zx-util.c:297:13: note: Resource handle 'fpin' freed twice.
            fclose(fpin);
            ^
src/appmake/zx-util.c:372:25: note: Resource handle 'fpin' freed twice.
                        fclose(fpin);
                        ^
src/appmake/zx-util.c:378:25: error: Resource handle 'fpin' freed twice. [doubleFree]
                        fclose(fpin);
                        ^
src/appmake/zx-util.c:297:13: note: Resource handle 'fpin' freed twice.
            fclose(fpin);
            ^
src/appmake/zx-util.c:378:25: note: Resource handle 'fpin' freed twice.
                        fclose(fpin);
                        ^
src/appmake/zx-util.c:379:25: error: Resource handle 'fpout' freed twice. [doubleFree]
                        fclose(fpout);
                        ^
src/appmake/zx-util.c:373:25: note: Resource handle 'fpout' freed twice.
                        fclose(fpout);
                        ^
src/appmake/zx-util.c:379:25: note: Resource handle 'fpout' freed twice.
                        fclose(fpout);
                        ^
src/appmake/zx-util.c:386:25: error: Resource handle 'fpin' freed twice. [doubleFree]
                        fclose(fpin);
                        ^
src/appmake/zx-util.c:297:13: note: Resource handle 'fpin' freed twice.
            fclose(fpin);
            ^
src/appmake/zx-util.c:386:25: note: Resource handle 'fpin' freed twice.
                        fclose(fpin);
                        ^
src/appmake/zx-util.c:387:25: error: Resource handle 'fpout' freed twice. [doubleFree]
                        fclose(fpout);
                        ^
src/appmake/zx-util.c:373:25: note: Resource handle 'fpout' freed twice.
                        fclose(fpout);
                        ^
src/appmake/zx-util.c:387:25: note: Resource handle 'fpout' freed twice.
                        fclose(fpout);
                        ^
src/appmake/zx-util.c:397:25: error: Resource handle 'fpin' freed twice. [doubleFree]
                        fclose(fpin);
                        ^
src/appmake/zx-util.c:297:13: note: Resource handle 'fpin' freed twice.
            fclose(fpin);
            ^
src/appmake/zx-util.c:397:25: note: Resource handle 'fpin' freed twice.
                        fclose(fpin);
                        ^
src/appmake/zx-util.c:398:25: error: Resource handle 'fpout' freed twice. [doubleFree]
                        fclose(fpout);
                        ^
src/appmake/zx-util.c:373:25: note: Resource handle 'fpout' freed twice.
                        fclose(fpout);
                        ^
src/appmake/zx-util.c:398:25: note: Resource handle 'fpout' freed twice.
                        fclose(fpout);
                        ^
src/appmake/zx-util.c:533:21: error: Resource handle 'fpin' freed twice. [doubleFree]
                    fclose(fpin);
                    ^
src/appmake/zx-util.c:297:13: note: Resource handle 'fpin' freed twice.
            fclose(fpin);
            ^
src/appmake/zx-util.c:533:21: note: Resource handle 'fpin' freed twice.
                    fclose(fpin);
                    ^
src/appmake/zx-util.c:539:21: error: Resource handle 'fpin' freed twice. [doubleFree]
                    fclose(fpin);
                    ^
src/appmake/zx-util.c:297:13: note: Resource handle 'fpin' freed twice.
            fclose(fpin);
            ^
src/appmake/zx-util.c:539:21: note: Resource handle 'fpin' freed twice.
                    fclose(fpin);
                    ^
src/appmake/zx-util.c:540:21: error: Resource handle 'fpout' freed twice. [doubleFree]
                    fclose(fpout);
                    ^
src/appmake/zx-util.c:534:21: note: Resource handle 'fpout' freed twice.
                    fclose(fpout);
                    ^
src/appmake/zx-util.c:540:21: note: Resource handle 'fpout' freed twice.
                    fclose(fpout);
                    ^
src/appmake/zx-util.c:547:21: error: Resource handle 'fpin' freed twice. [doubleFree]
                    fclose(fpin);
                    ^
src/appmake/zx-util.c:297:13: note: Resource handle 'fpin' freed twice.
            fclose(fpin);
            ^
src/appmake/zx-util.c:547:21: note: Resource handle 'fpin' freed twice.
                    fclose(fpin);
                    ^
src/appmake/zx-util.c:548:21: error: Resource handle 'fpout' freed twice. [doubleFree]
                    fclose(fpout);
                    ^
src/appmake/zx-util.c:534:21: note: Resource handle 'fpout' freed twice.
                    fclose(fpout);
                    ^
src/appmake/zx-util.c:548:21: note: Resource handle 'fpout' freed twice.
                    fclose(fpout);
                    ^
src/appmake/zx-util.c:549:21: error: Resource handle 'fpmerge' freed twice. [doubleFree]
                    fclose(fpmerge);
                    ^
src/appmake/zx-util.c:541:21: note: Resource handle 'fpmerge' freed twice.
                    fclose(fpmerge);
                    ^
src/appmake/zx-util.c:549:21: note: Resource handle 'fpmerge' freed twice.
                    fclose(fpmerge);
                    ^
src/appmake/zx-util.c:1625:9: error: Resource handle 'fin' freed twice. [doubleFree]
        fclose(fin);
        ^
src/appmake/zx-util.c:1621:46: note: Resource handle 'fin' freed twice.
    if (1 != fread(sna_state, 27, 1, fin)) { fclose(fin); exit_log(1, "Could not read required data from <%s>\n",filename); }
                                             ^
src/appmake/zx-util.c:1625:9: note: Resource handle 'fin' freed twice.
        fclose(fin);
        ^
src/appmake/zx-util.c:1631:62: error: Resource handle 'fin' freed twice. [doubleFree]
        if (1 != fread(&sna_state[SNA_128_PC], 4, 1, fin)) { fclose(fin); exit_log(1, "Could not read required data from <%s>\n",filename); }
                                                             ^
src/appmake/zx-util.c:1621:46: note: Resource handle 'fin' freed twice.
    if (1 != fread(sna_state, 27, 1, fin)) { fclose(fin); exit_log(1, "Could not read required data from <%s>\n",filename); }
                                             ^
src/appmake/zx-util.c:1631:62: note: Resource handle 'fin' freed twice.
        if (1 != fread(&sna_state[SNA_128_PC], 4, 1, fin)) { fclose(fin); exit_log(1, "Could not read required data from <%s>\n",filename); }
                                                             ^
src/appmake/zx-util.c:1648:5: error: Resource handle 'fin' freed twice. [doubleFree]
    fclose(fin);
    ^
src/appmake/zx-util.c:1621:46: note: Resource handle 'fin' freed twice.
    if (1 != fread(sna_state, 27, 1, fin)) { fclose(fin); exit_log(1, "Could not read required data from <%s>\n",filename); }
                                             ^
src/appmake/zx-util.c:1648:5: note: Resource handle 'fin' freed twice.
    fclose(fin);
    ^
src/appmake/zx-util.c:2225:9: error: Resource handle 'fpin' freed twice. [doubleFree]
        fclose(fpin);
        ^
src/appmake/zx-util.c:2217:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/zx-util.c:2225:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/zx-util.c:2286:13: error: Resource handle 'fpin' freed twice. [doubleFree]
            fclose(fpin);
            ^
src/appmake/zx-util.c:2217:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/zx-util.c:2286:13: note: Resource handle 'fpin' freed twice.
            fclose(fpin);
            ^
src/appmake/zx-util.c:2291:9: error: Resource handle 'fpscr' freed twice. [doubleFree]
        fclose(fpscr);
        ^
src/appmake/zx-util.c:2290:54: note: Resource handle 'fpscr' freed twice.
        if (6912 != fread(scrbuf, 1, 6912, fpscr)) { fclose(fpscr); exit_log(1, "Could not read required data from <%s>\n",zxt->screen); }
                                                     ^
src/appmake/zx-util.c:2291:9: note: Resource handle 'fpscr' freed twice.
        fclose(fpscr);
        ^
src/appmake/zx-util.c:2299:64: error: Resource handle 'fpin' freed twice. [doubleFree]
    if (binary_length != fread(ptr, 1, binary_length, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",zxc->binname); }
                                                               ^
src/appmake/zx-util.c:2217:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/zx-util.c:2299:64: note: Resource handle 'fpin' freed twice.
    if (binary_length != fread(ptr, 1, binary_length, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",zxc->binname); }
                                                               ^
src/appmake/zx-util.c:2300:5: error: Resource handle 'fpin' freed twice. [doubleFree]
    fclose(fpin);
    ^
src/appmake/zx-util.c:2217:9: note: Resource handle 'fpin' freed twice.
        fclose(fpin);
        ^
src/appmake/zx-util.c:2300:5: note: Resource handle 'fpin' freed twice.
    fclose(fpin);
    ^
src/appmake/zx-util.c:75:19: warning: Either the condition '(fin=fopen(sb->filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fin. [nullPointerRedundantCheck]
        if (fseek(fin, sb->offset, SEEK_SET) != 0)
                  ^
src/appmake/zx-util.c:72:47: note: Assuming that condition '(fin=fopen(sb->filename,"rb"))==NULL' is not redundant
        if ((fin = fopen(sb->filename, "rb")) == NULL)
                                              ^
src/appmake/zx-util.c:75:19: note: Null pointer dereference
        if (fseek(fin, sb->offset, SEEK_SET) != 0)
                  ^
src/appmake/zx-util.c:78:60: warning: Either the condition '(fin=fopen(sb->filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fin. [nullPointerRedundantCheck]
        if (fread(&mem[sb->org & (mbsz - 1)], sb->size, 1, fin) != 1)
                                                           ^
src/appmake/zx-util.c:72:47: note: Assuming that condition '(fin=fopen(sb->filename,"rb"))==NULL' is not redundant
        if ((fin = fopen(sb->filename, "rb")) == NULL)
                                              ^
src/appmake/zx-util.c:78:60: note: Null pointer dereference
        if (fread(&mem[sb->org & (mbsz - 1)], sb->size, 1, fin) != 1)
                                                           ^
src/appmake/zx-util.c:81:16: warning: Either the condition '(fin=fopen(sb->filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fin. [nullPointerRedundantCheck]
        fclose(fin);
               ^
src/appmake/zx-util.c:72:47: note: Assuming that condition '(fin=fopen(sb->filename,"rb"))==NULL' is not redundant
        if ((fin = fopen(sb->filename, "rb")) == NULL)
                                              ^
src/appmake/zx-util.c:81:16: note: Null pointer dereference
        fclose(fin);
               ^
src/appmake/zx-util.c:296:19: warning: Either the condition '(fpin=fopen_bin(zxc->binname,zxc->crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/zx-util.c:288:60: note: Assuming that condition '(fpin=fopen_bin(zxc->binname,zxc->crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(zxc->binname, zxc->crtfile)) == NULL) {
                                                           ^
src/appmake/zx-util.c:296:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/zx-util.c:301:21: warning: Either the condition '(fpin=fopen_bin(zxc->binname,zxc->crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin);
                    ^
src/appmake/zx-util.c:288:60: note: Assuming that condition '(fpin=fopen_bin(zxc->binname,zxc->crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(zxc->binname, zxc->crtfile)) == NULL) {
                                                           ^
src/appmake/zx-util.c:301:21: note: Null pointer dereference
        len = ftell(fpin);
                    ^
src/appmake/zx-util.c:302:15: warning: Either the condition '(fpin=fopen_bin(zxc->binname,zxc->crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/zx-util.c:288:60: note: Assuming that condition '(fpin=fopen_bin(zxc->binname,zxc->crtfile))==NULL' is not redundant
        if ((fpin = fopen_bin(zxc->binname, zxc->crtfile)) == NULL) {
                                                           ^
src/appmake/zx-util.c:302:15: note: Null pointer dereference
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/zx-util.c:383:27: warning: Either the condition '(fpmerge=fopen(zxt->merge,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpmerge. [nullPointerRedundantCheck]
                    fseek(fpmerge, 3, SEEK_SET);
                          ^
src/appmake/zx-util.c:377:61: note: Assuming that condition '(fpmerge=fopen(zxt->merge,"rb"))==NULL' is not redundant
                    if ((fpmerge = fopen(zxt->merge, "rb")) == NULL) {
                                                            ^
src/appmake/zx-util.c:383:27: note: Null pointer dereference
                    fseek(fpmerge, 3, SEEK_SET);
                          ^
src/appmake/zx-util.c:384:30: warning: Either the condition '(fpmerge=fopen(zxt->merge,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpmerge. [nullPointerRedundantCheck]
                    c = getc(fpmerge);
                             ^
src/appmake/zx-util.c:377:61: note: Assuming that condition '(fpmerge=fopen(zxt->merge,"rb"))==NULL' is not redundant
                    if ((fpmerge = fopen(zxt->merge, "rb")) == NULL) {
                                                            ^
src/appmake/zx-util.c:384:30: note: Null pointer dereference
                    c = getc(fpmerge);
                             ^
src/appmake/zx-util.c:391:27: warning: Either the condition '(fpmerge=fopen(zxt->merge,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpmerge. [nullPointerRedundantCheck]
                    fseek(fpmerge, 21, SEEK_SET);
                          ^
src/appmake/zx-util.c:377:61: note: Assuming that condition '(fpmerge=fopen(zxt->merge,"rb"))==NULL' is not redundant
                    if ((fpmerge = fopen(zxt->merge, "rb")) == NULL) {
                                                            ^
src/appmake/zx-util.c:391:27: note: Null pointer dereference
                    fseek(fpmerge, 21, SEEK_SET);
                          ^
src/appmake/zx-util.c:392:33: warning: Either the condition '(fpmerge=fopen(zxt->merge,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpmerge. [nullPointerRedundantCheck]
                    mlen = getc(fpmerge) + 256 * getc(fpmerge);  /* get block length */
                                ^
src/appmake/zx-util.c:377:61: note: Assuming that condition '(fpmerge=fopen(zxt->merge,"rb"))==NULL' is not redundant
                    if ((fpmerge = fopen(zxt->merge, "rb")) == NULL) {
                                                            ^
src/appmake/zx-util.c:392:33: note: Null pointer dereference
                    mlen = getc(fpmerge) + 256 * getc(fpmerge);  /* get block length */
                                ^
src/appmake/zx-util.c:394:27: warning: Either the condition '(fpmerge=fopen(zxt->merge,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpmerge. [nullPointerRedundantCheck]
                    fseek(fpmerge, 0, SEEK_SET);
                          ^
src/appmake/zx-util.c:377:61: note: Assuming that condition '(fpmerge=fopen(zxt->merge,"rb"))==NULL' is not redundant
                    if ((fpmerge = fopen(zxt->merge, "rb")) == NULL) {
                                                            ^
src/appmake/zx-util.c:394:27: note: Null pointer dereference
                    fseek(fpmerge, 0, SEEK_SET);
                          ^
src/appmake/zx-util.c:395:37: warning: Either the condition '(fpmerge=fopen(zxt->merge,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpmerge. [nullPointerRedundantCheck]
                    blocklen = getc(fpmerge) + 256 * getc(fpmerge);  /* get block length */
                                    ^
src/appmake/zx-util.c:377:61: note: Assuming that condition '(fpmerge=fopen(zxt->merge,"rb"))==NULL' is not redundant
                    if ((fpmerge = fopen(zxt->merge, "rb")) == NULL) {
                                                            ^
src/appmake/zx-util.c:395:37: note: Null pointer dereference
                    blocklen = getc(fpmerge) + 256 * getc(fpmerge);  /* get block length */
                                    ^
src/appmake/zx-util.c:401:27: warning: Either the condition '(fpmerge=fopen(zxt->merge,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpmerge. [nullPointerRedundantCheck]
                    fseek(fpmerge, 0, SEEK_SET);
                          ^
src/appmake/zx-util.c:377:61: note: Assuming that condition '(fpmerge=fopen(zxt->merge,"rb"))==NULL' is not redundant
                    if ((fpmerge = fopen(zxt->merge, "rb")) == NULL) {
                                                            ^
src/appmake/zx-util.c:401:27: note: Null pointer dereference
                    fseek(fpmerge, 0, SEEK_SET);
                          ^
src/appmake/zx-util.c:409:28: warning: Either the condition '(fpmerge=fopen(zxt->merge,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpmerge. [nullPointerRedundantCheck]
                    fclose(fpmerge);
                           ^
src/appmake/zx-util.c:377:61: note: Assuming that condition '(fpmerge=fopen(zxt->merge,"rb"))==NULL' is not redundant
                    if ((fpmerge = fopen(zxt->merge, "rb")) == NULL) {
                                                            ^
src/appmake/zx-util.c:409:28: note: Null pointer dereference
                    fclose(fpmerge);
                           ^
src/appmake/zx-util.c:538:27: warning: Either the condition '(fpmerge=fopen(zxt->screen,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpmerge. [nullPointerRedundantCheck]
                if (fseek(fpmerge, 0, SEEK_END)) {
                          ^
src/appmake/zx-util.c:532:58: note: Assuming that condition '(fpmerge=fopen(zxt->screen,"rb"))==NULL' is not redundant
                if ((fpmerge = fopen(zxt->screen, "rb")) == NULL) {
                                                         ^
src/appmake/zx-util.c:538:27: note: Null pointer dereference
                if (fseek(fpmerge, 0, SEEK_END)) {
                          ^
src/appmake/zx-util.c:545:30: warning: Either the condition '(fpmerge=fopen(zxt->screen,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpmerge. [nullPointerRedundantCheck]
                mlen = ftell(fpmerge);
                             ^
src/appmake/zx-util.c:532:58: note: Assuming that condition '(fpmerge=fopen(zxt->screen,"rb"))==NULL' is not redundant
                if ((fpmerge = fopen(zxt->screen, "rb")) == NULL) {
                                                         ^
src/appmake/zx-util.c:545:30: note: Null pointer dereference
                mlen = ftell(fpmerge);
                             ^
src/appmake/zx-util.c:636:84: warning: Either the condition 'fpbank==NULL' is redundant or there is possible null pointer dereference: fpbank. [nullPointerRedundantCheck]
                    if ( mb->secbin->size != fread(bank_buf, 1,  mb->secbin->size, fpbank)) {  exit_log(1, "Could not read required data from <%s>\n",mb->secbin->filename); }
                                                                                   ^
src/appmake/zx-util.c:633:33: note: Assuming that condition 'fpbank==NULL' is not redundant
                    if ( fpbank == NULL ) {
                                ^
src/appmake/zx-util.c:636:84: note: Null pointer dereference
                    if ( mb->secbin->size != fread(bank_buf, 1,  mb->secbin->size, fpbank)) {  exit_log(1, "Could not read required data from <%s>\n",mb->secbin->filename); }
                                                                                   ^
src/appmake/zx-util.c:647:28: warning: Either the condition 'fpbank==NULL' is redundant or there is possible null pointer dereference: fpbank. [nullPointerRedundantCheck]
                    fclose(fpbank);
                           ^
src/appmake/zx-util.c:633:33: note: Assuming that condition 'fpbank==NULL' is not redundant
                    if ( fpbank == NULL ) {
                                ^
src/appmake/zx-util.c:647:28: note: Null pointer dereference
                    fclose(fpbank);
                           ^
src/appmake/zx-util.c:663:19: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/zx-util.c:659:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/zx-util.c:663:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/zx-util.c:667:21: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin);
                    ^
src/appmake/zx-util.c:659:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/zx-util.c:667:21: note: Null pointer dereference
        len = ftell(fpin);
                    ^
src/appmake/zx-util.c:668:15: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/zx-util.c:659:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/zx-util.c:668:15: note: Null pointer dereference
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/zx-util.c:881:16: warning: Either the condition '(fout=fopen(outnamex,"wb"))==NULL' is redundant or there is possible null pointer dereference: fout. [nullPointerRedundantCheck]
        fclose(fout);
               ^
src/appmake/zx-util.c:865:44: note: Assuming that condition '(fout=fopen(outnamex,"wb"))==NULL' is not redundant
        if ((fout = fopen(outnamex, "wb")) == NULL)
                                           ^
src/appmake/zx-util.c:881:16: note: Null pointer dereference
        fclose(fout);
               ^
src/appmake/zx-util.c:905:12: warning: Either the condition '(fout=fopen(outname,"rb+"))==NULL' is redundant or there is possible null pointer dereference: fout. [nullPointerRedundantCheck]
    fclose(fout);
           ^
src/appmake/zx-util.c:885:44: note: Assuming that condition '(fout=fopen(outname,"rb+"))==NULL' is not redundant
        if ((fout = fopen(outname, "rb+")) == NULL)
                                           ^
src/appmake/zx-util.c:905:12: note: Null pointer dereference
    fclose(fout);
           ^
src/appmake/zx-util.c:1044:19: warning: Either the condition '(fin=fopen(sb->filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fin. [nullPointerRedundantCheck]
        if (fseek(fin, sb->offset, SEEK_SET) != 0)
                  ^
src/appmake/zx-util.c:1041:47: note: Assuming that condition '(fin=fopen(sb->filename,"rb"))==NULL' is not redundant
        if ((fin = fopen(sb->filename, "rb")) == NULL)
                                              ^
src/appmake/zx-util.c:1044:19: note: Null pointer dereference
        if (fseek(fin, sb->offset, SEEK_SET) != 0)
                  ^
src/appmake/zx-util.c:1047:47: warning: Either the condition '(fin=fopen(sb->filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fin. [nullPointerRedundantCheck]
        if (fread(&mem[sb->org], sb->size, 1, fin) < 1)
                                              ^
src/appmake/zx-util.c:1041:47: note: Assuming that condition '(fin=fopen(sb->filename,"rb"))==NULL' is not redundant
        if ((fin = fopen(sb->filename, "rb")) == NULL)
                                              ^
src/appmake/zx-util.c:1047:47: note: Null pointer dereference
        if (fread(&mem[sb->org], sb->size, 1, fin) < 1)
                                              ^
src/appmake/zx-util.c:1053:16: warning: Either the condition '(fin=fopen(sb->filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fin. [nullPointerRedundantCheck]
        fclose(fin);
               ^
src/appmake/zx-util.c:1041:47: note: Assuming that condition '(fin=fopen(sb->filename,"rb"))==NULL' is not redundant
        if ((fin = fopen(sb->filename, "rb")) == NULL)
                                              ^
src/appmake/zx-util.c:1053:16: note: Null pointer dereference
        fclose(fin);
               ^
src/appmake/zx-util.c:1169:35: warning: Either the condition '(fout=fopen(outname,"wb"))==NULL' is redundant or there is possible null pointer dereference: fout. [nullPointerRedundantCheck]
    fwrite(&mem[0x2000], 8192, 1, fout);
                                  ^
src/appmake/zx-util.c:1164:39: note: Assuming that condition '(fout=fopen(outname,"wb"))==NULL' is not redundant
    if ((fout = fopen(outname, "wb")) == NULL)
                                      ^
src/appmake/zx-util.c:1169:35: note: Null pointer dereference
    fwrite(&mem[0x2000], 8192, 1, fout);
                                  ^
src/appmake/zx-util.c:1621:38: warning: Either the condition '(fin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fin. [nullPointerRedundantCheck]
    if (1 != fread(sna_state, 27, 1, fin)) { fclose(fin); exit_log(1, "Could not read required data from <%s>\n",filename); }
                                     ^
src/appmake/zx-util.c:1618:39: note: Assuming that condition '(fin=fopen(filename,"rb"))==NULL' is not redundant
    if ((fin = fopen(filename, "rb")) == NULL)
                                      ^
src/appmake/zx-util.c:1621:38: note: Null pointer dereference
    if (1 != fread(sna_state, 27, 1, fin)) { fclose(fin); exit_log(1, "Could not read required data from <%s>\n",filename); }
                                     ^
src/appmake/zx-util.c:1623:33: warning: Either the condition '(fin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fin. [nullPointerRedundantCheck]
    if (fread(mem128, 49152, 1, fin) < 1)
                                ^
src/appmake/zx-util.c:1618:39: note: Assuming that condition '(fin=fopen(filename,"rb"))==NULL' is not redundant
    if ((fin = fopen(filename, "rb")) == NULL)
                                      ^
src/appmake/zx-util.c:1623:33: note: Null pointer dereference
    if (fread(mem128, 49152, 1, fin) < 1)
                                ^
src/appmake/zx-util.c:1648:12: warning: Either the condition '(fin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fin. [nullPointerRedundantCheck]
    fclose(fin);
           ^
src/appmake/zx-util.c:1618:39: note: Assuming that condition '(fin=fopen(filename,"rb"))==NULL' is not redundant
    if ((fin = fopen(filename, "rb")) == NULL)
                                      ^
src/appmake/zx-util.c:1648:12: note: Null pointer dereference
    fclose(fin);
           ^
src/appmake/zx-util.c:1667:19: warning: Either the condition '(fin=fopen(sb->filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fin. [nullPointerRedundantCheck]
        if (fseek(fin, sb->offset, SEEK_SET) != 0)
                  ^
src/appmake/zx-util.c:1664:47: note: Assuming that condition '(fin=fopen(sb->filename,"rb"))==NULL' is not redundant
        if ((fin = fopen(sb->filename, "rb")) == NULL)
                                              ^
src/appmake/zx-util.c:1667:19: note: Null pointer dereference
        if (fseek(fin, sb->offset, SEEK_SET) != 0)
                  ^
src/appmake/zx-util.c:1670:59: warning: Either the condition '(fin=fopen(sb->filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fin. [nullPointerRedundantCheck]
        if (fread(&mem128[sb->org - 0x4000], sb->size, 1, fin) < 1)
                                                          ^
src/appmake/zx-util.c:1664:47: note: Assuming that condition '(fin=fopen(sb->filename,"rb"))==NULL' is not redundant
        if ((fin = fopen(sb->filename, "rb")) == NULL)
                                              ^
src/appmake/zx-util.c:1670:59: note: Null pointer dereference
        if (fread(&mem128[sb->org - 0x4000], sb->size, 1, fin) < 1)
                                                          ^
src/appmake/zx-util.c:1676:16: warning: Either the condition '(fin=fopen(sb->filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fin. [nullPointerRedundantCheck]
        fclose(fin);
               ^
src/appmake/zx-util.c:1664:47: note: Assuming that condition '(fin=fopen(sb->filename,"rb"))==NULL' is not redundant
        if ((fin = fopen(sb->filename, "rb")) == NULL)
                                              ^
src/appmake/zx-util.c:1676:16: note: Null pointer dereference
        fclose(fin);
               ^
src/appmake/zx-util.c:1692:27: warning: Either the condition '(fin=fopen(sb->filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fin. [nullPointerRedundantCheck]
                if (fseek(fin, sb->offset, SEEK_SET) != 0)
                          ^
src/appmake/zx-util.c:1689:55: note: Assuming that condition '(fin=fopen(sb->filename,"rb"))==NULL' is not redundant
                if ((fin = fopen(sb->filename, "rb")) == NULL)
                                                      ^
src/appmake/zx-util.c:1692:27: note: Null pointer dereference
                if (fseek(fin, sb->offset, SEEK_SET) != 0)
                          ^
src/appmake/zx-util.c:1695:87: warning: Either the condition '(fin=fopen(sb->filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fin. [nullPointerRedundantCheck]
                if (fread(&mem128[49152 + i * 16384 + sb->org - 0xc000], sb->size, 1, fin) < 1)
                                                                                      ^
src/appmake/zx-util.c:1689:55: note: Assuming that condition '(fin=fopen(sb->filename,"rb"))==NULL' is not redundant
                if ((fin = fopen(sb->filename, "rb")) == NULL)
                                                      ^
src/appmake/zx-util.c:1695:87: note: Null pointer dereference
                if (fread(&mem128[49152 + i * 16384 + sb->org - 0xc000], sb->size, 1, fin) < 1)
                                                                                      ^
src/appmake/zx-util.c:1701:24: warning: Either the condition '(fin=fopen(sb->filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fin. [nullPointerRedundantCheck]
                fclose(fin);
                       ^
src/appmake/zx-util.c:1689:55: note: Assuming that condition '(fin=fopen(sb->filename,"rb"))==NULL' is not redundant
                if ((fin = fopen(sb->filename, "rb")) == NULL)
                                                      ^
src/appmake/zx-util.c:1701:24: note: Null pointer dereference
                fclose(fin);
                       ^
src/appmake/zx-util.c:1767:30: warning: Either the condition '(fout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fout. [nullPointerRedundantCheck]
    fwrite(sna_state, 27, 1, fout);
                             ^
src/appmake/zx-util.c:1764:40: note: Assuming that condition '(fout=fopen(filename,"wb"))==NULL' is not redundant
    if ((fout = fopen(filename, "wb")) == NULL)
                                       ^
src/appmake/zx-util.c:1767:30: note: Null pointer dereference
    fwrite(sna_state, 27, 1, fout);
                             ^
src/appmake/zx-util.c:1768:30: warning: Either the condition '(fout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fout. [nullPointerRedundantCheck]
    fwrite(mem128, 49152, 1, fout);
                             ^
src/appmake/zx-util.c:1764:40: note: Assuming that condition '(fout=fopen(filename,"wb"))==NULL' is not redundant
    if ((fout = fopen(filename, "wb")) == NULL)
                                       ^
src/appmake/zx-util.c:1768:30: note: Null pointer dereference
    fwrite(mem128, 49152, 1, fout);
                             ^
src/appmake/zx-util.c:1909:32: warning: Either the condition '(fout=fopen(outname,"wb"))==NULL' is redundant or there is possible null pointer dereference: fout. [nullPointerRedundantCheck]
    fwrite(&nh, sizeof(nh), 1, fout);
                               ^
src/appmake/zx-util.c:1903:39: note: Assuming that condition '(fout=fopen(outname,"wb"))==NULL' is not redundant
    if ((fout = fopen(outname, "wb")) == NULL)
                                      ^
src/appmake/zx-util.c:1909:32: note: Null pointer dereference
    fwrite(&nh, sizeof(nh), 1, fout);
                               ^
src/appmake/zx-util.c:1987:23: warning: Either the condition '(fin=fopen(sb->filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fin. [nullPointerRedundantCheck]
            if (fseek(fin, sb->offset, SEEK_SET) != 0)
                      ^
src/appmake/zx-util.c:1984:51: note: Assuming that condition '(fin=fopen(sb->filename,"rb"))==NULL' is not redundant
            if ((fin = fopen(sb->filename, "rb")) == NULL)
                                                  ^
src/appmake/zx-util.c:1987:23: note: Null pointer dereference
            if (fseek(fin, sb->offset, SEEK_SET) != 0)
                      ^
src/appmake/zx-util.c:1990:60: warning: Either the condition '(fin=fopen(sb->filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fin. [nullPointerRedundantCheck]
            if (fread(&mem[sb->org - 0x4000], sb->size, 1, fin) < 1)
                                                           ^
src/appmake/zx-util.c:1984:51: note: Assuming that condition '(fin=fopen(sb->filename,"rb"))==NULL' is not redundant
            if ((fin = fopen(sb->filename, "rb")) == NULL)
                                                  ^
src/appmake/zx-util.c:1990:60: note: Null pointer dereference
            if (fread(&mem[sb->org - 0x4000], sb->size, 1, fin) < 1)
                                                           ^
src/appmake/zx-util.c:1996:20: warning: Either the condition '(fin=fopen(sb->filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fin. [nullPointerRedundantCheck]
            fclose(fin);
                   ^
src/appmake/zx-util.c:1984:51: note: Assuming that condition '(fin=fopen(sb->filename,"rb"))==NULL' is not redundant
            if ((fin = fopen(sb->filename, "rb")) == NULL)
                                                  ^
src/appmake/zx-util.c:1996:20: note: Null pointer dereference
            fclose(fin);
                   ^
src/appmake/zx-util.c:2102:12: warning: Either the condition '(fout=fopen(outname,"wb"))==NULL' is redundant or there is possible null pointer dereference: fout. [nullPointerRedundantCheck]
    rewind(fout);
           ^
src/appmake/zx-util.c:1903:39: note: Assuming that condition '(fout=fopen(outname,"wb"))==NULL' is not redundant
    if ((fout = fopen(outname, "wb")) == NULL)
                                      ^
src/appmake/zx-util.c:2102:12: note: Null pointer dereference
    rewind(fout);
           ^
src/appmake/zx-util.c:2103:32: warning: Either the condition '(fout=fopen(outname,"wb"))==NULL' is redundant or there is possible null pointer dereference: fout. [nullPointerRedundantCheck]
    fwrite(&nh, sizeof(nh), 1, fout);
                               ^
src/appmake/zx-util.c:1903:39: note: Assuming that condition '(fout=fopen(outname,"wb"))==NULL' is not redundant
    if ((fout = fopen(outname, "wb")) == NULL)
                                      ^
src/appmake/zx-util.c:2103:32: note: Null pointer dereference
    fwrite(&nh, sizeof(nh), 1, fout);
                               ^
src/appmake/zx-util.c:2105:12: warning: Either the condition '(fout=fopen(outname,"wb"))==NULL' is redundant or there is possible null pointer dereference: fout. [nullPointerRedundantCheck]
    fclose(fout);
           ^
src/appmake/zx-util.c:1903:39: note: Assuming that condition '(fout=fopen(outname,"wb"))==NULL' is not redundant
    if ((fout = fopen(outname, "wb")) == NULL)
                                      ^
src/appmake/zx-util.c:2105:12: note: Null pointer dereference
    fclose(fout);
           ^
src/appmake/zx-util.c:2216:15: warning: Either the condition '(fpin=fopen_bin(zxc->binname,zxc->crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/zx-util.c:2212:56: note: Assuming that condition '(fpin=fopen_bin(zxc->binname,zxc->crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(zxc->binname, zxc->crtfile)) == NULL) {
                                                       ^
src/appmake/zx-util.c:2216:15: note: Null pointer dereference
    if (fseek(fpin, 0, SEEK_END)) {
              ^
src/appmake/zx-util.c:2221:27: warning: Either the condition '(fpin=fopen_bin(zxc->binname,zxc->crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    binary_length = ftell(fpin);
                          ^
src/appmake/zx-util.c:2212:56: note: Assuming that condition '(fpin=fopen_bin(zxc->binname,zxc->crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(zxc->binname, zxc->crtfile)) == NULL) {
                                                       ^
src/appmake/zx-util.c:2221:27: note: Null pointer dereference
    binary_length = ftell(fpin);
                          ^
src/appmake/zx-util.c:2222:11: warning: Either the condition '(fpin=fopen_bin(zxc->binname,zxc->crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/zx-util.c:2212:56: note: Assuming that condition '(fpin=fopen_bin(zxc->binname,zxc->crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(zxc->binname, zxc->crtfile)) == NULL) {
                                                       ^
src/appmake/zx-util.c:2222:11: note: Null pointer dereference
    fseek(fpin, 0L, SEEK_SET);
          ^
src/appmake/zx-util.c:2290:44: warning: Either the condition 'fpscr==NULL' is redundant or there is possible null pointer dereference: fpscr. [nullPointerRedundantCheck]
        if (6912 != fread(scrbuf, 1, 6912, fpscr)) { fclose(fpscr); exit_log(1, "Could not read required data from <%s>\n",zxt->screen); }
                                           ^
src/appmake/zx-util.c:2285:20: note: Assuming that condition 'fpscr==NULL' is not redundant
        if ( fpscr == NULL ) {
                   ^
src/appmake/zx-util.c:2290:44: note: Null pointer dereference
        if (6912 != fread(scrbuf, 1, 6912, fpscr)) { fclose(fpscr); exit_log(1, "Could not read required data from <%s>\n",zxt->screen); }
                                           ^
src/appmake/zx-util.c:2291:16: warning: Either the condition 'fpscr==NULL' is redundant or there is possible null pointer dereference: fpscr. [nullPointerRedundantCheck]
        fclose(fpscr);
               ^
src/appmake/zx-util.c:2285:20: note: Assuming that condition 'fpscr==NULL' is not redundant
        if ( fpscr == NULL ) {
                   ^
src/appmake/zx-util.c:2291:16: note: Null pointer dereference
        fclose(fpscr);
               ^
src/appmake/zx-util.c:2299:55: warning: Either the condition '(fpin=fopen_bin(zxc->binname,zxc->crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    if (binary_length != fread(ptr, 1, binary_length, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",zxc->binname); }
                                                      ^
src/appmake/zx-util.c:2212:56: note: Assuming that condition '(fpin=fopen_bin(zxc->binname,zxc->crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(zxc->binname, zxc->crtfile)) == NULL) {
                                                       ^
src/appmake/zx-util.c:2299:55: note: Null pointer dereference
    if (binary_length != fread(ptr, 1, binary_length, fpin)) { fclose(fpin); exit_log(1, "Could not read required data from <%s>\n",zxc->binname); }
                                                      ^
src/appmake/zx-util.c:2300:12: warning: Either the condition '(fpin=fopen_bin(zxc->binname,zxc->crtfile))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
    fclose(fpin);
           ^
src/appmake/zx-util.c:2212:56: note: Assuming that condition '(fpin=fopen_bin(zxc->binname,zxc->crtfile))==NULL' is not redundant
    if ((fpin = fopen_bin(zxc->binname, zxc->crtfile)) == NULL) {
                                                       ^
src/appmake/zx-util.c:2300:12: note: Null pointer dereference
    fclose(fpin);
           ^
src/appmake/zx-util.c:2322:76: warning: Either the condition 'fpbank==NULL' is redundant or there is possible null pointer dereference: fpbank. [nullPointerRedundantCheck]
            if ( mb->secbin->size != fread(bank_buf, 1,  mb->secbin->size, fpbank)) {  exit_log(1, "Could not read required data from <%s>\n",mb->secbin->filename); }
                                                                           ^
src/appmake/zx-util.c:2319:25: note: Assuming that condition 'fpbank==NULL' is not redundant
            if ( fpbank == NULL ) {
                        ^
src/appmake/zx-util.c:2322:76: note: Null pointer dereference
            if ( mb->secbin->size != fread(bank_buf, 1,  mb->secbin->size, fpbank)) {  exit_log(1, "Could not read required data from <%s>\n",mb->secbin->filename); }
                                                                           ^
src/appmake/zx-util.c:2328:20: warning: Either the condition 'fpbank==NULL' is redundant or there is possible null pointer dereference: fpbank. [nullPointerRedundantCheck]
            fclose(fpbank);
                   ^
src/appmake/zx-util.c:2319:25: note: Assuming that condition 'fpbank==NULL' is not redundant
            if ( fpbank == NULL ) {
                        ^
src/appmake/zx-util.c:2328:20: note: Null pointer dereference
            fclose(fpbank);
                   ^
src/appmake/zx-util.c:709:19: style: Variable 'c' is reassigned a value before the old one has been used. [redundantAssignment]
                c = -1;
                  ^
src/appmake/zx-util.c:700:23: note: c is assigned
                    c = getc(fpin);
                      ^
src/appmake/zx-util.c:709:19: note: c is overwritten
                c = -1;
                  ^
src/appmake/zx-util.c:988:25: style: Variable 'appmake_handle' is reassigned a value before the old one has been used. [redundantAssignment]
    if ((appmake_handle = parameter_search(zxc->crtfile, ".map", "__appmake_handle")) < 0)
                        ^
src/appmake/zx-util.c:986:20: note: appmake_handle is assigned
    appmake_handle = user_handle = -1;
                   ^
src/appmake/zx-util.c:988:25: note: appmake_handle is overwritten
    if ((appmake_handle = parameter_search(zxc->crtfile, ".map", "__appmake_handle")) < 0)
                        ^
src/appmake/zx-util.c:49:11: style: The scope of the variable 'fin' can be reduced. [variableScope]
    FILE *fin;
          ^
src/appmake/zx-util.c:177:9: style: The scope of the variable 'i' can be reduced. [variableScope]
    int i;
        ^
src/appmake/zx-util.c:204:13: style: The scope of the variable 'wavfile' can be reduced. [variableScope]
    char    wavfile[FILENAME_MAX + 1];
            ^
src/appmake/zx-util.c:205:13: style: The scope of the variable 'name' can be reduced. [variableScope]
    char    name[11];
            ^
src/appmake/zx-util.c:206:13: style: The scope of the variable 'mybuf' can be reduced. [variableScope]
    char    mybuf[20];
            ^
src/appmake/zx-util.c:207:29: style: The scope of the variable 'fpmerge' can be reduced. [variableScope]
    FILE    *fpin, *fpout, *fpmerge;
                            ^
src/appmake/zx-util.c:209:20: style: The scope of the variable 'd' can be reduced. [variableScope]
    int     c = 0, d;
                   ^
src/appmake/zx-util.c:210:13: style: The scope of the variable 'warping' can be reduced. [variableScope]
    int     warping;
            ^
src/appmake/zx-util.c:211:16: style: The scope of the variable 'j' can be reduced. [variableScope]
    int     i, j, blocklen;
               ^
src/appmake/zx-util.c:212:18: style: The scope of the variable 'mlen' can be reduced. [variableScope]
    int     len, mlen;
                 ^
src/appmake/zx-util.c:213:10: style: The scope of the variable 'blockcount' can be reduced. [variableScope]
    int  blockcount, bsnum_bank;
         ^
src/appmake/zx-util.c:213:22: style: The scope of the variable 'bsnum_bank' can be reduced. [variableScope]
    int  blockcount, bsnum_bank;
                     ^
src/appmake/zx-util.c:1544:12: style: The scope of the variable 'j' can be reduced. [variableScope]
    int i, j;
           ^
src/appmake/zx-util.c:1856:13: style: The scope of the variable 'j' can be reduced. [variableScope]
    int  i, j;
            ^
src/appmake/zx-util.c:1864:9: style: The scope of the variable 'mainbank_occupied' can be reduced. [variableScope]
    int mainbank_occupied;
        ^
src/appmake/zx-util.c:2086:29: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
    nh.SP[1] = (register_sp >> 8) & 0xff;
                            ^
src/appmake/zx-util.c:2089:30: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
    nh.PC[1] = (crt_org_code >> 8) & 0xff;
                             ^
src/appmake/zx-util.c:629:30: style: Local variable 'j' shadows outer variable [shadowVariable]
                    int      j;
                             ^
src/appmake/zx-util.c:211:16: note: Shadowed declaration
    int     i, j, blocklen;
               ^
src/appmake/zx-util.c:629:30: note: Shadow variable
                    int      j;
                             ^
src/appmake/zx.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/zx.c:390:61: style: Same expression on both sides of '-'. [duplicateExpression]
                                mb->secbin[j].org += 0xc000 - 0xc000;
                                                            ^
src/appmake/zx81.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/zx81.c:134:13: error: Resource handle 'fpin' freed twice. [doubleFree]
            fclose(fpin);
            ^
src/appmake/zx81.c:125:13: note: Resource handle 'fpin' freed twice.
            fclose(fpin);
            ^
src/appmake/zx81.c:134:13: note: Resource handle 'fpin' freed twice.
            fclose(fpin);
            ^
src/appmake/zx81.c:124:19: warning: Either the condition '(fpin=fopen_bin(binname,NULL))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/zx81.c:116:47: note: Assuming that condition '(fpin=fopen_bin(binname,NULL))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, NULL)) == NULL) {
                                              ^
src/appmake/zx81.c:124:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/zx81.c:129:21: warning: Either the condition '(fpin=fopen_bin(binname,NULL))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin);
                    ^
src/appmake/zx81.c:116:47: note: Assuming that condition '(fpin=fopen_bin(binname,NULL))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, NULL)) == NULL) {
                                              ^
src/appmake/zx81.c:129:21: note: Null pointer dereference
        len = ftell(fpin);
                    ^
src/appmake/zx81.c:131:15: warning: Either the condition '(fpin=fopen_bin(binname,NULL))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/zx81.c:116:47: note: Assuming that condition '(fpin=fopen_bin(binname,NULL))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, NULL)) == NULL) {
                                              ^
src/appmake/zx81.c:131:15: note: Null pointer dereference
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/zx81.c:511:16: warning: Either the condition '(fpin=fopen_bin(binname,NULL))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fclose(fpin);
               ^
src/appmake/zx81.c:116:47: note: Assuming that condition '(fpin=fopen_bin(binname,NULL))==NULL' is not redundant
        if ((fpin = fopen_bin(binname, NULL)) == NULL) {
                                              ^
src/appmake/zx81.c:511:16: note: Null pointer dereference
        fclose(fpin);
               ^
src/appmake/zx81.c:512:16: warning: Either the condition '(fpout=fopen(filename,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fclose(fpout);
               ^
src/appmake/zx81.c:133:45: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant
        if ((fpout = fopen(filename, "wb")) == NULL) {
                                            ^
src/appmake/zx81.c:512:16: note: Null pointer dereference
        fclose(fpout);
               ^
src/appmake/zx81.c:523:19: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/zx81.c:519:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/zx81.c:523:19: note: Null pointer dereference
        if (fseek(fpin, 0, SEEK_END)) {
                  ^
src/appmake/zx81.c:527:21: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        len = ftell(fpin);
                    ^
src/appmake/zx81.c:519:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/zx81.c:527:21: note: Null pointer dereference
        len = ftell(fpin);
                    ^
src/appmake/zx81.c:528:15: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/zx81.c:519:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/zx81.c:528:15: note: Null pointer dereference
        fseek(fpin, 0L, SEEK_SET);
              ^
src/appmake/zx81.c:578:16: warning: Either the condition '(fpin=fopen(filename,"rb"))==NULL' is redundant or there is possible null pointer dereference: fpin. [nullPointerRedundantCheck]
        fclose(fpin);
               ^
src/appmake/zx81.c:519:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant
        if ((fpin = fopen(filename, "rb")) == NULL) {
                                           ^
src/appmake/zx81.c:578:16: note: Null pointer dereference
        fclose(fpin);
               ^
src/appmake/zx81.c:579:16: warning: Either the condition '(fpout=fopen(wavfile,"wb"))==NULL' is redundant or there is possible null pointer dereference: fpout. [nullPointerRedundantCheck]
        fclose(fpout);
               ^
src/appmake/zx81.c:532:44: note: Assuming that condition '(fpout=fopen(wavfile,"wb"))==NULL' is not redundant
        if ((fpout = fopen(wavfile, "wb")) == NULL) {
                                           ^
src/appmake/zx81.c:579:16: note: Null pointer dereference
        fclose(fpout);
               ^
src/appmake/zx81.c:87:10: style: The scope of the variable 'wavfile' can be reduced. [variableScope]
    char wavfile[FILENAME_MAX + 1];
         ^
src/appmake/zx81.c:93:9: style: The scope of the variable 'screen_size' can be reduced. [variableScope]
    int screen_size;
        ^
src/appmake/zxn.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/zxn.c:262:12: warning: Either the condition '(fmap=fopen(filename,"r"))==NULL' is redundant or there is possible null pointer dereference: fmap. [nullPointerRedundantCheck]
    fclose(fmap);
           ^
src/appmake/zxn.c:257:39: note: Assuming that condition '(fmap=fopen(filename,"r"))==NULL' is not redundant
    if ((fmap = fopen(filename, "r")) == NULL)
                                      ^
src/appmake/zxn.c:262:12: note: Null pointer dereference
    fclose(fmap);
           ^
src/appmake/zxn.c:492:61: style: Same expression on both sides of '-'. [duplicateExpression]
                                mb->secbin[j].org += 0xc000 - 0xc000;
                                                            ^
src/appmake/zxn.c:173:12: style: The scope of the variable 'p' can be reduced. [variableScope]
    char  *p;
           ^
src/appmake/zxvgs.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/appmake/zxvgs.c:79:9: error: Resource handle 'binfile' freed twice. [doubleFree]
        fclose(binfile);
        ^
src/appmake/zxvgs.c:73:9: note: Resource handle 'binfile' freed twice.
        fclose(binfile);
        ^
src/appmake/zxvgs.c:79:9: note: Resource handle 'binfile' freed twice.
        fclose(binfile);
        ^
src/appmake/zxvgs.c:87:9: error: Resource handle 'binfile' freed twice. [doubleFree]
        fclose(binfile);
        ^
src/appmake/zxvgs.c:73:9: note: Resource handle 'binfile' freed twice.
        fclose(binfile);
        ^
src/appmake/zxvgs.c:87:9: note: Resource handle 'binfile' freed twice.
        fclose(binfile);
        ^
src/appmake/zxvgs.c:90:5: error: Resource handle 'binfile' freed twice. [doubleFree]
    fclose(binfile);
    ^
src/appmake/zxvgs.c:73:9: note: Resource handle 'binfile' freed twice.
        fclose(binfile);
        ^
src/appmake/zxvgs.c:90:5: note: Resource handle 'binfile' freed twice.
    fclose(binfile);
    ^
src/appmake/zxvgs.c:72:15: warning: Either the condition 'binfile==NULL' is redundant or there is possible null pointer dereference: binfile. [nullPointerRedundantCheck]
    if (fseek(binfile, 0, SEEK_END)) {
              ^
src/appmake/zxvgs.c:69:17: note: Assuming that condition 'binfile==NULL' is not redundant
    if (binfile == NULL)
                ^
src/appmake/zxvgs.c:72:15: note: Null pointer dereference
    if (fseek(binfile, 0, SEEK_END)) {
              ^
src/appmake/zxvgs.c:77:22: warning: Either the condition 'binfile==NULL' is redundant or there is possible null pointer dereference: binfile. [nullPointerRedundantCheck]
    filesize = ftell(binfile);
                     ^
src/appmake/zxvgs.c:69:17: note: Assuming that condition 'binfile==NULL' is not redundant
    if (binfile == NULL)
                ^
src/appmake/zxvgs.c:77:22: note: Null pointer dereference
    filesize = ftell(binfile);
                     ^
src/appmake/zxvgs.c:83:11: warning: Either the condition 'binfile==NULL' is redundant or there is possible null pointer dereference: binfile. [nullPointerRedundantCheck]
    fseek(binfile, 0, SEEK_SET);
          ^
src/appmake/zxvgs.c:69:17: note: Assuming that condition 'binfile==NULL' is not redundant
    if (binfile == NULL)
                ^
src/appmake/zxvgs.c:83:11: note: Null pointer dereference
    fseek(binfile, 0, SEEK_SET);
          ^
src/appmake/zxvgs.c:85:42: warning: Either the condition 'binfile==NULL' is redundant or there is possible null pointer dereference: binfile. [nullPointerRedundantCheck]
    readlen = fread(memory, 1, filesize, binfile);
                                         ^
src/appmake/zxvgs.c:69:17: note: Assuming that condition 'binfile==NULL' is not redundant
    if (binfile == NULL)
                ^
src/appmake/zxvgs.c:85:42: note: Null pointer dereference
    readlen = fread(memory, 1, filesize, binfile);
                                         ^
src/appmake/zxvgs.c:90:12: warning: Either the condition 'binfile==NULL' is redundant or there is possible null pointer dereference: binfile. [nullPointerRedundantCheck]
    fclose(binfile);
           ^
src/appmake/zxvgs.c:69:17: note: Assuming that condition 'binfile==NULL' is not redundant
    if (binfile == NULL)
                ^
src/appmake/zxvgs.c:90:12: note: Null pointer dereference
    fclose(binfile);
           ^
src/appmake/zxvgs.c:101:31: warning: Either the condition '(fp=fopen(name,"wb"))==NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    if (fwrite(&header, 1, 3, fp) != 3)
                              ^
src/appmake/zxvgs.c:95:34: note: Assuming that condition '(fp=fopen(name,"wb"))==NULL' is not redundant
    if ((fp = fopen(name, "wb")) == NULL) {
                                 ^
src/appmake/zxvgs.c:101:31: note: Null pointer dereference
    if (fwrite(&header, 1, 3, fp) != 3)
                              ^
src/appmake/zxvgs.c:118:31: warning: Either the condition '(fp=fopen(name,"wb"))==NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    if (fwrite(&header, 1, 3, fp) != 3)
                              ^
src/appmake/zxvgs.c:95:34: note: Assuming that condition '(fp=fopen(name,"wb"))==NULL' is not redundant
    if ((fp = fopen(name, "wb")) == NULL) {
                                 ^
src/appmake/zxvgs.c:118:31: note: Null pointer dereference
    if (fwrite(&header, 1, 3, fp) != 3)
                              ^
src/appmake/zxvgs.c:120:12: warning: Either the condition '(fp=fopen(name,"wb"))==NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    fclose(fp);
           ^
src/appmake/zxvgs.c:95:34: note: Assuming that condition '(fp=fopen(name,"wb"))==NULL' is not redundant
    if ((fp = fopen(name, "wb")) == NULL) {
                                 ^
src/appmake/zxvgs.c:120:12: note: Null pointer dereference
    fclose(fp);
           ^
src/appmake/zxvgs.c:45:18: style: The scope of the variable 'chunk' can be reduced. [variableScope]
    unsigned int chunk; /* chunk size */
                 ^
src/common/dirname.c:22:22: style:inconclusive: Function 'zdirname' argument 1 names different: declaration 'filename' definition 'path'. [funcArgNamesDifferent]
char *zdirname(char *path) {
                     ^
src/common/dirname.h:5:29: note: Function 'zdirname' argument 1 names different: declaration 'filename' definition 'path'.
extern char *zdirname(char *filename);
                            ^
src/common/dirname.c:22:22: note: Function 'zdirname' argument 1 names different: declaration 'filename' definition 'path'.
char *zdirname(char *path) {
                     ^
src/common/dirname.c:28:23: style:inconclusive: Function 'zbasename' argument 1 names different: declaration 'filename' definition 'path'. [funcArgNamesDifferent]
char *zbasename(char *path) {
                      ^
src/common/dirname.h:6:30: note: Function 'zbasename' argument 1 names different: declaration 'filename' definition 'path'.
extern char *zbasename(char *filename);
                             ^
src/common/dirname.c:28:23: note: Function 'zbasename' argument 1 names different: declaration 'filename' definition 'path'.
char *zbasename(char *path) {
                      ^
src/common/fileutil.c:369:26: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
 word[1] = value & 0xFF; value >>= 8;
                         ^
src/common/fileutil.c:379:27: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
 dword[3] = value & 0xFF; value >>= 8;
                          ^
src/common/fileutil.c:140:42: style:inconclusive: Function 'remove_extension' argument 1 names different: declaration 'path' definition 'path1'. [funcArgNamesDifferent]
const char *remove_extension(const char *path1)
                                         ^
src/common/fileutil.h:31:49: note: Function 'remove_extension' argument 1 names different: declaration 'path' definition 'path1'.
extern const char *remove_extension(const char *path);
                                                ^
src/common/fileutil.c:140:42: note: Function 'remove_extension' argument 1 names different: declaration 'path' definition 'path1'.
const char *remove_extension(const char *path1)
                                         ^
src/common/fileutil.c:145:43: style:inconclusive: Function 'replace_extension' argument 1 names different: declaration 'path' definition 'path1'. [funcArgNamesDifferent]
const char *replace_extension(const char *path1, const char *new_ext)
                                          ^
src/common/fileutil.h:32:50: note: Function 'replace_extension' argument 1 names different: declaration 'path' definition 'path1'.
extern const char *replace_extension(const char *path, const char *new_ext);
                                                 ^
src/common/fileutil.c:145:43: note: Function 'replace_extension' argument 1 names different: declaration 'path' definition 'path1'.
const char *replace_extension(const char *path1, const char *new_ext)
                                          ^
src/common/fileutil.c:183:34: style:inconclusive: Function 'path_dir' argument 1 names different: declaration 'path' definition 'path1'. [funcArgNamesDifferent]
const char *path_dir(const char *path1)
                                 ^
src/common/fileutil.h:26:41: note: Function 'path_dir' argument 1 names different: declaration 'path' definition 'path1'.
extern const char *path_dir(const char *path);
                                        ^
src/common/fileutil.c:183:34: note: Function 'path_dir' argument 1 names different: declaration 'path' definition 'path1'.
const char *path_dir(const char *path1)
                                 ^
src/common/fileutil.c:199:35: style:inconclusive: Function 'path_file' argument 1 names different: declaration 'path' definition 'path1'. [funcArgNamesDifferent]
const char *path_file(const char *path1)
                                  ^
src/common/fileutil.h:27:42: note: Function 'path_file' argument 1 names different: declaration 'path' definition 'path1'.
extern const char *path_file(const char *path);
                                         ^
src/common/fileutil.c:199:35: note: Function 'path_file' argument 1 names different: declaration 'path' definition 'path1'.
const char *path_file(const char *path1)
                                  ^
src/common/fileutil.c:369:32: style: Variable 'value' is assigned a value that is never used. [unreadVariable]
 word[1] = value & 0xFF; value >>= 8;
                               ^
src/common/fileutil.c:379:33: style: Variable 'value' is assigned a value that is never used. [unreadVariable]
 dword[3] = value & 0xFF; value >>= 8;
                                ^
src/common/objfile.c:97:32: warning:inconclusive: Possible null pointer dereference: section [nullPointer]
  if (strcmp(utstr_body(name), utstr_body(section->name)) == 0) {
                               ^
src/common/objfile.c:95:23: note: Assignment 'section=NULL', assigned value is 0
 section_t* section = NULL;
                      ^
src/common/objfile.c:97:32: note: Null pointer dereference
  if (strcmp(utstr_body(name), utstr_body(section->name)) == 0) {
                               ^
src/common/objfile.c:162:12: style: Variable 'need_nl' is reassigned a value before the old one has been used. [redundantAssignment]
   need_nl = true;
           ^
src/common/objfile.c:159:13: note: need_nl is assigned
    need_nl = false;
            ^
src/common/objfile.c:162:12: note: need_nl is overwritten
   need_nl = true;
           ^
src/common/objfile.c:166:11: style: Variable 'need_nl' is reassigned a value before the old one has been used. [redundantAssignment]
  need_nl = true;
          ^
src/common/objfile.c:162:12: note: need_nl is assigned
   need_nl = true;
           ^
src/common/objfile.c:166:11: note: need_nl is overwritten
  need_nl = true;
          ^
src/common/objfile.c:863:6: style: The scope of the variable 'length' can be reduced. [variableScope]
 int length = 0;
     ^
src/common/objfile.c:294:30: style:inconclusive: Function 'objfile_free' argument 1 names different: declaration 'obj' definition 'self'. [funcArgNamesDifferent]
void objfile_free(objfile_t* self)
                             ^
src/common/objfile.h:123:37: note: Function 'objfile_free' argument 1 names different: declaration 'obj' definition 'self'.
extern void objfile_free(objfile_t* obj);
                                    ^
src/common/objfile.c:294:30: note: Function 'objfile_free' argument 1 names different: declaration 'obj' definition 'self'.
void objfile_free(objfile_t* self)
                             ^
src/common/objfile.c:863:13: style: Variable 'length' is assigned a value that is never used. [unreadVariable]
 int length = 0;
            ^
src/common/t/t_strutil.c:109:14: warning: Unnecessary comparison of static strings. [staticStringCompare]
 TEST_ASSERT(strcasecmp("", "") == 0);
             ^
src/common/t/t_strutil.c:110:14: warning: Unnecessary comparison of static strings. [staticStringCompare]
 TEST_ASSERT(strcasecmp("a", "") > 0);
             ^
src/common/t/t_strutil.c:111:14: warning: Unnecessary comparison of static strings. [staticStringCompare]
 TEST_ASSERT(strcasecmp("", "a") < 0);
             ^
src/common/t/t_strutil.c:112:14: warning: Unnecessary comparison of static strings. [staticStringCompare]
 TEST_ASSERT(strcasecmp("a", "a") == 0);
             ^
src/common/t/t_strutil.c:113:14: warning: Unnecessary comparison of static strings. [staticStringCompare]
 TEST_ASSERT(strcasecmp("a", "A") == 0);
             ^
src/common/t/t_strutil.c:114:14: warning: Unnecessary comparison of static strings. [staticStringCompare]
 TEST_ASSERT(strcasecmp("A", "a") == 0);
             ^
src/common/t/t_strutil.c:115:14: warning: Unnecessary comparison of static strings. [staticStringCompare]
 TEST_ASSERT(strcasecmp("ab", "a") > 0);
             ^
src/common/t/t_strutil.c:116:14: warning: Unnecessary comparison of static strings. [staticStringCompare]
 TEST_ASSERT(strcasecmp("a", "ab") < 0);
             ^
src/common/t/t_strutil.c:117:14: warning: Unnecessary comparison of static strings. [staticStringCompare]
 TEST_ASSERT(strcasecmp("ab", "ab") == 0);
             ^
src/common/t/t_strutil.c:122:14: warning: Unnecessary comparison of static strings. [staticStringCompare]
 TEST_ASSERT(strncasecmp("", "", 0) == 0);
             ^
src/common/t/t_strutil.c:123:14: warning: Unnecessary comparison of static strings. [staticStringCompare]
 TEST_ASSERT(strncasecmp("x", "y", 0) == 0);
             ^
src/common/t/t_strutil.c:124:14: warning: Unnecessary comparison of static strings. [staticStringCompare]
 TEST_ASSERT(strncasecmp("a", "", 1) > 0);
             ^
src/common/t/t_strutil.c:125:14: warning: Unnecessary comparison of static strings. [staticStringCompare]
 TEST_ASSERT(strncasecmp("", "a", 1) < 0);
             ^
src/common/t/t_strutil.c:126:14: warning: Unnecessary comparison of static strings. [staticStringCompare]
 TEST_ASSERT(strncasecmp("ax", "ay", 1) == 0);
             ^
src/common/t/t_strutil.c:127:14: warning: Unnecessary comparison of static strings. [staticStringCompare]
 TEST_ASSERT(strncasecmp("ax", "Ay", 1) == 0);
             ^
src/common/t/t_strutil.c:128:14: warning: Unnecessary comparison of static strings. [staticStringCompare]
 TEST_ASSERT(strncasecmp("Ax", "ay", 1) == 0);
             ^
src/common/t/t_strutil.c:129:14: warning: Unnecessary comparison of static strings. [staticStringCompare]
 TEST_ASSERT(strncasecmp("abx", "a", 2) > 0);
             ^
src/common/t/t_strutil.c:130:14: warning: Unnecessary comparison of static strings. [staticStringCompare]
 TEST_ASSERT(strncasecmp("a", "aby", 2) < 0);
             ^
src/common/t/t_strutil.c:131:14: warning: Unnecessary comparison of static strings. [staticStringCompare]
 TEST_ASSERT(strncasecmp("abx", "aby", 2) == 0);
             ^
src/common/zutils.c:119:10: style: The scope of the variable 'c2' can be reduced. [variableScope]
 int c1, c2;
         ^
src/common/zutils.c:47:11: style: Variable 'base' is assigned a value that is never used. [unreadVariable]
 int base = 0, max_digits, digit;
          ^
src/copt/copt.c:234:9: warning: sscanf() without field width limits can crash with huge input data. [invalidscanf]
    x = sscanf(pat, "%d = %[^\n]s", &expected, expr);
        ^
src/copt/copt.c:669:13: error: Common realloc mistake: 'c_options' nulled but not freed upon failure [memleakOnRealloc]
            c_options = realloc(c_options, c_options_num * sizeof(c_options[0]));
            ^
src/copt/copt.c:806:23: style: Local variable 'endptr' shadows outer variable [shadowVariable]
                char *endptr;
                      ^
src/copt/copt.c:735:11: note: Shadowed declaration
    char* endptr;
          ^
src/copt/copt.c:806:23: note: Shadow variable
                char *endptr;
                      ^
src/copt/regex/engine.c:634:15: style: The scope of the variable 'lastc' can be reduced. [variableScope]
 register int lastc; /* previous c */
              ^
src/copt/regex/engine.c:635:15: style: The scope of the variable 'flagch' can be reduced. [variableScope]
 register int flagch;
              ^
src/copt/regex/engine.c:636:15: style: The scope of the variable 'i' can be reduced. [variableScope]
 register int i;
              ^
src/copt/regex/engine.c:725:15: style: The scope of the variable 'lastc' can be reduced. [variableScope]
 register int lastc; /* previous c */
              ^
src/copt/regex/engine.c:726:15: style: The scope of the variable 'flagch' can be reduced. [variableScope]
 register int flagch;
              ^
src/copt/regex/engine.c:727:15: style: The scope of the variable 'i' can be reduced. [variableScope]
 register int i;
              ^
src/copt/regex/regcomp.c:199:16: style: The scope of the variable 'c' can be reduced. [variableScope]
 register char c;
               ^
src/copt/regex/regcomp.c:202:17: style: The scope of the variable 'conc' can be reduced. [variableScope]
 register sopno conc;
                ^
src/copt/regex/regcomp.c:1023:18: style: The scope of the variable 'nc' can be reduced. [variableScope]
 register size_t nc;
                 ^
src/copt/regex/regcomp.c:1024:18: style: The scope of the variable 'nbytes' can be reduced. [variableScope]
 register size_t nbytes;
                 ^
src/copt/regex/regcomp.c:1027:15: style: The scope of the variable 'i' can be reduced. [variableScope]
 register int i;
              ^
src/copt/regex/regcomp.c:107:9: warning: Redundant assignment of 'cflags' to itself. [selfAssignment]
 cflags = GOODFLAGS(cflags);
        ^
src/copt/regex/regcomp.c:363:0: information: Skipping configuration '_POSIX2_RE_DUP_MAX' since the value of '_POSIX2_RE_DUP_MAX' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    count2 = INFINITY;
^
src/copt/regex/regcomp.c:541:0: information: Skipping configuration '_POSIX2_RE_DUP_MAX' since the value of '_POSIX2_RE_DUP_MAX' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    count2 = INFINITY;
^
src/copt/regex/regcomp.c:568:0: information: Skipping configuration '_POSIX2_RE_DUP_MAX' since the value of '_POSIX2_RE_DUP_MAX' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 while (MORE() && isdigit(PEEK()) && count <= DUPMAX) {
^
src/copt/regex/regcomp.c:573:0: information: Skipping configuration '_POSIX2_RE_DUP_MAX' since the value of '_POSIX2_RE_DUP_MAX' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 REQUIRE(ndigits > 0 && count <= DUPMAX, REG_BADBR);
^
src/copt/regex/regcomp.c:949:0: information: Skipping configuration '_POSIX2_RE_DUP_MAX' since the value of '_POSIX2_RE_DUP_MAX' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 switch (REP(MAP(from), MAP(to))) {
^
src/copt/regex/engine.c:639:2: style: Redundant initialization for 'st'. The initialized value is overwritten before it is read. [redundantInitialization]
 CLEAR(st);
 ^
src/copt/regex/engine.c:629:21: note: st is initialized
 register states st = m->st;
                    ^
src/copt/regex/engine.c:639:2: note: st is overwritten
 CLEAR(st);
 ^
src/copt/regex/engine.c:642:2: style: Redundant initialization for 'fresh'. The initialized value is overwritten before it is read. [redundantInitialization]
 ASSIGN(fresh, st);
 ^
src/copt/regex/engine.c:630:24: note: fresh is initialized
 register states fresh = m->fresh;
                       ^
src/copt/regex/engine.c:642:2: note: fresh is overwritten
 ASSIGN(fresh, st);
 ^
src/copt/regex/engine.c:731:2: style: Redundant initialization for 'st'. The initialized value is overwritten before it is read. [redundantInitialization]
 CLEAR(st);
 ^
src/copt/regex/engine.c:720:21: note: st is initialized
 register states st = m->st;
                    ^
src/copt/regex/engine.c:731:2: note: st is overwritten
 CLEAR(st);
 ^
src/copt/regex/engine.c:818:15: style: The scope of the variable 's' can be reduced. [variableScope]
 register sop s;
              ^
src/copt/regex/engine.c:631:22: style: Variable 'tmp' is assigned a value that is never used. [unreadVariable]
 register states tmp = m->tmp;
                     ^
src/copt/regex/engine.c:722:22: style: Variable 'tmp' is assigned a value that is never used. [unreadVariable]
 register states tmp = m->tmp;
                     ^
src/copt/regex/regexec.c:136:9: warning: Redundant assignment of 'eflags' to itself. [selfAssignment]
 eflags = GOODFLAGS(eflags);
        ^
src/sccz80/callfunc.c:109:11: style: The scope of the variable 'i' can be reduced. [variableScope]
    int   i;
          ^
src/sccz80/callfunc.c:95:38: style:inconclusive: Function 'callfunction' argument 2 names different: declaration 'func_ptr_call_type' definition 'fnptr_type'. [funcArgNamesDifferent]
void callfunction(SYMBOL *ptr, Type *fnptr_type)
                                     ^
src/sccz80/ccdefs.h:50:49: note: Function 'callfunction' argument 2 names different: declaration 'func_ptr_call_type' definition 'fnptr_type'.
extern void     callfunction(SYMBOL *ptr, Type *func_ptr_call_type);
                                                ^
src/sccz80/callfunc.c:95:38: note: Function 'callfunction' argument 2 names different: declaration 'func_ptr_call_type' definition 'fnptr_type'.
void callfunction(SYMBOL *ptr, Type *fnptr_type)
                                     ^
src/sccz80/callfunc.c:395:37: style:inconclusive: Function 'SetWatch' argument 2 names different: declaration 'isscanf' definition 'type'. [funcArgNamesDifferent]
static int SetWatch(char* sym, int* type)
                                    ^
src/sccz80/callfunc.c:19:37: note: Function 'SetWatch' argument 2 names different: declaration 'isscanf' definition 'type'.
static int SetWatch(char* sym, int* isscanf);
                                    ^
src/sccz80/callfunc.c:395:37: note: Function 'SetWatch' argument 2 names different: declaration 'isscanf' definition 'type'.
static int SetWatch(char* sym, int* type)
                                    ^
src/sccz80/callfunc.c:99:16: style: Local variable 'vconst' shadows outer function [shadowFunction]
    int nargs, vconst, expr, argnumber;
               ^
src/sccz80/codegen.h:38:13: note: Shadowed declaration
extern void vconst(int64_t val);
            ^
src/sccz80/callfunc.c:99:16: note: Shadow variable
    int nargs, vconst, expr, argnumber;
               ^
src/sccz80/callfunc.c:127:25: style: Variable 'minifunc' is assigned a value that is never used. [unreadVariable]
    watcharg = minifunc = 0;
                        ^
src/sccz80/callfunc.c:153:14: style: Variable 'expr' is assigned a value that is never used. [unreadVariable]
        expr = expression(&vconst, &val, &type);
             ^
src/sccz80/callfunc.c:321:26: style: Variable 'minifunc' is assigned a value that is never used. [unreadVariable]
                minifunc = SetMiniFunc(litq + (int)val + 1, &format_option);
                         ^
src/sccz80/callfunc.c:73:5: error: Common realloc mistake: 'tmpfiles' nulled but not freed upon failure [memleakOnRealloc]
    tmpfiles = REALLOC(tmpfiles, (tmpfiles_num+1) * sizeof(tmpfiles[0]));
    ^
src/sccz80/callfunc.c:106:11: style: Local variable 'tmpfiles' shadows outer variable [shadowVariable]
    FILE *tmpfiles[100];  // 100 arguments enough I guess */
          ^
src/sccz80/callfunc.c:40:15: note: Shadowed declaration
static char **tmpfiles = NULL;
              ^
src/sccz80/callfunc.c:106:11: note: Shadow variable
    FILE *tmpfiles[100];  // 100 arguments enough I guess */
          ^
src/sccz80/cdbfile.c:96:9: style: The scope of the variable 'i' can be reduced. [variableScope]
    int i;
        ^
src/sccz80/codegen.c:5054:24: style: Expression is always false because 'else if' condition matches previous condition at line 5044. [multiCondition]
            if ( value == 0 ) {
                       ^
src/sccz80/codegen.c:273:15: style: Condition 'name!=NULL' is always true [knownConditionTrueFalse]
    if ( name != NULL ) {
              ^
src/sccz80/codegen.c:268:41: note: Assuming that condition 'name==NULL' is not redundant
    if ( current_nspace == name || name == NULL ) {
                                        ^
src/sccz80/codegen.c:273:15: note: Condition 'name!=NULL' is always true
    if ( name != NULL ) {
              ^
src/sccz80/codegen.c:3454:27: style: Condition 'value<8' is always true [knownConditionTrueFalse]
        } else if  (value < 8 ) {
                          ^
src/sccz80/codegen.c:3438:27: note: Assuming that condition 'value>=5' is not redundant
        } else if ( value >= 5 ) {
                          ^
src/sccz80/codegen.c:3454:27: note: Condition 'value<8' is always true
        } else if  (value < 8 ) {
                          ^
src/sccz80/codegen.c:160:11: style: The scope of the variable 'timestr' can be reduced. [variableScope]
    char* timestr;
          ^
src/sccz80/codegen.c:180:11: style: The scope of the variable 'segment' can be reduced. [variableScope]
    char* segment;
          ^
src/sccz80/codegen.c:266:16: style: The scope of the variable 'ns' can be reduced. [variableScope]
    namespace *ns;
               ^
src/sccz80/codegen.c:1400:9: style: The scope of the variable 'savesp' can be reduced. [variableScope]
    int savesp;
        ^
src/sccz80/codegen.c:150:30: style:inconclusive: Function 'gen_comment' argument 1 names different: declaration 'comment' definition 'message'. [funcArgNamesDifferent]
void gen_comment(const char *message)
                             ^
src/sccz80/ccdefs.h:60:37: note: Function 'gen_comment' argument 1 names different: declaration 'comment' definition 'message'.
extern void gen_comment(const char *comment);
                                    ^
src/sccz80/codegen.c:150:30: note: Function 'gen_comment' argument 1 names different: declaration 'comment' definition 'message'.
void gen_comment(const char *message)
                             ^
src/sccz80/codegen.c:1102:30: style:inconclusive: Function 'push' argument 1 names different: declaration 'ret' definition 'reg'. [funcArgNamesDifferent]
static void push(const char *reg)
                             ^
src/sccz80/codegen.c:50:30: note: Function 'push' argument 1 names different: declaration 'ret' definition 'reg'.
static void push(const char *ret);
                             ^
src/sccz80/codegen.c:1102:30: note: Function 'push' argument 1 names different: declaration 'ret' definition 'reg'.
static void push(const char *reg)
                             ^
src/sccz80/codegen.c:1108:29: style:inconclusive: Function 'pop' argument 1 names different: declaration 'ret' definition 'reg'. [funcArgNamesDifferent]
static void pop(const char *reg)
                            ^
src/sccz80/codegen.c:51:29: note: Function 'pop' argument 1 names different: declaration 'ret' definition 'reg'.
static void pop(const char *ret);
                            ^
src/sccz80/codegen.c:1108:29: note: Function 'pop' argument 1 names different: declaration 'ret' definition 'reg'.
static void pop(const char *reg)
                            ^
src/sccz80/codegen.c:1122:19: style:inconclusive: Function 'gen_call' argument 1 names different: declaration 'nargs_count' definition 'arg_count'. [funcArgNamesDifferent]
void gen_call(int arg_count, const char *name, SYMBOL *sym)
                  ^
src/sccz80/ccdefs.h:72:26: note: Function 'gen_call' argument 1 names different: declaration 'nargs_count' definition 'arg_count'.
extern void gen_call(int nargs_count, const char *name, SYMBOL *sym);
                         ^
src/sccz80/codegen.c:1122:19: note: Function 'gen_call' argument 1 names different: declaration 'nargs_count' definition 'arg_count'.
void gen_call(int arg_count, const char *name, SYMBOL *sym)
                  ^
src/sccz80/codegen.c:1398:30: style:inconclusive: Function 'gen_leave_function' argument 1 names different: declaration 'save' definition 'vartype'. [funcArgNamesDifferent]
void gen_leave_function(Kind vartype, char type, int incritical)
                             ^
src/sccz80/ccdefs.h:98:37: note: Function 'gen_leave_function' argument 1 names different: declaration 'save' definition 'vartype'.
extern void gen_leave_function(Kind save,char type, int incritical);
                                    ^
src/sccz80/codegen.c:1398:30: note: Function 'gen_leave_function' argument 1 names different: declaration 'save' definition 'vartype'.
void gen_leave_function(Kind vartype, char type, int incritical)
                             ^
src/sccz80/codegen.c:2361:39: style:inconclusive: Function 'zadd_const' argument 2 names different: declaration 'value' definition 'value64'. [funcArgNamesDifferent]
void zadd_const(LVALUE *lval, int64_t value64)
                                      ^
src/sccz80/ccdefs.h:112:46: note: Function 'zadd_const' argument 2 names different: declaration 'value' definition 'value64'.
extern void zadd_const(LVALUE *lval, int64_t value);
                                             ^
src/sccz80/codegen.c:2361:39: note: Function 'zadd_const' argument 2 names different: declaration 'value' definition 'value64'.
void zadd_const(LVALUE *lval, int64_t value64)
                                      ^
src/sccz80/codegen.c:2682:39: style:inconclusive: Function 'mult_const' argument 2 names different: declaration 'value' definition 'value64'. [funcArgNamesDifferent]
void mult_const(LVALUE *lval, int64_t value64)
                                      ^
src/sccz80/ccdefs.h:116:46: note: Function 'mult_const' argument 2 names different: declaration 'value' definition 'value64'.
extern void mult_const(LVALUE *lval, int64_t value);
                                             ^
src/sccz80/codegen.c:2682:39: note: Function 'mult_const' argument 2 names different: declaration 'value' definition 'value64'.
void mult_const(LVALUE *lval, int64_t value64)
                                      ^
src/sccz80/codegen.c:2811:39: style:inconclusive: Function 'zdiv_const' argument 2 names different: declaration 'value' definition 'value64'. [funcArgNamesDifferent]
void zdiv_const(LVALUE *lval, int64_t value64)
                                      ^
src/sccz80/ccdefs.h:119:46: note: Function 'zdiv_const' argument 2 names different: declaration 'value' definition 'value64'.
extern void zdiv_const(LVALUE *lval, int64_t value);
                                             ^
src/sccz80/codegen.c:2811:39: note: Function 'zdiv_const' argument 2 names different: declaration 'value' definition 'value64'.
void zdiv_const(LVALUE *lval, int64_t value64)
                                      ^
src/sccz80/codegen.c:2981:39: style:inconclusive: Function 'zmod_const' argument 2 names different: declaration 'value' definition 'value64'. [funcArgNamesDifferent]
void zmod_const(LVALUE *lval, int64_t value64)
                                      ^
src/sccz80/ccdefs.h:122:46: note: Function 'zmod_const' argument 2 names different: declaration 'value' definition 'value64'.
extern void zmod_const(LVALUE *lval, int64_t value);
                                             ^
src/sccz80/codegen.c:2981:39: note: Function 'zmod_const' argument 2 names different: declaration 'value' definition 'value64'.
void zmod_const(LVALUE *lval, int64_t value64)
                                      ^
src/sccz80/codegen.c:3175:38: style:inconclusive: Function 'zor_const' argument 2 names different: declaration 'value' definition 'value64'. [funcArgNamesDifferent]
void zor_const(LVALUE *lval, int64_t value64)
                                     ^
src/sccz80/ccdefs.h:124:45: note: Function 'zor_const' argument 2 names different: declaration 'value' definition 'value64'.
extern void zor_const(LVALUE *lval, int64_t value);
                                            ^
src/sccz80/codegen.c:3175:38: note: Function 'zor_const' argument 2 names different: declaration 'value' definition 'value64'.
void zor_const(LVALUE *lval, int64_t value64)
                                     ^
src/sccz80/codegen.c:3243:39: style:inconclusive: Function 'zxor_const' argument 2 names different: declaration 'value' definition 'value64'. [funcArgNamesDifferent]
void zxor_const(LVALUE *lval, int64_t value64)
                                      ^
src/sccz80/ccdefs.h:126:46: note: Function 'zxor_const' argument 2 names different: declaration 'value' definition 'value64'.
extern void zxor_const(LVALUE *lval, int64_t value);
                                             ^
src/sccz80/codegen.c:3243:39: note: Function 'zxor_const' argument 2 names different: declaration 'value' definition 'value64'.
void zxor_const(LVALUE *lval, int64_t value64)
                                      ^
src/sccz80/codegen.c:3312:39: style:inconclusive: Function 'zand_const' argument 2 names different: declaration 'value' definition 'value64'. [funcArgNamesDifferent]
void zand_const(LVALUE *lval, int64_t value64)
                                      ^
src/sccz80/ccdefs.h:128:46: note: Function 'zand_const' argument 2 names different: declaration 'value' definition 'value64'.
extern void zand_const(LVALUE *lval, int64_t value);
                                             ^
src/sccz80/codegen.c:3312:39: note: Function 'zand_const' argument 2 names different: declaration 'value' definition 'value64'.
void zand_const(LVALUE *lval, int64_t value64)
                                      ^
src/sccz80/codegen.c:3431:38: style:inconclusive: Function 'asr_const' argument 2 names different: declaration 'value' definition 'value64'. [funcArgNamesDifferent]
void asr_const(LVALUE *lval, int64_t value64)
                                     ^
src/sccz80/ccdefs.h:130:45: note: Function 'asr_const' argument 2 names different: declaration 'value' definition 'value64'.
extern void asr_const(LVALUE *lval, int64_t value);
                                            ^
src/sccz80/codegen.c:3431:38: note: Function 'asr_const' argument 2 names different: declaration 'value' definition 'value64'.
void asr_const(LVALUE *lval, int64_t value64)
                                     ^
src/sccz80/codegen.c:3868:38: style:inconclusive: Function 'asl_const' argument 2 names different: declaration 'value' definition 'value64'. [funcArgNamesDifferent]
void asl_const(LVALUE *lval, int64_t value64)
                                     ^
src/sccz80/ccdefs.h:132:45: note: Function 'asl_const' argument 2 names different: declaration 'value' definition 'value64'.
extern void asl_const(LVALUE *lval, int64_t value);
                                            ^
src/sccz80/codegen.c:3868:38: note: Function 'asl_const' argument 2 names different: declaration 'value' definition 'value64'.
void asl_const(LVALUE *lval, int64_t value64)
                                     ^
src/sccz80/codegen.c:4211:24: style:inconclusive: Function 'zeq_const' argument 1 names different: declaration 'm' definition 'lval'. [funcArgNamesDifferent]
void zeq_const(LVALUE *lval, int64_t value64)
                       ^
src/sccz80/ccdefs.h:139:31: note: Function 'zeq_const' argument 1 names different: declaration 'm' definition 'lval'.
extern void zeq_const(LVALUE *m, int64_t value);
                              ^
src/sccz80/codegen.c:4211:24: note: Function 'zeq_const' argument 1 names different: declaration 'm' definition 'lval'.
void zeq_const(LVALUE *lval, int64_t value64)
                       ^
src/sccz80/codegen.c:4211:38: style:inconclusive: Function 'zeq_const' argument 2 names different: declaration 'value' definition 'value64'. [funcArgNamesDifferent]
void zeq_const(LVALUE *lval, int64_t value64)
                                     ^
src/sccz80/ccdefs.h:139:42: note: Function 'zeq_const' argument 2 names different: declaration 'value' definition 'value64'.
extern void zeq_const(LVALUE *m, int64_t value);
                                         ^
src/sccz80/codegen.c:4211:38: note: Function 'zeq_const' argument 2 names different: declaration 'value' definition 'value64'.
void zeq_const(LVALUE *lval, int64_t value64)
                                     ^
src/sccz80/codegen.c:4393:38: style:inconclusive: Function 'zne_const' argument 2 names different: declaration 'value' definition 'value64'. [funcArgNamesDifferent]
void zne_const(LVALUE *lval, int64_t value64)
                                     ^
src/sccz80/ccdefs.h:142:41: note: Function 'zne_const' argument 2 names different: declaration 'value' definition 'value64'.
extern void zne_const(LVALUE *, int64_t value);
                                        ^
src/sccz80/codegen.c:4393:38: note: Function 'zne_const' argument 2 names different: declaration 'value' definition 'value64'.
void zne_const(LVALUE *lval, int64_t value64)
                                     ^
src/sccz80/codegen.c:4576:38: style:inconclusive: Function 'zlt_const' argument 2 names different: declaration 'value' definition 'value64'. [funcArgNamesDifferent]
void zlt_const(LVALUE *lval, int64_t value64)
                                     ^
src/sccz80/ccdefs.h:144:41: note: Function 'zlt_const' argument 2 names different: declaration 'value' definition 'value64'.
extern void zlt_const(LVALUE *, int64_t value);
                                        ^
src/sccz80/codegen.c:4576:38: note: Function 'zlt_const' argument 2 names different: declaration 'value' definition 'value64'.
void zlt_const(LVALUE *lval, int64_t value64)
                                     ^
src/sccz80/codegen.c:4753:38: style:inconclusive: Function 'zle_const' argument 2 names different: declaration 'value' definition 'value64'. [funcArgNamesDifferent]
void zle_const(LVALUE *lval, int64_t value64)
                                     ^
src/sccz80/ccdefs.h:146:41: note: Function 'zle_const' argument 2 names different: declaration 'value' definition 'value64'.
extern void zle_const(LVALUE *, int64_t value);
                                        ^
src/sccz80/codegen.c:4753:38: note: Function 'zle_const' argument 2 names different: declaration 'value' definition 'value64'.
void zle_const(LVALUE *lval, int64_t value64)
                                     ^
src/sccz80/codegen.c:4885:38: style:inconclusive: Function 'zgt_const' argument 2 names different: declaration 'value' definition 'value64'. [funcArgNamesDifferent]
void zgt_const(LVALUE *lval, int64_t value64)
                                     ^
src/sccz80/ccdefs.h:148:41: note: Function 'zgt_const' argument 2 names different: declaration 'value' definition 'value64'.
extern void zgt_const(LVALUE *, int64_t value);
                                        ^
src/sccz80/codegen.c:4885:38: note: Function 'zgt_const' argument 2 names different: declaration 'value' definition 'value64'.
void zgt_const(LVALUE *lval, int64_t value64)
                                     ^
src/sccz80/codegen.c:5009:38: style:inconclusive: Function 'zge_const' argument 2 names different: declaration 'value' definition 'value64'. [funcArgNamesDifferent]
void zge_const(LVALUE *lval, int64_t value64)
                                     ^
src/sccz80/ccdefs.h:150:41: note: Function 'zge_const' argument 2 names different: declaration 'value' definition 'value64'.
extern void zge_const(LVALUE *, int64_t value);
                                        ^
src/sccz80/codegen.c:5009:38: note: Function 'zge_const' argument 2 names different: declaration 'value' definition 'value64'.
void zge_const(LVALUE *lval, int64_t value64)
                                     ^
src/sccz80/codegen.c:5199:26: style:inconclusive: Function 'gen_swap_float' argument 1 names different: declaration 'float_type' definition 'type'. [funcArgNamesDifferent]
void gen_swap_float(Kind type)
                         ^
src/sccz80/ccdefs.h:77:33: note: Function 'gen_swap_float' argument 1 names different: declaration 'float_type' definition 'type'.
extern void gen_swap_float(Kind float_type);
                                ^
src/sccz80/codegen.c:5199:26: note: Function 'gen_swap_float' argument 1 names different: declaration 'float_type' definition 'type'.
void gen_swap_float(Kind type)
                         ^
src/sccz80/codegen.c:5768:40: style:inconclusive: Function 'gen_load_constant_as_float' argument 1 names different: declaration 'value' definition 'val'. [funcArgNamesDifferent]
void gen_load_constant_as_float(double val, Kind to, unsigned char isunsigned)
                                       ^
src/sccz80/ccdefs.h:97:47: note: Function 'gen_load_constant_as_float' argument 1 names different: declaration 'value' definition 'val'.
extern void gen_load_constant_as_float(double value, Kind to, unsigned char isunsigned);
                                              ^
src/sccz80/codegen.c:5768:40: note: Function 'gen_load_constant_as_float' argument 1 names different: declaration 'value' definition 'val'.
void gen_load_constant_as_float(double val, Kind to, unsigned char isunsigned)
                                       ^
src/sccz80/codegen.c:5803:110: style:inconclusive: Function 'zconvert_stacked_to_decimal' argument 4 names different: declaration 'float_sign' definition 'float_unsigned'. [funcArgNamesDifferent]
void zconvert_stacked_to_decimal(Kind stacked_kind, Kind float_kind, unsigned char isunsigned, unsigned char float_unsigned, int operator_is_commutative)
                                                                                                             ^
src/sccz80/codegen.h:59:118: note: Function 'zconvert_stacked_to_decimal' argument 4 names different: declaration 'float_sign' definition 'float_unsigned'.
extern void zconvert_stacked_to_decimal(Kind stacked_kind, Kind float_kind, unsigned char isunsigned,  unsigned char float_sign, int operator_is_commutative);
                                                                                                                     ^
src/sccz80/codegen.c:5803:110: note: Function 'zconvert_stacked_to_decimal' argument 4 names different: declaration 'float_sign' definition 'float_unsigned'.
void zconvert_stacked_to_decimal(Kind stacked_kind, Kind float_kind, unsigned char isunsigned, unsigned char float_unsigned, int operator_is_commutative)
                                                                                                             ^
src/sccz80/codegen.c:5854:86: style:inconclusive: Function 'zconvert_to_decimal' argument 4 names different: declaration 'tounsigned' definition 'toissigned'. [funcArgNamesDifferent]
void zconvert_to_decimal(Kind from, Kind to, unsigned char isunsigned, unsigned char toissigned)
                                                                                     ^
src/sccz80/codegen.h:53:93: note: Function 'zconvert_to_decimal' argument 4 names different: declaration 'tounsigned' definition 'toissigned'.
extern void zconvert_to_decimal(Kind from, Kind to, unsigned char isunsigned, unsigned char tounsigned);
                                                                                            ^
src/sccz80/codegen.c:5854:86: note: Function 'zconvert_to_decimal' argument 4 names different: declaration 'tounsigned' definition 'toissigned'.
void zconvert_to_decimal(Kind from, Kind to, unsigned char isunsigned, unsigned char toissigned)
                                                                                     ^
src/sccz80/const.c:304:25: style: Variable 'lval->ltype' is reassigned a value before the old one has been used. [redundantAssignment]
            lval->ltype = type_ulonglong;
                        ^
src/sccz80/const.c:283:25: note: lval->ltype is assigned
            lval->ltype = type_float16;
                        ^
src/sccz80/const.c:304:25: note: lval->ltype is overwritten
            lval->ltype = type_ulonglong;
                        ^
src/sccz80/const.c:304:25: style: Variable 'lval->ltype' is reassigned a value before the old one has been used. [redundantAssignment]
            lval->ltype = type_ulonglong;
                        ^
src/sccz80/const.c:287:25: note: lval->ltype is assigned
            lval->ltype = type_double;
                        ^
src/sccz80/const.c:304:25: note: lval->ltype is overwritten
            lval->ltype = type_ulonglong;
                        ^
src/sccz80/const.c:304:25: style: Variable 'lval->ltype' is reassigned a value before the old one has been used. [redundantAssignment]
            lval->ltype = type_ulonglong;
                        ^
src/sccz80/const.c:293:25: note: lval->ltype is assigned
            lval->ltype = isunsigned ? type_uaccum16 : type_accum16;
                        ^
src/sccz80/const.c:304:25: note: lval->ltype is overwritten
            lval->ltype = type_ulonglong;
                        ^
src/sccz80/const.c:304:25: style: Variable 'lval->ltype' is reassigned a value before the old one has been used. [redundantAssignment]
            lval->ltype = type_ulonglong;
                        ^
src/sccz80/const.c:297:25: note: lval->ltype is assigned
            lval->ltype = isunsigned ? type_uaccum32 : type_accum32;
                        ^
src/sccz80/const.c:304:25: note: lval->ltype is overwritten
            lval->ltype = type_ulonglong;
                        ^
src/sccz80/const.c:343:9: style: The scope of the variable 'k' can be reduced. [variableScope]
    int k;
        ^
src/sccz80/const.c:86:21: style:inconclusive: Function 'fnumber' argument 1 names different: declaration 'val' definition 'lval'. [funcArgNamesDifferent]
int fnumber(LVALUE *lval)
                    ^
src/sccz80/const.c:38:29: note: Function 'fnumber' argument 1 names different: declaration 'val' definition 'lval'.
static int  fnumber(LVALUE *val);
                            ^
src/sccz80/const.c:86:21: note: Function 'fnumber' argument 1 names different: declaration 'val' definition 'lval'.
int fnumber(LVALUE *lval)
                    ^
src/sccz80/const.c:218:13: style: Local variable 'c' shadows outer variable [shadowVariable]
        int c;
            ^
src/sccz80/const.c:187:10: note: Shadowed declaration
    char c;
         ^
src/sccz80/const.c:218:13: note: Shadow variable
        int c;
            ^
src/sccz80/const.c:653:15: style: Local variable 'type' shadows outer variable [shadowVariable]
        Type *type;
              ^
src/sccz80/const.c:596:11: note: Shadowed declaration
    Type *type;
          ^
src/sccz80/const.c:653:15: note: Shadow variable
        Type *type;
              ^
src/sccz80/const.c:664:27: style: Local variable 'mptr' shadows outer variable [shadowVariable]
                    Type *mptr;
                          ^
src/sccz80/data.h:28:12: note: Shadowed declaration
extern int mptr;
           ^
src/sccz80/const.c:664:27: note: Shadow variable
                    Type *mptr;
                          ^
src/sccz80/const.c:963:16: style: Local variable 'mult' shadows outer function [shadowFunction]
        double mult = norm * 16.;
               ^
src/sccz80/ccdefs.h:115:13: note: Shadowed declaration
extern void mult(LVALUE *);
            ^
src/sccz80/const.c:963:16: note: Shadow variable
        double mult = norm * 16.;
               ^
src/sccz80/const.c:973:25: style: Local variable 'res' shadows outer variable [shadowVariable]
                    int res = fs->mantissa[i] + carry;
                        ^
src/sccz80/const.c:964:16: note: Shadowed declaration
        double res = floor(mult);
               ^
src/sccz80/const.c:973:25: note: Shadow variable
                    int res = fs->mantissa[i] + carry;
                        ^
src/sccz80/const.c:118:10: style: Variable 's' is assigned a value that is never used. [unreadVariable]
        s++;
         ^
src/sccz80/declinit.c:106:49: style: Condition 'had_bitfield<=8' is always true [knownConditionTrueFalse]
            outfmt("\t%s\t0x%x\n", had_bitfield <= 8 ? "defb" : "defw", bitfield_value);
                                                ^
src/sccz80/declinit.c:103:21: note: Assuming condition 'had_bitfield' is true
        } else if ( had_bitfield ) {
                    ^
src/sccz80/declinit.c:106:49: note: Condition 'had_bitfield<=8' is always true
            outfmt("\t%s\t0x%x\n", had_bitfield <= 8 ? "defb" : "defw", bitfield_value);
                                                ^
src/sccz80/declinit.c:153:57: style: Condition 'had_bitfield<=8' is always true [knownConditionTrueFalse]
                    outfmt("\t%s\t0x%x\n", had_bitfield <= 8 ? "defb" : "defw", bitfield_value);
                                                        ^
src/sccz80/declinit.c:150:22: note: Assuming condition 'had_bitfield' is true
                if ( had_bitfield ) {
                     ^
src/sccz80/declinit.c:153:57: note: Condition 'had_bitfield<=8' is always true
                    outfmt("\t%s\t0x%x\n", had_bitfield <= 8 ? "defb" : "defw", bitfield_value);
                                                        ^
src/sccz80/declinit.c:199:45: style: Condition 'had_bitfield<=8' is always true [knownConditionTrueFalse]
        outfmt("\t%s\t0x%x\n", had_bitfield <= 8 ? "defb" : "defw", bitfield_value);
                                            ^
src/sccz80/declinit.c:197:10: note: Assuming condition 'had_bitfield' is true
    if ( had_bitfield ) {
         ^
src/sccz80/declinit.c:199:45: note: Condition 'had_bitfield<=8' is always true
        outfmt("\t%s\t0x%x\n", had_bitfield <= 8 ? "defb" : "defw", bitfield_value);
                                            ^
src/sccz80/declinit.c:568:19: style: Variable 'lval.val_type' is reassigned a value before the old one has been used. [redundantAssignment]
    lval.val_type = KIND_DOUBLE;
                  ^
src/sccz80/declinit.c:561:19: note: lval.val_type is assigned
    lval.val_type = KIND_DOUBLE;
                  ^
src/sccz80/declinit.c:568:19: note: lval.val_type is overwritten
    lval.val_type = KIND_DOUBLE;
                  ^
src/sccz80/declinit.c:445:36: style: The scope of the variable 'fa' can be reduced. [variableScope]
                    unsigned char  fa[MAX_MANTISSA_SIZE + 1] = { 0 };
                                   ^
src/sccz80/declinit.c:446:30: style: The scope of the variable 'i' can be reduced. [variableScope]
                    int      i;
                             ^
src/sccz80/declinit.c:532:36: style: The scope of the variable 'fa' can be reduced. [variableScope]
                    unsigned char  fa[6];
                                   ^
src/sccz80/declinit.c:533:36: style: The scope of the variable 'i' can be reduced. [variableScope]
                    int            i;
                                   ^
src/sccz80/declinit.c:395:38: style: Local variable 'valtype' shadows outer variable [shadowVariable]
                                Kind valtype;
                                     ^
src/sccz80/declinit.c:292:12: note: Shadowed declaration
    Kind   valtype;
           ^
src/sccz80/declinit.c:395:38: note: Shadow variable
                                Kind valtype;
                                     ^
src/sccz80/declparse.c:1533:16: style: The if condition is the same as the previous if condition [duplicateCondition]
    if ( flags & HL_CALL ) {
               ^
src/sccz80/declparse.c:1529:16: note: First condition
    if ( flags & HL_CALL ) {
               ^
src/sccz80/declparse.c:1533:16: note: Second condition
    if ( flags & HL_CALL ) {
               ^
src/sccz80/declparse.c:270:12: warning: Either the condition 'base_type==NULL' is redundant or there is possible null pointer dereference: type. [nullPointerRedundantCheck]
    return type->kind == KIND_PTR || type->kind == KIND_CPTR;
           ^
src/sccz80/declparse.c:960:24: note: Assuming that condition 'base_type==NULL' is not redundant
        if ( base_type == NULL ) {
                       ^
src/sccz80/declparse.c:953:20: note: Calling function 'ispointer', 1st argument 'base_type' value is 0
    if ( ispointer(base_type) ) {
                   ^
src/sccz80/declparse.c:270:12: note: Null pointer dereference
    return type->kind == KIND_PTR || type->kind == KIND_CPTR;
           ^
src/sccz80/declparse.c:1317:10: warning: Either the condition 'type!=NULL' is redundant or there is possible null pointer dereference: type. [nullPointerRedundantCheck]
    if ( type->kind == KIND_FUNC ) {
         ^
src/sccz80/declparse.c:1313:15: note: Assuming that condition 'type!=NULL' is not redundant
    if ( type != NULL ) {
              ^
src/sccz80/declparse.c:1317:10: note: Null pointer dereference
    if ( type->kind == KIND_FUNC ) {
         ^
src/sccz80/declparse.c:1322:10: warning: Either the condition 'type!=NULL' is redundant or there is possible null pointer dereference: type. [nullPointerRedundantCheck]
    if ( type->kind == KIND_STRUCT ) {
         ^
src/sccz80/declparse.c:1313:15: note: Assuming that condition 'type!=NULL' is not redundant
    if ( type != NULL ) {
              ^
src/sccz80/declparse.c:1322:10: note: Null pointer dereference
    if ( type->kind == KIND_STRUCT ) {
         ^
src/sccz80/declparse.c:278:16: style: The scope of the variable 'num_enums_defined' can be reduced. [variableScope]
    static int num_enums_defined = 0;
               ^
src/sccz80/declparse.c:378:13: style: The scope of the variable 'offset' can be reduced. [variableScope]
    size_t  offset = 0;
            ^
src/sccz80/declparse.c:379:13: style: The scope of the variable 'size' can be reduced. [variableScope]
    int     size = 0;
            ^
src/sccz80/declparse.c:380:16: style: The scope of the variable 'num_structs' can be reduced. [variableScope]
    static int num_structs;
               ^
src/sccz80/declparse.c:1086:13: style: The scope of the variable 'sym' can be reduced. [variableScope]
    SYMBOL *sym;
            ^
src/sccz80/declparse.c:1972:21: style: The scope of the variable 'i' can be reduced. [variableScope]
            int     i;
                    ^
src/sccz80/declparse.c:1785:28: style:inconclusive: Function 'declfunc' argument 1 names different: declaration 'type' definition 'functype'. [funcArgNamesDifferent]
static void declfunc(Type *functype, enum storage_type storage)
                           ^
src/sccz80/declparse.c:6:28: note: Function 'declfunc' argument 1 names different: declaration 'type' definition 'functype'.
static void declfunc(Type *type, enum storage_type storage);
                           ^
src/sccz80/declparse.c:1785:28: note: Function 'declfunc' argument 1 names different: declaration 'type' definition 'functype'.
static void declfunc(Type *functype, enum storage_type storage)
                           ^
src/sccz80/declparse.c:1046:27: style: Local variable 'vconst' shadows outer function [shadowFunction]
                    int   vconst;
                          ^
src/sccz80/codegen.h:38:13: note: Shadowed declaration
extern void vconst(int64_t val);
            ^
src/sccz80/declparse.c:1046:27: note: Shadow variable
                    int   vconst;
                          ^
src/sccz80/declparse.c:1802:24: style: Local variable 'output' shadows outer variable [shadowVariable]
            UT_string *output;
                       ^
src/sccz80/data.h:51:14: note: Shadowed declaration
extern FILE *output;
             ^
src/sccz80/declparse.c:1802:24: note: Shadow variable
            UT_string *output;
                       ^
src/sccz80/declparse.c:2079:28: style: Local variable 'output' shadows outer variable [shadowVariable]
                UT_string *output;
                           ^
src/sccz80/data.h:51:14: note: Shadowed declaration
extern FILE *output;
             ^
src/sccz80/declparse.c:2079:28: note: Shadow variable
                UT_string *output;
                           ^
src/sccz80/error.c:40:9: error: Common realloc mistake: 'c_warning_categories' nulled but not freed upon failure [memleakOnRealloc]
        c_warning_categories = REALLOC(c_warning_categories, c_warning_categories_num * sizeof(c_warning_categories[0]));
        ^
src/sccz80/expr.c:198:9: style: The scope of the variable 'falselab' can be reduced. [variableScope]
    int falselab, endlab, skiplab;
        ^
src/sccz80/expr.c:198:19: style: The scope of the variable 'endlab' can be reduced. [variableScope]
    int falselab, endlab, skiplab;
                  ^
src/sccz80/expr.c:198:27: style: The scope of the variable 'skiplab' can be reduced. [variableScope]
    int falselab, endlab, skiplab;
                          ^
src/sccz80/expr.c:499:12: style: The scope of the variable 'j' can be reduced. [variableScope]
    int k, j;
           ^
src/sccz80/expr.c:501:9: style: The scope of the variable 'klptr' can be reduced. [variableScope]
    int klptr;
        ^
src/sccz80/expr.c:616:10: style: The scope of the variable 'sname' can be reduced. [variableScope]
    char sname[NAMESIZE];
         ^
src/sccz80/expr.c:618:19: style: The scope of the variable 'direct' can be reduced. [variableScope]
    int val, con, direct, k;
                  ^
src/sccz80/expr.c:620:10: style: The scope of the variable 'flags' can be reduced. [variableScope]
    char flags;
         ^
src/sccz80/expr.c:716:23: style: Local variable 'flags' shadows outer variable [shadowVariable]
                int   flags = 0;
                      ^
src/sccz80/expr.c:620:10: note: Shadowed declaration
    char flags;
         ^
src/sccz80/expr.c:716:23: note: Shadow variable
                int   flags = 0;
                      ^
src/sccz80/goto.c:45:13: style: The scope of the variable 'ptr' can be reduced. [variableScope]
    SYMBOL* ptr;
            ^
src/sccz80/io.c:267:17: style: The scope of the variable 'loc' can be reduced. [variableScope]
    const char *loc;
                ^
src/sccz80/lex.c:48:11: style: The scope of the variable 'i' can be reduced. [variableScope]
    int k,i;
          ^
src/sccz80/lex.c:62:10: style: The scope of the variable 'i' can be reduced. [variableScope]
    int  i;
         ^
src/sccz80/lex.c:79:10: style: The scope of the variable 'i' can be reduced. [variableScope]
    int  i;
         ^
src/sccz80/lex.c:102:12: style: Variable 'k' is assigned a value that is never used. [unreadVariable]
    if ((k = streq(line + lptr, lit)))
           ^
src/sccz80/main.c:583:13: warning: Either the condition '(fp=fopen(c_zcc_opt,"a"))==NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    fprintf(fp, "\nIF !DEFINED_%s\n", sname);
            ^
src/sccz80/main.c:580:38: note: Assuming that condition '(fp=fopen(c_zcc_opt,"a"))==NULL' is not redundant
    if ((fp = fopen(c_zcc_opt, "a")) == NULL) {
                                     ^
src/sccz80/main.c:583:13: note: Null pointer dereference
    fprintf(fp, "\nIF !DEFINED_%s\n", sname);
            ^
src/sccz80/main.c:584:13: warning: Either the condition '(fp=fopen(c_zcc_opt,"a"))==NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    fprintf(fp, "\tdefc\tDEFINED_%s = 1\n", sname);
            ^
src/sccz80/main.c:580:38: note: Assuming that condition '(fp=fopen(c_zcc_opt,"a"))==NULL' is not redundant
    if ((fp = fopen(c_zcc_opt, "a")) == NULL) {
                                     ^
src/sccz80/main.c:584:13: note: Null pointer dereference
    fprintf(fp, "\tdefc\tDEFINED_%s = 1\n", sname);
            ^
src/sccz80/main.c:585:13: warning: Either the condition '(fp=fopen(c_zcc_opt,"a"))==NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    fprintf(fp, "\tdefc %s = %d\n", sname, value);
            ^
src/sccz80/main.c:580:38: note: Assuming that condition '(fp=fopen(c_zcc_opt,"a"))==NULL' is not redundant
    if ((fp = fopen(c_zcc_opt, "a")) == NULL) {
                                     ^
src/sccz80/main.c:585:13: note: Null pointer dereference
    fprintf(fp, "\tdefc %s = %d\n", sname, value);
            ^
src/sccz80/main.c:586:13: warning: Either the condition '(fp=fopen(c_zcc_opt,"a"))==NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    fprintf(fp, "ENDIF\n\n");
            ^
src/sccz80/main.c:580:38: note: Assuming that condition '(fp=fopen(c_zcc_opt,"a"))==NULL' is not redundant
    if ((fp = fopen(c_zcc_opt, "a")) == NULL) {
                                     ^
src/sccz80/main.c:586:13: note: Null pointer dereference
    fprintf(fp, "ENDIF\n\n");
            ^
src/sccz80/main.c:587:12: warning: Either the condition '(fp=fopen(c_zcc_opt,"a"))==NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    fclose(fp);
           ^
src/sccz80/main.c:580:38: note: Assuming that condition '(fp=fopen(c_zcc_opt,"a"))==NULL' is not redundant
    if ((fp = fopen(c_zcc_opt, "a")) == NULL) {
                                     ^
src/sccz80/main.c:587:12: note: Null pointer dereference
    fclose(fp);
           ^
src/sccz80/main.c:646:9: style: The scope of the variable 'j' can be reduced. [variableScope]
    int j, k, lit;
        ^
src/sccz80/main.c:646:12: style: The scope of the variable 'k' can be reduced. [variableScope]
    int j, k, lit;
           ^
src/sccz80/main.c:646:15: style: The scope of the variable 'lit' can be reduced. [variableScope]
    int j, k, lit;
              ^
src/sccz80/main.c:825:35: style: The scope of the variable 'cp' can be reduced. [variableScope]
    char name[FILENAME_LEN + 1], *cp;
                                  ^
src/sccz80/main.c:943:36: style:inconclusive: Function 'SetWarning' argument 2 names different: declaration 'val' definition 'value'. [funcArgNamesDifferent]
void SetWarning(option *arg, char *value)
                                   ^
src/sccz80/main.c:77:43: note: Function 'SetWarning' argument 2 names different: declaration 'val' definition 'value'.
static void SetWarning(option *arg, char* val);
                                          ^
src/sccz80/main.c:943:36: note: Function 'SetWarning' argument 2 names different: declaration 'val' definition 'value'.
void SetWarning(option *arg, char *value)
                                   ^
src/sccz80/main.c:444:17: style: Local variable 'debug' shadows outer function [shadowFunction]
    const char *debug = utstring_body(debug_utstr);
                ^
src/sccz80/ccdefs.h:220:19: note: Shadowed declaration
extern void       debug(int num,char *str,...);
                  ^
src/sccz80/main.c:444:17: note: Shadow variable
    const char *debug = utstring_body(debug_utstr);
                ^
src/sccz80/main.c:457:17: style: Local variable 'debug' shadows outer function [shadowFunction]
    const char *debug = utstring_body(debug2_utstr);
                ^
src/sccz80/ccdefs.h:220:19: note: Shadowed declaration
extern void       debug(int num,char *str,...);
                  ^
src/sccz80/main.c:457:17: note: Shadow variable
    const char *debug = utstring_body(debug2_utstr);
                ^
src/sccz80/plunge.c:708:66: style: Condition 'lval->ptr_type==KIND_CHAR' is always true [knownConditionTrueFalse]
        } else if (lval->ptr_type == KIND_CHAR && lval->ptr_type == KIND_CHAR ) {
                                                                 ^
src/sccz80/plunge.c:708:35: note: Assuming that condition 'lval->ptr_type==KIND_CHAR' is not redundant
        } else if (lval->ptr_type == KIND_CHAR && lval->ptr_type == KIND_CHAR ) {
                                  ^
src/sccz80/plunge.c:708:66: note: Condition 'lval->ptr_type==KIND_CHAR' is always true
        } else if (lval->ptr_type == KIND_CHAR && lval->ptr_type == KIND_CHAR ) {
                                                                 ^
src/sccz80/plunge.c:708:48: style: Same expression on both sides of '&&'. [duplicateExpression]
        } else if (lval->ptr_type == KIND_CHAR && lval->ptr_type == KIND_CHAR ) {
                                               ^
src/sccz80/plunge.c:17:32: style: The scope of the variable 'k' can be reduced. [variableScope]
    int droplab, endlab, hits, k;
                               ^
src/sccz80/plunge.c:471:12: style: The scope of the variable 'val' can be reduced. [variableScope]
    double val;
           ^
src/sccz80/preproc.c:192:17: warning: sscanf() without field width limits can crash with huge input data. [invalidscanf]
                sscanf(line + lptr, "%d %s", &num, string);
                ^
src/sccz80/preproc.c:48:9: style: The scope of the variable 'i' can be reduced. [variableScope]
    int i;
        ^
src/sccz80/preproc.c:76:11: style: The scope of the variable 'unit' can be reduced. [variableScope]
    FILE* unit;
          ^
src/sccz80/preproc.c:77:9: style: The scope of the variable 'k' can be reduced. [variableScope]
    int k;
        ^
src/sccz80/preproc.c:263:13: style: The scope of the variable 'ptr' can be reduced. [variableScope]
    SYMBOL* ptr;
            ^
src/sccz80/primary.c:323:17: style: Condition 't1!=KIND_LONGLONG' is always true [knownConditionTrueFalse]
        if ( t1 != KIND_LONGLONG) {
                ^
src/sccz80/primary.c:305:12: note: Assuming that condition 't1==KIND_LONGLONG' is not redundant
    if (t1 == KIND_LONGLONG) {
           ^
src/sccz80/primary.c:315:12: note: Assuming condition is false
    if (t1 == KIND_LONG) {
           ^
src/sccz80/primary.c:323:17: note: Condition 't1!=KIND_LONGLONG' is always true
        if ( t1 != KIND_LONGLONG) {
                ^
src/sccz80/primary.c:423:29: style: Condition 'lval2->val_type!=KIND_LONGLONG' is always true [knownConditionTrueFalse]
        if (lval2->val_type != KIND_LONGLONG ) {
                            ^
src/sccz80/primary.c:408:25: note: Assuming that condition 'lval2->val_type==KIND_LONGLONG' is not redundant
    if (lval2->val_type == KIND_LONGLONG) {
                        ^
src/sccz80/primary.c:423:29: note: Condition 'lval2->val_type!=KIND_LONGLONG' is always true
        if (lval2->val_type != KIND_LONGLONG ) {
                            ^
src/sccz80/primary.c:458:29: style: Condition 'lval2->val_type!=KIND_LONG' is always true [knownConditionTrueFalse]
        if (lval2->val_type != KIND_LONG && lval2->val_type != KIND_CPTR) {
                            ^
src/sccz80/primary.c:437:25: note: Assuming that condition 'lval2->val_type==KIND_LONG' is not redundant
    if (lval2->val_type == KIND_LONG) {
                        ^
src/sccz80/primary.c:458:29: note: Condition 'lval2->val_type!=KIND_LONG' is always true
        if (lval2->val_type != KIND_LONG && lval2->val_type != KIND_CPTR) {
                            ^
src/sccz80/primary.c:412:42: style: Same expression on both sides of '||'. [duplicateExpression]
            if ( lval->ltype->isunsigned || lval->ltype->isunsigned ) {
                                         ^
src/sccz80/primary.c:425:42: style: Same expression on both sides of '||'. [duplicateExpression]
            if ( lval->ltype->isunsigned || lval->ltype->isunsigned) {
                                         ^
src/sccz80/primary.c:747:55: style: Same expression on both sides of '||'. [duplicateExpression]
        ( oper == zgt && lval->const_val < min_value) ||
                                                      ^
src/sccz80/primary.c:21:9: style: The scope of the variable 'k' can be reduced. [variableScope]
    int k;
        ^
src/sccz80/primary.c:288:17: style:inconclusive: Function 'force' argument 1 names different: declaration 'to' definition 't1'. [funcArgNamesDifferent]
void force(Kind t1, Kind t2, char isunsigned1, char isunsigned2, int isconst)
                ^
src/sccz80/ccdefs.h:306:28: note: Function 'force' argument 1 names different: declaration 'to' definition 't1'.
extern void     force(Kind to, Kind from, char to_sign, char from_sign, int lconst);
                           ^
src/sccz80/primary.c:288:17: note: Function 'force' argument 1 names different: declaration 'to' definition 't1'.
void force(Kind t1, Kind t2, char isunsigned1, char isunsigned2, int isconst)
                ^
src/sccz80/primary.c:288:26: style:inconclusive: Function 'force' argument 2 names different: declaration 'from' definition 't2'. [funcArgNamesDifferent]
void force(Kind t1, Kind t2, char isunsigned1, char isunsigned2, int isconst)
                         ^
src/sccz80/ccdefs.h:306:37: note: Function 'force' argument 2 names different: declaration 'from' definition 't2'.
extern void     force(Kind to, Kind from, char to_sign, char from_sign, int lconst);
                                    ^
src/sccz80/primary.c:288:26: note: Function 'force' argument 2 names different: declaration 'from' definition 't2'.
void force(Kind t1, Kind t2, char isunsigned1, char isunsigned2, int isconst)
                         ^
src/sccz80/primary.c:288:35: style:inconclusive: Function 'force' argument 3 names different: declaration 'to_sign' definition 'isunsigned1'. [funcArgNamesDifferent]
void force(Kind t1, Kind t2, char isunsigned1, char isunsigned2, int isconst)
                                  ^
src/sccz80/ccdefs.h:306:48: note: Function 'force' argument 3 names different: declaration 'to_sign' definition 'isunsigned1'.
extern void     force(Kind to, Kind from, char to_sign, char from_sign, int lconst);
                                               ^
src/sccz80/primary.c:288:35: note: Function 'force' argument 3 names different: declaration 'to_sign' definition 'isunsigned1'.
void force(Kind t1, Kind t2, char isunsigned1, char isunsigned2, int isconst)
                                  ^
src/sccz80/primary.c:288:53: style:inconclusive: Function 'force' argument 4 names different: declaration 'from_sign' definition 'isunsigned2'. [funcArgNamesDifferent]
void force(Kind t1, Kind t2, char isunsigned1, char isunsigned2, int isconst)
                                                    ^
src/sccz80/ccdefs.h:306:62: note: Function 'force' argument 4 names different: declaration 'from_sign' definition 'isunsigned2'.
extern void     force(Kind to, Kind from, char to_sign, char from_sign, int lconst);
                                                             ^
src/sccz80/primary.c:288:53: note: Function 'force' argument 4 names different: declaration 'from_sign' definition 'isunsigned2'.
void force(Kind t1, Kind t2, char isunsigned1, char isunsigned2, int isconst)
                                                    ^
src/sccz80/primary.c:288:70: style:inconclusive: Function 'force' argument 5 names different: declaration 'lconst' definition 'isconst'. [funcArgNamesDifferent]
void force(Kind t1, Kind t2, char isunsigned1, char isunsigned2, int isconst)
                                                                     ^
src/sccz80/ccdefs.h:306:77: note: Function 'force' argument 5 names different: declaration 'lconst' definition 'isconst'.
extern void     force(Kind to, Kind from, char to_sign, char from_sign, int lconst);
                                                                            ^
src/sccz80/primary.c:288:70: note: Function 'force' argument 5 names different: declaration 'lconst' definition 'isconst'.
void force(Kind t1, Kind t2, char isunsigned1, char isunsigned2, int isconst)
                                                                     ^
src/sccz80/primary.c:836:34: style:inconclusive: Function 'constexpr' argument 2 names different: declaration 'valtype' definition 'type'. [funcArgNamesDifferent]
int constexpr(double *val, Kind *type, int flag)
                                 ^
src/sccz80/ccdefs.h:318:46: note: Function 'constexpr' argument 2 names different: declaration 'valtype' definition 'type'.
extern int      constexpr(double *val, Kind *valtype, int flag);
                                             ^
src/sccz80/primary.c:836:34: note: Function 'constexpr' argument 2 names different: declaration 'valtype' definition 'type'.
int constexpr(double *val, Kind *type, int flag)
                                 ^
src/sccz80/primary.c:42:21: style: Local variable 'litlab' shadows outer variable [shadowVariable]
            int32_t litlab;
                    ^
src/sccz80/data.h:36:12: note: Shadowed declaration
extern int litlab;
           ^
src/sccz80/primary.c:42:21: note: Shadow variable
            int32_t litlab;
                    ^
src/sccz80/stmt.c:57:9: style: The scope of the variable 'locstatic' can be reduced. [variableScope]
    int locstatic; /* have we had the static keyword */
        ^
src/sccz80/stmt.c:418:28: style: The scope of the variable 'buf4' can be reduced. [variableScope]
    t_buffer *buf2, *buf3,*buf4;
                           ^
src/sccz80/stmt.c:757:16: style: The scope of the variable 'buf' can be reduced. [variableScope]
        char   buf[100];
               ^
src/sccz80/stmt.c:340:12: style: Local variable 'vconst' shadows outer function [shadowFunction]
    int    vconst;
           ^
src/sccz80/codegen.h:38:13: note: Shadowed declaration
extern void vconst(int64_t val);
            ^
src/sccz80/stmt.c:340:12: note: Shadow variable
    int    vconst;
           ^
src/sccz80/stmt.c:567:16: style: Local variable 'vconst' shadows outer function [shadowFunction]
        int    vconst;
               ^
src/sccz80/codegen.h:38:13: note: Shadowed declaration
extern void vconst(int64_t val);
            ^
src/sccz80/stmt.c:567:16: note: Shadow variable
        int    vconst;
               ^
src/sccz80/sym.c:100:10: style:inconclusive: Function 'addloc' argument 5 names different: declaration 'where' definition 'offset'. [funcArgNamesDifferent]
    int  offset)
         ^
src/sccz80/ccdefs.h:340:84: note: Function 'addloc' argument 5 names different: declaration 'where' definition 'offset'.
extern SYMBOL  *addloc(char *sname, Type *type, enum ident_type id, Kind kind, int where);
                                                                                   ^
src/sccz80/sym.c:100:10: note: Function 'addloc' argument 5 names different: declaration 'where' definition 'offset'.
    int  offset)
         ^
src/ticks/am9511.c:161:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
 _apu_push8(data >> 8);
                 ^
src/ticks/am9511.c:181:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
 _apu_push8(data >> 8);
                 ^
src/ticks/am9511.c:182:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
 _apu_push8(data >> 16);
                 ^
src/ticks/am9511.c:183:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
 _apu_push8(data >> 24);
                 ^
src/ticks/am9511.c:319:10: style: Local variable 'l' shadows outer variable [shadowVariable]
 int64_t l;
         ^
src/ticks/ticks.h:30:34: note: Shadowed declaration
extern unsigned char a,b,c,d,e,h,l;
                                 ^
src/ticks/am9511.c:319:10: note: Shadow variable
 int64_t l;
         ^
src/ticks/am9511.c:320:9: style: Local variable 'f' shadows outer function [shadowFunction]
 double f;
        ^
src/ticks/ticks.h:46:12: note: Shadowed declaration
extern int f(void);
           ^
src/ticks/am9511.c:320:9: note: Shadow variable
 double f;
        ^
src/ticks/debug.c:962:54: style: Condition 'a->first->next==NULL' is always false [knownConditionTrueFalse]
        if (a->first->next == NULL || a->first->next == NULL) {
                                                     ^
src/ticks/debug.c:962:28: note: Assuming that condition 'a->first->next==NULL' is not redundant
        if (a->first->next == NULL || a->first->next == NULL) {
                           ^
src/ticks/debug.c:962:54: note: Condition 'a->first->next==NULL' is always false
        if (a->first->next == NULL || a->first->next == NULL) {
                                                     ^
src/ticks/debug.c:328:17: warning: sscanf() without field width limits can crash with huge input data. [invalidscanf]
            if (sscanf(encoded, "%[^$]$", file_name) != 1) {
                ^
src/ticks/debug.c:352:17: warning: sscanf() without field width limits can crash with huge input data. [invalidscanf]
            if (sscanf(encoded, "%[^$]$", function_name) != 1) {
                ^
src/ticks/debug.c:373:9: warning: sscanf() without field width limits can crash with huge input data. [invalidscanf]
    if (sscanf(encoded, "%[^$]$%[^$]$%[^(](%[^)]),%n", function_name, level, block, type_record, &end) != 4) {
        ^
src/ticks/debug.c:419:17: warning: sscanf() without field width limits can crash with huge input data. [invalidscanf]
            if (sscanf(encoded, "%[^$]$", file_name) != 1) {
                ^
src/ticks/debug.c:455:17: warning: sscanf() without field width limits can crash with huge input data. [invalidscanf]
            if (sscanf(encoded, "%[^$]$", localiry_name) != 1) {
                ^
src/ticks/debug.c:475:9: warning: sscanf() without field width limits can crash with huge input data. [invalidscanf]
    if (sscanf(encoded, "%[^$]$%[^$]$%[^(](%[^)]),%n", symbol_name, level, block, type_record, &end) != 4) {
        ^
src/ticks/debug.c:476:13: warning: sscanf() without field width limits can crash with huge input data. [invalidscanf]
        if (sscanf(encoded, "$%[^$]$%[^(](%[^)]),%n", level, block, type_record, &end) == 3) {
            ^
src/ticks/debug.c:553:17: warning: sscanf() without field width limits can crash with huge input data. [invalidscanf]
            if (sscanf(encoded, "%[^$]$", file_name) != 1) {
                ^
src/ticks/debug.c:577:17: warning: sscanf() without field width limits can crash with huge input data. [invalidscanf]
            if (sscanf(encoded, "%[^$]$", localiry_name) != 1) {
                ^
src/ticks/debug.c:593:9: warning: sscanf() without field width limits can crash with huge input data. [invalidscanf]
    if (sscanf(encoded, "%[^[][%[^]]]", t->name, type_info) != 2) {
        ^
src/ticks/debug.c:919:9: warning: Either the condition 'a==NULL' is redundant or there is possible null pointer dereference: a. [nullPointerRedundantCheck]
    if (a->type_ != b->type_) {
        ^
src/ticks/debug.c:923:15: note: Assuming that condition 'a==NULL' is not redundant
        if (a == NULL || b == NULL) {
              ^
src/ticks/debug.c:919:9: note: Null pointer dereference
    if (a->type_ != b->type_) {
        ^
src/ticks/debug.c:919:21: warning: Either the condition 'b==NULL' is redundant or there is possible null pointer dereference: b. [nullPointerRedundantCheck]
    if (a->type_ != b->type_) {
                    ^
src/ticks/debug.c:923:28: note: Assuming that condition 'b==NULL' is not redundant
        if (a == NULL || b == NULL) {
                           ^
src/ticks/debug.c:919:21: note: Null pointer dereference
    if (a->type_ != b->type_) {
                    ^
src/ticks/debug.c:962:36: style: Same expression on both sides of '||'. [duplicateExpression]
        if (a->first->next == NULL || a->first->next == NULL) {
                                   ^
src/ticks/debug.c:726:93: style:inconclusive: Function 'debug_add_cline' argument 5 names different: declaration 'scope' definition 'scope_block'. [funcArgNamesDifferent]
void debug_add_cline(const char *filename, const char *function, int lineno, int level, int scope_block, const char *address)
                                                                                            ^
src/ticks/debug.h:170:100: note: Function 'debug_add_cline' argument 5 names different: declaration 'scope' definition 'scope_block'.
extern void debug_add_cline(const char *filename, const char *function, int lineno, int level, int scope, const char *address);
                                                                                                   ^
src/ticks/debug.c:726:93: note: Function 'debug_add_cline' argument 5 names different: declaration 'scope' definition 'scope_block'.
void debug_add_cline(const char *filename, const char *function, int lineno, int level, int scope_block, const char *address)
                                                                                            ^
src/ticks/debug.c:146:31: style: Local variable 'end' shadows outer variable [shadowVariable]
                        char *end;
                              ^
src/ticks/debug.c:75:9: note: Shadowed declaration
    int end;
        ^
src/ticks/debug.c:146:31: note: Shadow variable
                        char *end;
                              ^
src/ticks/debug.c:299:21: style: Local variable 'c' shadows outer variable [shadowVariable]
        type_chain* c = record->first;
                    ^
src/ticks/debug.c:92:10: note: Shadowed declaration
    char c;
         ^
src/ticks/debug.c:299:21: note: Shadow variable
        type_chain* c = record->first;
                    ^
src/ticks/debug.c:1248:14: style: Variable 'data' is not assigned a value. [unassignedVariable]
    uint16_t data;
             ^
src/ticks/debugger.c:602:19: style: Condition 'line==NULL' is always false [knownConditionTrueFalse]
        if ( line == NULL || line[0] == '\0') {
                  ^
src/ticks/debugger.c:599:41: note: Assuming that condition '(line=linenoise(prompt))!=NULL' is not redundant
    while ( (line = linenoise(prompt) ) != NULL ) {
                                        ^
src/ticks/debugger.c:602:19: note: Condition 'line==NULL' is always false
        if ( line == NULL || line[0] == '\0') {
                  ^
src/ticks/debugger.c:687:16: style: Condition 'fn!=NULL' is always true [knownConditionTrueFalse]
        if (fn != NULL) {
               ^
src/ticks/debugger.c:685:34: note: Assuming that condition 'fp->function' is not redundant
    if (sym && fp->filename && fp->function) {
                                 ^
src/ticks/debugger.c:686:36: note: Assignment 'fn=fp->function', assigned value is 0
        debug_sym_function* fn = fp->function;
                                   ^
src/ticks/debugger.c:687:16: note: Condition 'fn!=NULL' is always true
        if (fn != NULL) {
               ^
src/ticks/debugger.c:874:64: warning: Either the condition 'fp!=NULL' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
    debug_sym_symbol* s = cdb_find_symbol(lookup->symbol_name, fp->filename);
                                                               ^
src/ticks/debugger.c:843:12: note: Assuming that condition 'fp!=NULL' is not redundant
    if (fp != NULL) {
           ^
src/ticks/debugger.c:874:64: note: Null pointer dereference
    debug_sym_symbol* s = cdb_find_symbol(lookup->symbol_name, fp->filename);
                                                               ^
src/ticks/debugger.c:1083:9: style: The scope of the variable 'matches_total' can be reduced. [variableScope]
    int matches_total = 0;
        ^
src/ticks/debugger.c:1084:9: style: The scope of the variable 'matched_section' can be reduced. [variableScope]
    int matched_section = -1;
        ^
src/ticks/debugger.c:1212:10: style: The scope of the variable 'temp' can be reduced. [variableScope]
    char temp[1024];
         ^
src/ticks/debugger.c:1403:21: style: The scope of the variable 'elem' can be reduced. [variableScope]
        breakpoint *elem;
                    ^
src/ticks/debugger.c:1512:21: style: The scope of the variable 'elem' can be reduced. [variableScope]
        breakpoint *elem;
                    ^
src/ticks/debugger.c:1918:17: style: The scope of the variable 'buf' can be reduced. [variableScope]
    static char buf[2048];
                ^
src/ticks/debugger.c:1919:9: style: The scope of the variable 'i' can be reduced. [variableScope]
    int i;
        ^
src/ticks/debugger.c:465:30: style: Local variable 'pc' shadows outer function [shadowFunction]
        const unsigned short pc = bk.pc();
                             ^
src/ticks/debugger.c:70:18: note: Shadowed declaration
static uint16_t* pc(struct debugger_regs_t* regs) { return &regs->pc; }
                 ^
src/ticks/debugger.c:465:30: note: Shadow variable
        const unsigned short pc = bk.pc();
                             ^
src/ticks/debugger.c:641:26: style: Local variable 'pc' shadows outer function [shadowFunction]
    const unsigned short pc = bk.pc();
                         ^
src/ticks/debugger.c:70:18: note: Shadowed declaration
static uint16_t* pc(struct debugger_regs_t* regs) { return &regs->pc; }
                 ^
src/ticks/debugger.c:641:26: note: Shadow variable
    const unsigned short pc = bk.pc();
                         ^
src/ticks/debugger.c:661:26: style: Local variable 'pc' shadows outer function [shadowFunction]
    const unsigned short pc = bk.pc();
                         ^
src/ticks/debugger.c:70:18: note: Shadowed declaration
static uint16_t* pc(struct debugger_regs_t* regs) { return &regs->pc; }
                 ^
src/ticks/debugger.c:661:26: note: Shadow variable
    const unsigned short pc = bk.pc();
                         ^
src/ticks/debugger.c:1259:26: style: Local variable 'pc' shadows outer function [shadowFunction]
    const unsigned short pc = bk.pc();
                         ^
src/ticks/debugger.c:70:18: note: Shadowed declaration
static uint16_t* pc(struct debugger_regs_t* regs) { return &regs->pc; }
                 ^
src/ticks/debugger.c:1259:26: note: Shadow variable
    const unsigned short pc = bk.pc();
                         ^
src/ticks/debugger.c:1306:26: style: Local variable 'pc' shadows outer function [shadowFunction]
    const unsigned short pc = bk.pc();
                         ^
src/ticks/debugger.c:70:18: note: Shadowed declaration
static uint16_t* pc(struct debugger_regs_t* regs) { return &regs->pc; }
                 ^
src/ticks/debugger.c:1306:26: note: Shadow variable
    const unsigned short pc = bk.pc();
                         ^
src/ticks/debugger.c:1307:26: style: Local variable 'sp' shadows outer function [shadowFunction]
    const unsigned short sp = bk.sp();
                         ^
src/ticks/debugger.c:69:18: note: Shadowed declaration
static uint16_t* sp(struct debugger_regs_t* regs) { return &regs->sp; }
                 ^
src/ticks/debugger.c:1307:26: note: Shadow variable
    const unsigned short sp = bk.sp();
                         ^
src/ticks/debugger.c:1374:17: style: Local variable 'b' shadows outer function [shadowFunction]
    breakpoint* b = find_breakpoint(number);
                ^
src/ticks/debugger.c:49:17: note: Shadowed declaration
static uint8_t* b(struct debugger_regs_t* regs) { return &regs->b; }
                ^
src/ticks/debugger.c:1374:17: note: Shadow variable
    breakpoint* b = find_breakpoint(number);
                ^
src/ticks/debugger.c:1478:14: style: Local variable 'c' shadows outer function [shadowFunction]
        char c;
             ^
src/ticks/debugger.c:50:17: note: Shadowed declaration
static uint8_t* c(struct debugger_regs_t* regs) { return &regs->c; }
                ^
src/ticks/debugger.c:1478:14: note: Shadow variable
        char c;
             ^
src/ticks/debugger.c:1506:26: style: Local variable 'pc' shadows outer function [shadowFunction]
    const unsigned short pc = bk.pc();
                         ^
src/ticks/debugger.c:70:18: note: Shadowed declaration
static uint16_t* pc(struct debugger_regs_t* regs) { return &regs->pc; }
                 ^
src/ticks/debugger.c:1506:26: note: Shadow variable
    const unsigned short pc = bk.pc();
                         ^
src/ticks/debugger.c:1606:26: style: Local variable 'pc' shadows outer function [shadowFunction]
    const unsigned short pc = bk.pc();
                         ^
src/ticks/debugger.c:70:18: note: Shadowed declaration
static uint16_t* pc(struct debugger_regs_t* regs) { return &regs->pc; }
                 ^
src/ticks/debugger.c:1606:26: note: Shadow variable
    const unsigned short pc = bk.pc();
                         ^
src/ticks/debugger.c:1623:17: style: Local variable 'b' shadows outer function [shadowFunction]
        uint8_t b = bk.get_memory(addr);
                ^
src/ticks/debugger.c:49:17: note: Shadowed declaration
static uint8_t* b(struct debugger_regs_t* regs) { return &regs->b; }
                ^
src/ticks/debugger.c:1623:17: note: Shadow variable
        uint8_t b = bk.get_memory(addr);
                ^
src/ticks/debugger.c:367:14: style: Variable 'data' is not assigned a value. [unassignedVariable]
    uint16_t data;
             ^
src/ticks/debugger.c:1448:28: style: Variable 'initial_stack' is assigned a value that is never used. [unreadVariable]
    uint16_t initial_stack = stack;
                           ^
src/ticks/debugger.c:1953:15: error: va_list 'args' was opened but not closed by va_end(). [va_end_missing]
        return;
              ^
src/ticks/debugger.c:1943:5: error: va_list 'args2' used before va_start() was called. [va_list_usedBeforeStarted]
    va_copy(args2, args);
    ^
src/ticks/debugger.c:1946:35: error: va_list 'args2' used before va_start() was called. [va_list_usedBeforeStarted]
    len = vsnprintf(NULL, 0, fmt, args2);
                                  ^
src/ticks/debugger.c:1949:5: error: va_list 'args2' used before va_start() was called. [va_list_usedBeforeStarted]
    va_end(args2);
    ^
src/ticks/debugger_gdb.c:165:1: error: Memory leak: w.data [memleak]
}
^
src/ticks/debugger_gdb.c:199:19: style: The scope of the variable 'ch' can be reduced. [variableScope]
    unsigned char ch;
                  ^
src/ticks/debugger_gdb.c:212:19: style: The scope of the variable 'ch' can be reduced. [variableScope]
    unsigned char ch;
                  ^
src/ticks/debugger_gdb.c:666:11: style: Local variable 'f' shadows outer function [shadowFunction]
    FILE *f = fopen(file_path, "rb");
          ^
src/ticks/debugger_gdb.c:501:5: note: Shadowed declaration
int f()
    ^
src/ticks/debugger_gdb.c:666:11: note: Shadow variable
    FILE *f = fopen(file_path, "rb");
          ^
src/ticks/sxmlc.h:266:0: information: Skipping configuration '_MAX_PATH' since the value of '_MAX_PATH' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 SXML_CHAR filename[SXMLC_MAX_PATH];
^
src/ticks/debugger_mi2.c:844:9: warning: %x in format string (no. 1) requires 'unsigned int *' but the argument type is 'signed int *'. [invalidScanfArgType_int]
    if (sscanf(from, "%x", &from_d) != 1) {
        ^
src/ticks/debugger_mi2.c:850:9: warning: %x in format string (no. 1) requires 'unsigned int *' but the argument type is 'signed int *'. [invalidScanfArgType_int]
    if (sscanf(to, "%x", &to_d) != 1) {
        ^
src/ticks/debugger_mi2.c:931:9: warning: %x in format string (no. 1) requires 'unsigned int *' but the argument type is 'signed int *'. [invalidScanfArgType_int]
    if (sscanf(address, "%x,+%d", &from_d, &len_d) != 2) {
        ^
src/ticks/debugger_mi2.c:932:13: warning: %x in format string (no. 1) requires 'unsigned int *' but the argument type is 'signed int *'. [invalidScanfArgType_int]
        if (sscanf(address, "%x", &from_d) != 1) {
            ^
src/ticks/debugger_mi2.c:1334:17: warning: %d in format string (no. 1) requires 'int *' but the argument type is 'unsigned int *'. [invalidScanfArgType_int]
            if (sscanf(command_name, "%d-%n", &flow_id, &end) == 1) {
                ^
src/ticks/debugger_mi2.c:1097:25: warning: sscanf() without field width limits can crash with huge input data. [invalidscanf]
        int scanf_res = sscanf(argv[2], "tcp:%[^:]:%d", hostname, &port);
                        ^
src/ticks/debugger_mi2.c:1099:25: warning: sscanf() without field width limits can crash with huge input data. [invalidscanf]
            scanf_res = sscanf(argv[2], "%[^:]:%d", hostname, &port);
                        ^
src/ticks/debugger_mi2.c:930:13: error: Pointer addition with NULL pointer. [nullPointerArithmetic]
    address += 2;
            ^
src/ticks/debugger_mi2.c:910:27: note: Assignment 'address=NULL', assigned value is 0
    const char* address = NULL;
                          ^
src/ticks/debugger_mi2.c:930:13: note: Null pointer addition
    address += 2;
            ^
src/ticks/debugger_mi2.c:269:13: style: The scope of the variable 'first' can be reduced. [variableScope]
    uint8_t first = 1;
            ^
src/ticks/debugger_mi2.c:1140:21: style: The scope of the variable 'elem' can be reduced. [variableScope]
        breakpoint *elem;
                    ^
src/ticks/debugger_mi2.c:313:56: style:inconclusive: Function 'cmd_interpreter_exec' argument 2 names different: declaration 'argc' definition 'argc_'. [funcArgNamesDifferent]
static void cmd_interpreter_exec(const char* flow, int argc_, char **argv_) {
                                                       ^
src/ticks/debugger_mi2.c:65:56: note: Function 'cmd_interpreter_exec' argument 2 names different: declaration 'argc' definition 'argc_'.
static void cmd_interpreter_exec(const char* flow, int argc, char **argv);
                                                       ^
src/ticks/debugger_mi2.c:313:56: note: Function 'cmd_interpreter_exec' argument 2 names different: declaration 'argc' definition 'argc_'.
static void cmd_interpreter_exec(const char* flow, int argc_, char **argv_) {
                                                       ^
src/ticks/debugger_mi2.c:313:70: style:inconclusive: Function 'cmd_interpreter_exec' argument 3 names different: declaration 'argv' definition 'argv_'. [funcArgNamesDifferent]
static void cmd_interpreter_exec(const char* flow, int argc_, char **argv_) {
                                                                     ^
src/ticks/debugger_mi2.c:65:69: note: Function 'cmd_interpreter_exec' argument 3 names different: declaration 'argv' definition 'argv_'.
static void cmd_interpreter_exec(const char* flow, int argc, char **argv);
                                                                    ^
src/ticks/debugger_mi2.c:313:70: note: Function 'cmd_interpreter_exec' argument 3 names different: declaration 'argv' definition 'argv_'.
static void cmd_interpreter_exec(const char* flow, int argc_, char **argv_) {
                                                                     ^
src/ticks/debugger_mi2.c:273:33: style: Variable 'function_args' is assigned a value that is never used. [unreadVariable]
        char function_args[255] = {0};
                                ^
src/ticks/debugger_mi2.c:707:28: style: Variable 'initial_stack' is assigned a value that is never used. [unreadVariable]
    uint16_t initial_stack = stack;
                           ^
src/ticks/debugger_mi2.c:708:17: style: Variable 'at' is assigned a value that is never used. [unreadVariable]
    uint16_t at = bk.pc();
                ^
src/ticks/debugger_mi2.c:781:28: style: Variable 'initial_stack' is assigned a value that is never used. [unreadVariable]
    uint16_t initial_stack = stack;
                           ^
src/ticks/debugger_mi2.c:782:17: style: Variable 'at' is assigned a value that is never used. [unreadVariable]
    uint16_t at = bk.pc();
                ^
src/ticks/debugger_mi2.c:1014:28: style: Variable 'initial_stack' is assigned a value that is never used. [unreadVariable]
    uint16_t initial_stack = stack;
                           ^
src/ticks/debugger_mi2.c:1139:21: style: Unused variable: sym [unusedVariable]
        const char *sym;
                    ^
src/ticks/debugger_mi2.c:1318:31: style: Variable 'debugger_line_size' is assigned a value that is never used. [unreadVariable]
    size_t debugger_line_size = 1024;
                              ^
src/ticks/debugger_mi2.c:1446:15: error: va_list 'args' was opened but not closed by va_end(). [va_end_missing]
        return;
              ^
src/ticks/debugger_mi2.c:1437:5: error: va_list 'args2' used before va_start() was called. [va_list_usedBeforeStarted]
    va_copy(args2, args);
    ^
src/ticks/debugger_mi2.c:1440:35: error: va_list 'args2' used before va_start() was called. [va_list_usedBeforeStarted]
    len = vsnprintf(NULL, 0, fmt, args2);
                                  ^
src/ticks/debugger_mi2.c:1443:5: error: va_list 'args2' used before va_start() was called. [va_list_usedBeforeStarted]
    va_end(args2);
    ^
src/ticks/debugger_mi2.c:1486:15: error: va_list 'args' was opened but not closed by va_end(). [va_end_missing]
        return;
              ^
src/ticks/debugger_mi2.c:1476:5: error: va_list 'args2' used before va_start() was called. [va_list_usedBeforeStarted]
    va_copy(args2, args);
    ^
src/ticks/debugger_mi2.c:1479:35: error: va_list 'args2' used before va_start() was called. [va_list_usedBeforeStarted]
    len = vsnprintf(NULL, 0, fmt, args2);
                                  ^
src/ticks/debugger_mi2.c:1482:5: error: va_list 'args2' used before va_start() was called. [va_list_usedBeforeStarted]
    va_end(args2);
    ^
src/ticks/debugger_ticks.c:147:26: style: Local variable 'pc' shadows outer variable [shadowVariable]
    const unsigned short pc = bk.pc();
                         ^
src/ticks/ticks.h:33:27: note: Shadowed declaration
extern unsigned short ff, pc, sp;
                          ^
src/ticks/debugger_ticks.c:147:26: note: Shadow variable
    const unsigned short pc = bk.pc();
                         ^
src/ticks/disassembler_alg.c:647:53: style: Expression is always false because 'else if' condition matches previous condition at line 646. [multiCondition]
                                        else if ( b == 0x98 ) BUF_PRINTF("setae");
                                                    ^
src/ticks/disassembler_alg.c:67:14: style: The scope of the variable 'temp' can be reduced. [variableScope]
        char temp[10];
             ^
src/ticks/disassembler_alg.c:93:14: style: The scope of the variable 'temp' can be reduced. [variableScope]
        char temp[10];
             ^
src/ticks/disassembler_alg.c:259:18: style: The scope of the variable 'opbuf1' can be reduced. [variableScope]
    char         opbuf1[256];
                 ^
src/ticks/disassembler_alg.c:260:18: style: The scope of the variable 'opbuf2' can be reduced. [variableScope]
    char         opbuf2[256];
                 ^
src/ticks/disassembler_alg.c:586:72: style: Unsigned expression 'p' can't be negative so it is unnecessary to test it. [unsignedPositive]
                                                else if ( (y % 2 )&& p >= 0 && p <= 3 ) BUF_PRINTF("%-8s%s","mlt", handle_register16(state,p,0));
                                                                       ^
src/ticks/disassembler_alg.c:248:32: style:inconclusive: Function 'disassemble2' argument 2 names different: declaration 'buf' definition 'bufstart'. [funcArgNamesDifferent]
int disassemble2(int pc, char *bufstart, size_t buflen, int compact)
                               ^
src/ticks/disassembler.h:6:39: note: Function 'disassemble2' argument 2 names different: declaration 'buf' definition 'bufstart'.
extern int disassemble2(int pc, char *buf, size_t buflen, int compact);
                                      ^
src/ticks/disassembler_alg.c:248:32: note: Function 'disassemble2' argument 2 names different: declaration 'buf' definition 'bufstart'.
int disassemble2(int pc, char *bufstart, size_t buflen, int compact)
                               ^
src/ticks/disassembler_alg.c:439:37: style: Local variable 'x' shadows outer variable [shadowVariable]
                            uint8_t x = b >> 6;
                                    ^
src/ticks/disassembler_alg.c:286:21: note: Shadowed declaration
            uint8_t x = b >> 6;
                    ^
src/ticks/disassembler_alg.c:439:37: note: Shadow variable
                            uint8_t x = b >> 6;
                                    ^
src/ticks/disassembler_alg.c:440:37: style: Local variable 'y' shadows outer variable [shadowVariable]
                            uint8_t y = ( b & 0x38) >> 3;
                                    ^
src/ticks/disassembler_alg.c:287:21: note: Shadowed declaration
            uint8_t y = ( b & 0x38) >> 3;
                    ^
src/ticks/disassembler_alg.c:440:37: note: Shadow variable
                            uint8_t y = ( b & 0x38) >> 3;
                                    ^
src/ticks/disassembler_alg.c:441:37: style: Local variable 'z' shadows outer variable [shadowVariable]
                            uint8_t z = b & 0x07;
                                    ^
src/ticks/disassembler_alg.c:288:21: note: Shadowed declaration
            uint8_t z = b & 0x07;
                    ^
src/ticks/disassembler_alg.c:441:37: note: Shadow variable
                            uint8_t z = b & 0x07;
                                    ^
src/ticks/disassembler_alg.c:512:41: style: Local variable 'x' shadows outer variable [shadowVariable]
                                uint8_t x = b >> 6;
                                        ^
src/ticks/disassembler_alg.c:286:21: note: Shadowed declaration
            uint8_t x = b >> 6;
                    ^
src/ticks/disassembler_alg.c:512:41: note: Shadow variable
                                uint8_t x = b >> 6;
                                        ^
src/ticks/disassembler_alg.c:513:41: style: Local variable 'y' shadows outer variable [shadowVariable]
                                uint8_t y = ( b & 0x38) >> 3;
                                        ^
src/ticks/disassembler_alg.c:287:21: note: Shadowed declaration
            uint8_t y = ( b & 0x38) >> 3;
                    ^
src/ticks/disassembler_alg.c:513:41: note: Shadow variable
                                uint8_t y = ( b & 0x38) >> 3;
                                        ^
src/ticks/disassembler_alg.c:514:41: style: Local variable 'z' shadows outer variable [shadowVariable]
                                uint8_t z = b & 0x07;
                                        ^
src/ticks/disassembler_alg.c:288:21: note: Shadowed declaration
            uint8_t z = b & 0x07;
                    ^
src/ticks/disassembler_alg.c:514:41: note: Shadow variable
                                uint8_t z = b & 0x07;
                                        ^
src/ticks/disassembler_alg.c:515:41: style: Local variable 'p' shadows outer variable [shadowVariable]
                                uint8_t p = (y & 0x06) >> 1;
                                        ^
src/ticks/disassembler_alg.c:289:21: note: Shadowed declaration
            uint8_t p = (y & 0x06) >> 1;
                    ^
src/ticks/disassembler_alg.c:515:41: note: Shadow variable
                                uint8_t p = (y & 0x06) >> 1;
                                        ^
src/ticks/disassembler_alg.c:516:41: style: Local variable 'q' shadows outer variable [shadowVariable]
                                uint8_t q = y & 0x01;
                                        ^
src/ticks/disassembler_alg.c:290:21: note: Shadowed declaration
            uint8_t q = y & 0x01;
                    ^
src/ticks/disassembler_alg.c:516:41: note: Shadow variable
                                uint8_t q = y & 0x01;
                                        ^
src/ticks/disassembler_alg.c:704:18: style: Variable 'offs' is assigned a value that is never used. [unreadVariable]
            offs += snprintf(buf + offs, buflen - offs,"\n");
                 ^
src/ticks/exp_engine.c:731:25: warning: Either the condition 'i<128' is redundant or the array 'buff[128]' is accessed at index 128, which is out of bounds. [arrayIndexOutOfBoundsCond]
                    buff[i] = 0;
                        ^
src/ticks/exp_engine.c:720:30: note: Assuming that condition 'i<128' is not redundant
                    while (i < 128) {
                             ^
src/ticks/exp_engine.c:731:25: note: Array index out of bounds
                    buff[i] = 0;
                        ^
src/ticks/expressions.tab.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 28 configurations. Use --force to check all configurations. [toomanyconfigs]

^
expressions.tab.c:858:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]

    ^
expressions.tab.c:965:3: style: The comparison '0 <= yystate' is always true. [knownConditionTrueFalse]

  ^
expressions.tab.c:907:31: note: 'yystate' is assigned value '0' here.

                              ^
expressions.tab.c:965:3: note: The comparison '0 <= yystate' is always true.

  ^
expressions.tab.c:991:0: information: Skipping configuration 'EXIT_SUCCESS;_ALLOCA_H;YYSTACK_USE_ALLOCA;yyoverflow' since the value of 'yyoverflow' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]

^
expressions.tab.c:991:0: information: Skipping configuration 'YYSTACK_USE_ALLOCA;_AIX;yyoverflow' since the value of 'yyoverflow' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]

^
expressions.tab.c:991:0: information: Skipping configuration 'YYSTACK_USE_ALLOCA;_MSC_VER;yyoverflow' since the value of 'yyoverflow' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]

^
expressions.tab.c:991:0: information: Skipping configuration 'YYSTACK_USE_ALLOCA;__BUILTIN_VA_ARG_INCR;yyoverflow' since the value of 'yyoverflow' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]

^
expressions.tab.c:991:0: information: Skipping configuration 'YYSTACK_USE_ALLOCA;__GNUC__;yyoverflow' since the value of 'yyoverflow' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]

^
expressions.tab.c:991:0: information: Skipping configuration 'YYSTACK_USE_ALLOCA;yyoverflow' since the value of 'yyoverflow' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]

^
expressions.tab.c:991:0: information: Skipping configuration 'YYSTYPE_IS_TRIVIAL;yyoverflow' since the value of 'yyoverflow' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]

^
src/ticks/hook.c:33:2: warning: %llu in format string (no. 1) requires 'unsigned long long' but the argument type is 'signed long long'. [invalidPrintfArgType_uint]
 printf("\nTicks: %llu\n",st);
 ^
src/ticks/hook_cpm.c:90:20: style: Unsigned expression 'e' can't be negative so it is unnecessary to test it. [unsignedPositive]
            if ( e >= 0 && e < 16 )
                   ^
src/ticks/hook_io.c:201:11: style: Variable 'e' is reassigned a value before the old one has been used. [redundantAssignment]
        e = t / 256;
          ^
src/ticks/hook_io.c:200:11: note: e is assigned
        e = t % 256;
          ^
src/ticks/hook_io.c:201:11: note: e is overwritten
        e = t / 256;
          ^
src/ticks/hook_io.c:70:16: style: Variable 'mode' is assigned a value that is never used. [unreadVariable]
    int   mode = c | b << 8;
               ^
lex.yy.c:1462:2: warning: Possible null pointer dereference: b [nullPointer]

 ^
lex.yy.c:1355:18: note: Calling function 'yy_init_buffer', 1st argument '(yy_buffer_stack)?(yy_buffer_stack)[yy_buffer_stack_top]:NULL' value is 0

                 ^
lex.yy.c:1462:2: note: Null pointer dereference

 ^
lex.yy.c:1463:2: warning: Possible null pointer dereference: b [nullPointer]

 ^
lex.yy.c:1355:18: note: Calling function 'yy_init_buffer', 1st argument '(yy_buffer_stack)?(yy_buffer_stack)[yy_buffer_stack_top]:NULL' value is 0

                 ^
lex.yy.c:1463:2: note: Null pointer dereference

 ^
lex.yy.c:1474:9: warning: Possible null pointer dereference: b [nullPointer]

        ^
lex.yy.c:1355:18: note: Calling function 'yy_init_buffer', 1st argument '(yy_buffer_stack)?(yy_buffer_stack)[yy_buffer_stack_top]:NULL' value is 0

                 ^
lex.yy.c:1474:9: note: Null pointer dereference

        ^
lex.yy.c:1124:3: style: Redundant initialization for 'c'. The initialized value is overwritten before it is read. [redundantInitialization]

  ^
lex.yy.c:1124:3: note: c is initialized

  ^
lex.yy.c:1124:3: note: c is overwritten

  ^
lex.yy.c:1203:59: style:inconclusive: Function 'yy_try_NUL_trans' argument 1 names different: declaration 'current_state' definition 'yy_current_state'. [funcArgNamesDifferent]

                                                          ^
lex.yy.c:344:55: note: Function 'yy_try_NUL_trans' argument 1 names different: declaration 'current_state' definition 'yy_current_state'.

                                                      ^
lex.yy.c:1203:59: note: Function 'yy_try_NUL_trans' argument 1 names different: declaration 'current_state' definition 'yy_current_state'.

                                                          ^
lex.yy.c:1228:40: style:inconclusive: Function 'yyunput' argument 2 names different: declaration 'buf_ptr' definition 'yy_bp'. [funcArgNamesDifferent]

                                       ^
lex.yy.c:562:40: note: Function 'yyunput' argument 2 names different: declaration 'buf_ptr' definition 'yy_bp'.

                                       ^
lex.yy.c:1228:40: note: Function 'yyunput' argument 2 names different: declaration 'buf_ptr' definition 'yy_bp'.

                                       ^
lex.yy.c:1647:46: style:inconclusive: Function 'yy_scan_string' argument 1 names different: declaration 'yy_str' definition 'yystr'. [funcArgNamesDifferent]

                                             ^
lex.yy.c:296:46: note: Function 'yy_scan_string' argument 1 names different: declaration 'yy_str' definition 'yystr'.

                                             ^
lex.yy.c:1647:46: note: Function 'yy_scan_string' argument 1 names different: declaration 'yy_str' definition 'yystr'.

                                             ^
lex.yy.c:1660:46: style:inconclusive: Function 'yy_scan_bytes' argument 1 names different: declaration 'bytes' definition 'yybytes'. [funcArgNamesDifferent]

                                             ^
lex.yy.c:297:45: note: Function 'yy_scan_bytes' argument 1 names different: declaration 'bytes' definition 'yybytes'.

                                            ^
lex.yy.c:1660:46: note: Function 'yy_scan_bytes' argument 1 names different: declaration 'bytes' definition 'yybytes'.

                                             ^
lex.yy.c:1660:60: style:inconclusive: Function 'yy_scan_bytes' argument 2 names different: declaration 'len' definition '_yybytes_len'. [funcArgNamesDifferent]

                                                           ^
lex.yy.c:297:56: note: Function 'yy_scan_bytes' argument 2 names different: declaration 'len' definition '_yybytes_len'.

                                                       ^
lex.yy.c:1660:60: note: Function 'yy_scan_bytes' argument 2 names different: declaration 'len' definition '_yybytes_len'.

                                                           ^
lex.yy.c:1792:24: style:inconclusive: Function 'yyset_debug' argument 1 names different: declaration 'debug_flag' definition '_bdebug'. [funcArgNamesDifferent]

                       ^
lex.yy.c:526:24: note: Function 'yyset_debug' argument 1 names different: declaration 'debug_flag' definition '_bdebug'.

                       ^
lex.yy.c:1792:24: note: Function 'yyset_debug' argument 1 names different: declaration 'debug_flag' definition '_bdebug'.

                       ^
lex.yy.c:696:0: information: Skipping configuration 'YY_USER_INIT' since the value of 'YY_USER_INIT' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]

^
src/ticks/linenoise.c:2501:28: warning: Identical condition 'c=='\r'', second condition is always false [identicalConditionAfterEarlyExit]
        if (c == '\n' || c == '\r') {
                           ^
src/ticks/linenoise.c:2497:15: note: If condition 'c=='\r'' is true, the function will return/exit
        if (c == '\r') {
              ^
src/ticks/linenoise.c:2501:28: note: Testing identical condition 'c=='\r''
        if (c == '\n' || c == '\r') {
                           ^
src/ticks/linenoise.c:1394:11: style: Condition 'c=='['' is always false [knownConditionTrueFalse]
    if (c == '[' && c2 >= '1' && c2 <= '8') {
          ^
src/ticks/linenoise.c:1377:11: note: Assuming that condition 'c=='['' is not redundant
    if (c == '[' || c == 'O') {
          ^
src/ticks/linenoise.c:1394:11: note: Condition 'c=='['' is always false
    if (c == '[' && c2 >= '1' && c2 <= '8') {
          ^
src/ticks/linenoise.c:1990:56: style: Condition '(last&0x80)==0' is always true [knownConditionTrueFalse]
            if (current->colsleft > 0 && (last & 0x80) == 0) {
                                                       ^
src/ticks/linenoise.c:1988:25: note: Assignment 'last=0', assigned value is 0
            char last = 0;
                        ^
src/ticks/linenoise.c:1990:56: note: Condition '(last&0x80)==0' is always true
            if (current->colsleft > 0 && (last & 0x80) == 0) {
                                                       ^
src/ticks/linenoise.c:2004:16: style: Condition 'rc==2' is always false [knownConditionTrueFalse]
        if (rc == 2) {
               ^
src/ticks/linenoise.c:1973:18: note: Assignment 'rc=1', assigned value is 1
        int rc = 1;
                 ^
src/ticks/linenoise.c:2004:16: note: Condition 'rc==2' is always false
        if (rc == 2) {
               ^
src/ticks/linenoise.c:2015:9: style: Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]
        return 1;
        ^
src/ticks/linenoise.c:2298:13: style:inconclusive: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
            enableRawMode(current);
            ^
src/ticks/linenoise.c:2517:9: style: The scope of the variable 'count' can be reduced. [variableScope]
    int count;
        ^
src/ticks/linenoise.c:1552:91: style:inconclusive: Function 'linenoiseSetCompletionCallback' argument 1 names different: declaration 'comp' definition 'fn'. [funcArgNamesDifferent]
linenoiseCompletionCallback * linenoiseSetCompletionCallback(linenoiseCompletionCallback *fn, void *userdata) {
                                                                                          ^
src/ticks/linenoise.h:55:91: note: Function 'linenoiseSetCompletionCallback' argument 1 names different: declaration 'comp' definition 'fn'.
linenoiseCompletionCallback * linenoiseSetCompletionCallback(linenoiseCompletionCallback *comp, void *userdata);
                                                                                          ^
src/ticks/linenoise.c:1552:91: note: Function 'linenoiseSetCompletionCallback' argument 1 names different: declaration 'comp' definition 'fn'.
linenoiseCompletionCallback * linenoiseSetCompletionCallback(linenoiseCompletionCallback *fn, void *userdata) {
                                                                                          ^
src/ticks/linenoise.c:1559:51: style:inconclusive: Function 'linenoiseAddCompletion' argument 1 names different: declaration 'comp' definition 'lc'. [funcArgNamesDifferent]
void linenoiseAddCompletion(linenoiseCompletions *lc, const char *str) {
                                                  ^
src/ticks/linenoise.h:61:51: note: Function 'linenoiseAddCompletion' argument 1 names different: declaration 'comp' definition 'lc'.
void linenoiseAddCompletion(linenoiseCompletions *comp, const char *str);
                                                  ^
src/ticks/linenoise.c:1559:51: note: Function 'linenoiseAddCompletion' argument 1 names different: declaration 'comp' definition 'lc'.
void linenoiseAddCompletion(linenoiseCompletions *lc, const char *str) {
                                                  ^
src/ticks/linenoise.c:2296:0: information: Skipping configuration 'SIGINT' since the value of 'SIGINT' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
            raise(SIGINT);
^
src/ticks/linenoise.c:2306:0: information: Skipping configuration 'SIGTSTP' since the value of 'SIGTSTP' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
            raise(SIGTSTP);
^
src/ticks/linenoise.c:526:37: style:inconclusive: Function 'utf8_index' argument 2 names different: declaration 'charindex' definition 'index'. [funcArgNamesDifferent]
int utf8_index(const char *str, int index)
                                    ^
src/ticks/utf8.h:77:37: note: Function 'utf8_index' argument 2 names different: declaration 'charindex' definition 'index'.
int utf8_index(const char *str, int charindex);
                                    ^
src/ticks/linenoise.c:526:37: note: Function 'utf8_index' argument 2 names different: declaration 'charindex' definition 'index'.
int utf8_index(const char *str, int index)
                                    ^
src/ticks/linenoise-win32.c:221:22: warning: The address of local variable 'nohighlight' might be accessed at non-zero index. [objectIndex]
        switch (props[i]) {
                     ^
src/ticks/linenoise.c:1426:33: note: Address of variable taken here.
    setOutputHighlight(current, &nohighlight, 1);
                                ^
src/ticks/linenoise.c:1426:33: note: Calling function 'setOutputHighlight', 2nd argument '&nohighlight' value is lifetime=nohighlight
    setOutputHighlight(current, &nohighlight, 1);
                                ^
src/ticks/linenoise-win32.c:221:22: note: The address of local variable 'nohighlight' might be accessed at non-zero index.
        switch (props[i]) {
                     ^
src/ticks/linenoise-win32.c:221:22: warning: The address of local variable 'reverse' might be accessed at non-zero index. [objectIndex]
        switch (props[i]) {
                     ^
src/ticks/linenoise.c:1432:33: note: Address of variable taken here.
    setOutputHighlight(current, &reverse, 1);
                                ^
src/ticks/linenoise.c:1432:33: note: Calling function 'setOutputHighlight', 2nd argument '&reverse' value is lifetime=reverse
    setOutputHighlight(current, &reverse, 1);
                                ^
src/ticks/linenoise-win32.c:221:22: note: The address of local variable 'reverse' might be accessed at non-zero index.
        switch (props[i]) {
                     ^
src/ticks/memory.c:263:21: warning: Either the condition 'bank>=0x10' is redundant or the array 'zx_banks[8]' is accessed at index 15, which is out of bounds. [arrayIndexOutOfBoundsCond]
    return &zx_banks[bank][pc % 16384];
                    ^
src/ticks/memory.c:259:15: note: Assuming that condition 'bank>=0x10' is not redundant
    if ( bank >= 0x10 ) {
              ^
src/ticks/memory.c:263:21: note: Array index out of bounds
    return &zx_banks[bank][pc % 16384];
                    ^
src/ticks/memory.c:156:15: style: Variable 'segment' is assigned a value that is never used. [unreadVariable]
  int segment = pc / 8192;
              ^
src/ticks/sxmlc.c:472:16: style: The scope of the variable 'pt' can be reduced. [variableScope]
 XMLAttribute* pt;
               ^
src/ticks/sxmlc.c:556:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
src/ticks/sxmlc.c:769:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
src/ticks/sxmlc.c:992:13: style: The scope of the variable 'p' can be reduced. [variableScope]
 SXML_CHAR* p;
            ^
src/ticks/sxmlc.c:1148:19: style: The scope of the variable 'p' can be reduced. [variableScope]
 const SXML_CHAR *p;
                  ^
src/ticks/sxmlc.c:1149:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i, n0, n1, remQ = 0;
     ^
src/ticks/sxmlc.c:1360:27: style: The scope of the variable 'txt_end' can be reduced. [variableScope]
 SXML_CHAR *line = NULL, *txt_end, *p;
                          ^
src/ticks/sxmlc.c:509:83: style:inconclusive: Function 'XMLNode_search_attribute' argument 3 names different: declaration 'isearch' definition 'i_search'. [funcArgNamesDifferent]
int XMLNode_search_attribute(const XMLNode* node, const SXML_CHAR* attr_name, int i_search)
                                                                                  ^
src/ticks/sxmlc.h:635:83: note: Function 'XMLNode_search_attribute' argument 3 names different: declaration 'isearch' definition 'i_search'.
int XMLNode_search_attribute(const XMLNode* node, const SXML_CHAR* attr_name, int isearch);
                                                                                  ^
src/ticks/sxmlc.c:509:83: note: Function 'XMLNode_search_attribute' argument 3 names different: declaration 'isearch' definition 'i_search'.
int XMLNode_search_attribute(const XMLNode* node, const SXML_CHAR* attr_name, int i_search)
                                                                                  ^
src/ticks/sxmlc.c:1553:35: style:inconclusive: Function 'DOMXMLDoc_doc_start' argument 1 names different: declaration 'dom' definition 'sd'. [funcArgNamesDifferent]
int DOMXMLDoc_doc_start(SAX_Data* sd)
                                  ^
src/ticks/sxmlc.h:464:35: note: Function 'DOMXMLDoc_doc_start' argument 1 names different: declaration 'dom' definition 'sd'.
int DOMXMLDoc_doc_start(SAX_Data* dom);
                                  ^
src/ticks/sxmlc.c:1553:35: note: Function 'DOMXMLDoc_doc_start' argument 1 names different: declaration 'dom' definition 'sd'.
int DOMXMLDoc_doc_start(SAX_Data* sd)
                                  ^
src/ticks/sxmlc.c:1564:57: style:inconclusive: Function 'DOMXMLDoc_node_start' argument 2 names different: declaration 'dom' definition 'sd'. [funcArgNamesDifferent]
int DOMXMLDoc_node_start(const XMLNode* node, SAX_Data* sd)
                                                        ^
src/ticks/sxmlc.h:465:57: note: Function 'DOMXMLDoc_node_start' argument 2 names different: declaration 'dom' definition 'sd'.
int DOMXMLDoc_node_start(const XMLNode* node, SAX_Data* dom);
                                                        ^
src/ticks/sxmlc.c:1564:57: note: Function 'DOMXMLDoc_node_start' argument 2 names different: declaration 'dom' definition 'sd'.
int DOMXMLDoc_node_start(const XMLNode* node, SAX_Data* sd)
                                                        ^
src/ticks/sxmlc.c:1595:55: style:inconclusive: Function 'DOMXMLDoc_node_end' argument 2 names different: declaration 'dom' definition 'sd'. [funcArgNamesDifferent]
int DOMXMLDoc_node_end(const XMLNode* node, SAX_Data* sd)
                                                      ^
src/ticks/sxmlc.h:467:55: note: Function 'DOMXMLDoc_node_end' argument 2 names different: declaration 'dom' definition 'sd'.
int DOMXMLDoc_node_end(const XMLNode* node, SAX_Data* dom);
                                                      ^
src/ticks/sxmlc.c:1595:55: note: Function 'DOMXMLDoc_node_end' argument 2 names different: declaration 'dom' definition 'sd'.
int DOMXMLDoc_node_end(const XMLNode* node, SAX_Data* sd)
                                                      ^
src/ticks/sxmlc.c:1617:52: style:inconclusive: Function 'DOMXMLDoc_node_text' argument 2 names different: declaration 'dom' definition 'sd'. [funcArgNamesDifferent]
int DOMXMLDoc_node_text(SXML_CHAR* text, SAX_Data* sd)
                                                   ^
src/ticks/sxmlc.h:466:52: note: Function 'DOMXMLDoc_node_text' argument 2 names different: declaration 'dom' definition 'sd'.
int DOMXMLDoc_node_text(SXML_CHAR* text, SAX_Data* dom);
                                                   ^
src/ticks/sxmlc.c:1617:52: note: Function 'DOMXMLDoc_node_text' argument 2 names different: declaration 'dom' definition 'sd'.
int DOMXMLDoc_node_text(SXML_CHAR* text, SAX_Data* sd)
                                                   ^
src/ticks/sxmlc.c:1685:33: style:inconclusive: Function 'DOMXMLDoc_doc_end' argument 1 names different: declaration 'dom' definition 'sd'. [funcArgNamesDifferent]
int DOMXMLDoc_doc_end(SAX_Data* sd)
                                ^
src/ticks/sxmlc.h:469:33: note: Function 'DOMXMLDoc_doc_end' argument 1 names different: declaration 'dom' definition 'sd'.
int DOMXMLDoc_doc_end(SAX_Data* dom);
                                ^
src/ticks/sxmlc.c:1685:33: note: Function 'DOMXMLDoc_doc_end' argument 1 names different: declaration 'dom' definition 'sd'.
int DOMXMLDoc_doc_end(SAX_Data* sd)
                                ^
src/ticks/sxmlc.c:1876:2: warning: %x in format string (no. 1) requires 'unsigned int' but the argument type is 'void *'. [invalidPrintfArgType_uint]
 printf("0x%x: MALLOC (%d) - NA %d - NF %d = %d\n", p, sz, nb_alloc, nb_free, nb_alloc - nb_free);
 ^
src/ticks/sxmlc.c:1876:2: portability: %d in format string (no. 2) requires 'int' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_sint]
 printf("0x%x: MALLOC (%d) - NA %d - NF %d = %d\n", p, sz, nb_alloc, nb_free, nb_alloc - nb_free);
 ^
src/ticks/sxmlc.c:1885:2: warning: %x in format string (no. 1) requires 'unsigned int' but the argument type is 'void *'. [invalidPrintfArgType_uint]
 printf("0x%x: CALLOC (%d, %d) - NA %d - NF %d = %d\n", p, count, sz, nb_alloc, nb_free, nb_alloc - nb_free);
 ^
src/ticks/sxmlc.c:1885:2: portability: %d in format string (no. 2) requires 'int' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_sint]
 printf("0x%x: CALLOC (%d, %d) - NA %d - NF %d = %d\n", p, count, sz, nb_alloc, nb_free, nb_alloc - nb_free);
 ^
src/ticks/sxmlc.c:1885:2: portability: %d in format string (no. 3) requires 'int' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_sint]
 printf("0x%x: CALLOC (%d, %d) - NA %d - NF %d = %d\n", p, count, sz, nb_alloc, nb_free, nb_alloc - nb_free);
 ^
src/ticks/sxmlc.c:1896:2: warning: %x in format string (no. 1) requires 'unsigned int' but the argument type is 'void *'. [invalidPrintfArgType_uint]
 printf("0x%x: REALLOC 0x%x (%d)", p, mem, sz);
 ^
src/ticks/sxmlc.c:1896:2: warning: %x in format string (no. 2) requires 'unsigned int' but the argument type is 'void *'. [invalidPrintfArgType_uint]
 printf("0x%x: REALLOC 0x%x (%d)", p, mem, sz);
 ^
src/ticks/sxmlc.c:1896:2: portability: %d in format string (no. 3) requires 'int' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_sint]
 printf("0x%x: REALLOC 0x%x (%d)", p, mem, sz);
 ^
src/ticks/sxmlc.c:1906:2: warning: %x in format string (no. 1) requires 'unsigned int' but the argument type is 'void *'. [invalidPrintfArgType_uint]
 printf("0x%x: FREE - NA %d - NF %d = %d\n", mem, nb_alloc, nb_free, nb_alloc - nb_free);
 ^
src/ticks/sxmlc.c:1921:2: warning: %x in format string (no. 1) requires 'unsigned int' but the argument type is 'signed char *'. [invalidPrintfArgType_uint]
 printf("0x%x: STRDUP (%d) - NA %d - NF %d = %d\n", p, sx_strlen(s), nb_alloc, nb_free, nb_alloc - nb_free);
 ^
src/ticks/sxmlc.c:1921:2: portability: %d in format string (no. 2) requires 'int' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_sint]
 printf("0x%x: STRDUP (%d) - NA %d - NF %d = %d\n", p, sx_strlen(s), nb_alloc, nb_free, nb_alloc - nb_free);
 ^
src/ticks/sxmlc.c:1808:0: information: Skipping configuration '_MAX_PATH' since the value of '_MAX_PATH' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 sx_strncpy(doc->filename, filename, SXMLC_MAX_PATH - 1);
^
src/ticks/sxmlc.c:1809:0: information: Skipping configuration '_MAX_PATH' since the value of '_MAX_PATH' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 doc->filename[SXMLC_MAX_PATH - 1] = NULC;
^
src/ticks/sxmlsearch.c:565:38: warning: The address of local variable 'xp' might be accessed at non-zero index. [objectIndex]
  (void)str2html(node->text, &(*xpath[sx_strlen(*xpath)]));
                                     ^
src/ticks/sxmlsearch.c:608:24: note: Address of variable taken here.
  if (_get_XPath(node, &xp) == NULL) {
                       ^
src/ticks/sxmlsearch.c:608:24: note: Calling function '_get_XPath', 2nd argument '&xp' value is lifetime=xp
  if (_get_XPath(node, &xp) == NULL) {
                       ^
src/ticks/sxmlsearch.c:559:13: note: Assuming condition is Assuming condition is false
 if (*xpath == NULL)
            ^
src/ticks/sxmlsearch.c:565:38: note: The address of local variable 'xp' might be accessed at non-zero index.
  (void)str2html(node->text, &(*xpath[sx_strlen(*xpath)]));
                                     ^
src/ticks/sxmlsearch.c:565:38: warning: The address of local variable 'xparent' might be accessed at non-zero index. [objectIndex]
  (void)str2html(node->text, &(*xpath[sx_strlen(*xpath)]));
                                     ^
src/ticks/sxmlsearch.c:619:26: note: Address of variable taken here.
  if (_get_XPath(parent, &xparent) == NULL) goto xp_err;
                         ^
src/ticks/sxmlsearch.c:619:26: note: Calling function '_get_XPath', 2nd argument '&xparent' value is lifetime=xparent
  if (_get_XPath(parent, &xparent) == NULL) goto xp_err;
                         ^
src/ticks/sxmlsearch.c:559:13: note: Assuming condition is Assuming condition is false
 if (*xpath == NULL)
            ^
src/ticks/sxmlsearch.c:565:38: note: The address of local variable 'xparent' might be accessed at non-zero index.
  (void)str2html(node->text, &(*xpath[sx_strlen(*xpath)]));
                                     ^
src/ticks/sxmlsearch.c:165:4: error: Memory pointed to by 'value' is freed twice. [doubleFree]
   __free(value);
   ^
src/ticks/sxmlsearch.c:156:4: note: Memory pointed to by 'value' is freed twice.
   __free(value);
   ^
src/ticks/sxmlsearch.c:165:4: note: Memory pointed to by 'value' is freed twice.
   __free(value);
   ^
src/ticks/sxmlsearch.c:166:3: error: Memory pointed to by 'name' is freed twice. [doubleFree]
  __free(name);
  ^
src/ticks/sxmlsearch.c:158:4: note: Memory pointed to by 'name' is freed twice.
   __free(name);
   ^
src/ticks/sxmlsearch.c:166:3: note: Memory pointed to by 'name' is freed twice.
  __free(name);
  ^
src/ticks/sxmlsearch.c:72:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
src/ticks/sxmlsearch.c:315:19: style: The scope of the variable 'cc' can be reduced. [variableScope]
 SXML_CHAR c, c1, cc;
                  ^
src/ticks/sxmlsearch.c:380:12: style: The scope of the variable 'c' can be reduced. [variableScope]
 SXML_CHAR c;
           ^
src/ticks/sxmlsearch.c:462:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i, j;
     ^
src/ticks/sxmlsearch.c:462:9: style: The scope of the variable 'j' can be reduced. [variableScope]
 int i, j;
        ^
src/ticks/syms.c:201:25: style: Condition 'argc>=8' is always true [knownConditionTrueFalse]
                if(argc >= 8) {
                        ^
src/ticks/syms.c:102:23: note: Assuming that condition 'argc<10' is not redundant
            if ( argc < 10 ) {
                      ^
src/ticks/syms.c:201:25: note: Condition 'argc>=8' is always true
                if(argc >= 8) {
                        ^
src/ticks/syms.c:222:30: style: Condition 'argc>9' is always true [knownConditionTrueFalse]
            } else if ( argc > 9 ) {
                             ^
src/ticks/syms.c:102:23: note: Assuming that condition 'argc<10' is not redundant
            if ( argc < 10 ) {
                      ^
src/ticks/syms.c:222:30: note: Condition 'argc>9' is always true
            } else if ( argc > 9 ) {
                             ^
src/ticks/syms.c:52:10: warning: sscanf() without field width limits can crash with huge input data. [invalidscanf]
    if ( sscanf(input,"%[^:]::%[^:]::%d::%d:%d",filename,funcname, level, scope, lineno) == 5 ) {
         ^
src/ticks/syms.c:63:10: warning: sscanf() without field width limits can crash with huge input data. [invalidscanf]
    if ( sscanf(input,"%[^:]::%[^:]:%d",filename,funcname, lineno) == 3 ) {
         ^
src/ticks/syms.c:74:10: warning: sscanf() without field width limits can crash with huge input data. [invalidscanf]
    if ( sscanf(input,"%[^:]:%d",filename,lineno) == 2 ) {
         ^
src/ticks/syms.c:183:25: warning: sscanf() without field width limits can crash with huge input data. [invalidscanf]
                    if (sscanf(argv[9], "%[^:]", fname) == 1) {
                        ^
src/ticks/syms.c:93:16: style: The scope of the variable 'temp' can be reduced. [variableScope]
    UT_string* temp;
               ^
src/ticks/syms.c:331:46: style:inconclusive: Function 'find_symbol' argument 2 names different: declaration 'preferred_symtype' definition 'preferred_type'. [funcArgNamesDifferent]
const char *find_symbol(int addr, symboltype preferred_type)
                                             ^
src/ticks/syms.h:38:57: note: Function 'find_symbol' argument 2 names different: declaration 'preferred_symtype' definition 'preferred_type'.
extern const char     *find_symbol(int addr, symboltype preferred_symtype);
                                                        ^
src/ticks/syms.c:331:46: note: Function 'find_symbol' argument 2 names different: declaration 'preferred_symtype' definition 'preferred_type'.
const char *find_symbol(int addr, symboltype preferred_type)
                                             ^
src/ticks/syms.c:456:31: style:inconclusive: Function 'symbol_add_autolabel' argument 1 names different: declaration 'addr' definition 'address'. [funcArgNamesDifferent]
void symbol_add_autolabel(int address, char *label)
                              ^
src/ticks/syms.h:42:38: note: Function 'symbol_add_autolabel' argument 1 names different: declaration 'addr' definition 'address'.
extern void symbol_add_autolabel(int addr, char *label);
                                     ^
src/ticks/syms.c:456:31: note: Function 'symbol_add_autolabel' argument 1 names different: declaration 'addr' definition 'address'.
void symbol_add_autolabel(int address, char *label)
                              ^
src/ticks/syms.c:224:24: style: Local variable 'filename' shadows outer argument [shadowArgument]
                char   filename[FILENAME_MAX+1];
                       ^
src/ticks/syms.c:90:29: note: Shadowed declaration
void read_symbol_file(char *filename)
                            ^
src/ticks/syms.c:224:24: note: Shadow variable
                char   filename[FILENAME_MAX+1];
                       ^
src/ticks/syms.c:241:22: style: Local variable 'f' shadows outer function [shadowFunction]
        symbol_file* f = NULL;
                     ^
src/ticks/ticks.h:46:12: note: Shadowed declaration
extern int f(void);
           ^
src/ticks/syms.c:241:22: note: Shadow variable
        symbol_file* f = NULL;
                     ^
src/ticks/syms.c:260:22: style: Local variable 'f' shadows outer function [shadowFunction]
        symbol_file* f = NULL;
                     ^
src/ticks/ticks.h:46:12: note: Shadowed declaration
extern int f(void);
           ^
src/ticks/syms.c:260:22: note: Shadow variable
        symbol_file* f = NULL;
                     ^
src/ticks/syms.c:280:22: style: Local variable 'f' shadows outer function [shadowFunction]
        symbol_file* f;
                     ^
src/ticks/ticks.h:46:12: note: Shadowed declaration
extern int f(void);
           ^
src/ticks/syms.c:280:22: note: Shadow variable
        symbol_file* f;
                     ^
src/ticks/syms.c:94:9: style: Unused variable: length [unusedVariable]
    int length;
        ^
src/ticks/syms.c:47:10: warning: sscanf() without field width limits can crash with huge input data. [invalidscanf]
    if ( sscanf(input,"%c:%[^:]::%[^:]::%d::%d:%d",filename,&filename[2], funcname, level, scope, lineno) == 6) {
         ^
src/ticks/syms.c:58:10: warning: sscanf() without field width limits can crash with huge input data. [invalidscanf]
    if ( sscanf(input,"%c:%[^:]::%[^:]:%d",filename,&filename[2],funcname, lineno) == 4 ) {
         ^
src/ticks/syms.c:69:10: warning: sscanf() without field width limits can crash with huge input data. [invalidscanf]
    if ( sscanf(input,"%c:%[^:]:%d",filename,&filename[2], lineno) == 3) {
         ^
src/ticks/ticks.c:793:11: warning: %llu in format string (no. 1) requires 'unsigned long long *' but the argument type is 'signed long long *'. [invalidScanfArgType_int]
          sscanf(argv[1], "%llu", &counter);
          ^
src/ticks/ticks.c:4704:5: warning: %llu in format string (no. 1) requires 'unsigned long long' but the argument type is 'signed long long'. [invalidPrintfArgType_uint]
    printf("%llu\n", st);
    ^
src/ticks/ticks.c:4567:47: style: Variable 'mp' is reassigned a value before the old one has been used. [redundantAssignment]
                              w && (st+= 5, mp=--pc, --pc));
                                              ^
src/ticks/ticks.c:4560:22: note: mp is assigned
                     ++mp;
                     ^
src/ticks/ticks.c:4567:47: note: mp is overwritten
                              w && (st+= 5, mp=--pc, --pc));
                                              ^
src/ticks/ticks.c:4584:47: style: Variable 'mp' is reassigned a value before the old one has been used. [redundantAssignment]
                              w && (st+= 5, mp=--pc, --pc));
                                              ^
src/ticks/ticks.c:4577:22: note: mp is assigned
                     --mp;
                     ^
src/ticks/ticks.c:4584:47: note: mp is overwritten
                              w && (st+= 5, mp=--pc, --pc));
                                              ^
src/ticks/ticks.c:4619:40: style: Variable 'mp' is reassigned a value before the old one has been used. [redundantAssignment]
                     --b && (st+= 5, mp= --pc, --pc);
                                       ^
src/ticks/ticks.c:4617:22: note: mp is assigned
                     ++mp;
                     ^
src/ticks/ticks.c:4619:40: note: mp is overwritten
                     --b && (st+= 5, mp= --pc, --pc);
                                       ^
src/ticks/ticks.c:4631:40: style: Variable 'mp' is reassigned a value before the old one has been used. [redundantAssignment]
                     --b && (st+= 5, mp= --pc, --pc);
                                       ^
src/ticks/ticks.c:4629:22: note: mp is assigned
                     --mp;
                     ^
src/ticks/ticks.c:4631:40: note: mp is overwritten
                     --b && (st+= 5, mp= --pc, --pc);
                                       ^
src/ticks/ticks.c:4671:38: style: Variable 'mp' is reassigned a value before the old one has been used. [redundantAssignment]
                     b && (st+= 5, mp= --pc, --pc);
                                     ^
src/ticks/ticks.c:4668:22: note: mp is assigned
                     ++mp;
                     ^
src/ticks/ticks.c:4671:38: note: mp is overwritten
                     b && (st+= 5, mp= --pc, --pc);
                                     ^
src/ticks/ticks.c:4685:38: style: Variable 'mp' is reassigned a value before the old one has been used. [redundantAssignment]
                     b && (st+= 5, mp= --pc, --pc);
                                     ^
src/ticks/ticks.c:4682:22: note: mp is assigned
                     --mp;
                     ^
src/ticks/ticks.c:4685:38: note: mp is overwritten
                     b && (st+= 5, mp= --pc, --pc);
                                     ^
src/ticks/ticks.c:1558:23: style: Same expression on both sides of '^'. [duplicateExpression]
          if ( altd ) ADDRRRR_ALTD(h, l, h, l, h_, l_);
                      ^
src/ticks/ticks.c:1559:16: style: Same expression on both sides of '^'. [duplicateExpression]
          else ADDRRRR(h, l, h, l);
               ^
src/ticks/ticks.c:1561:23: style: Same expression on both sides of '^'. [duplicateExpression]
          if ( altd ) ADDRRRR_ALTD(yh, yl, yh, yl, yh, yl);
                      ^
src/ticks/ticks.c:1562:16: style: Same expression on both sides of '^'. [duplicateExpression]
          else ADDRRRR(yh, yl, yh, yl);
               ^
src/ticks/ticks.c:1564:23: style: Same expression on both sides of '^'. [duplicateExpression]
          if ( altd ) ADDRRRR_ALTD(xh, xl, xh, xl, xh, xl);
                      ^
src/ticks/ticks.c:1565:16: style: Same expression on both sides of '^'. [duplicateExpression]
          else ADDRRRR(xh, xl, xh, xl);
               ^
src/ticks/ticks.c:1085:9: style: Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]
        break;
        ^
src/ticks/ticks.c:1223:9: style: Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]
        break;
        ^
src/ticks/ticks.c:1266:9: style: Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]
        break;
        ^
src/ticks/ticks.c:2685:11: style: Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]
          break;
          ^
src/ticks/ticks.c:3125:11: style: Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]
          break;
          ^
src/ticks/ticks.c:2935:13: error: Expression 'mp&65280|++mp' depends on order of evaluation of side effects [unknownEvaluationOrder]
            | ++mp;
            ^
src/ticks/ticks.c:931:15: style: Local variable 'fk' shadows outer variable [shadowVariable]
        FILE *fk= fopen("48.rom", "rb");
              ^
src/ticks/ticks.c:536:9: note: Shadowed declaration
      , fk = 0
        ^
src/ticks/ticks.c:931:15: note: Shadow variable
        FILE *fk= fopen("48.rom", "rb");
              ^
src/ticks/ticks.c:1014:13: style: Local variable 'l' shadows outer variable [shadowVariable]
        int l;
            ^
src/ticks/ticks.h:30:34: note: Shadowed declaration
extern unsigned char a,b,c,d,e,h,l;
                                 ^
src/ticks/ticks.c:1014:13: note: Shadow variable
        int l;
            ^
src/ticks/ticks.c:3928:23: style: Local variable 'v' shadows outer variable [shadowVariable]
              uint8_t v = get_memory(pc++);
                      ^
src/ticks/ticks.c:516:9: note: Shadowed declaration
int     v
        ^
src/ticks/ticks.c:3928:23: note: Shadow variable
              uint8_t v = get_memory(pc++);
                      ^
src/ticks/ticks.c:3949:23: style: Local variable 'v' shadows outer variable [shadowVariable]
              uint8_t v = get_memory(pc++);
                      ^
src/ticks/ticks.c:516:9: note: Shadowed declaration
int     v
        ^
src/ticks/ticks.c:3949:23: note: Shadow variable
              uint8_t v = get_memory(pc++);
                      ^
src/ticks/ticks.c:3950:23: style: Local variable 'r' shadows outer variable [shadowVariable]
              uint8_t r = get_memory(pc++);
                      ^
src/ticks/ticks.c:564:9: note: Shadowed declaration
      , r= 0
        ^
src/ticks/ticks.c:3950:23: note: Shadow variable
              uint8_t r = get_memory(pc++);
                      ^
src/ticks/ticks.c:3960:23: style: Local variable 'v' shadows outer variable [shadowVariable]
              uint8_t v = get_memory(pc++);
                      ^
src/ticks/ticks.c:516:9: note: Shadowed declaration
int     v
        ^
src/ticks/ticks.c:3960:23: note: Shadow variable
              uint8_t v = get_memory(pc++);
                      ^
src/ticks/ticks.c:4070:23: style: Local variable 'v' shadows outer variable [shadowVariable]
              uint8_t v = get_memory(l | h << 8);
                      ^
src/ticks/ticks.c:516:9: note: Shadowed declaration
int     v
        ^
src/ticks/ticks.c:4070:23: note: Shadow variable
              uint8_t v = get_memory(l | h << 8);
                      ^
src/ticks/ticks.c:4160:23: style: Local variable 'v' shadows outer variable [shadowVariable]
              uint8_t v = get_memory(pc++);
                      ^
src/ticks/ticks.c:516:9: note: Shadowed declaration
int     v
        ^
src/ticks/ticks.c:4160:23: note: Shadow variable
              uint8_t v = get_memory(pc++);
                      ^
src/ticks/ticks.c:4352:24: style: Local variable 'v' shadows outer variable [shadowVariable]
              uint16_t v = b * c;
                       ^
src/ticks/ticks.c:516:9: note: Shadowed declaration
int     v
        ^
src/ticks/ticks.c:4352:24: note: Shadow variable
              uint16_t v = b * c;
                       ^
src/ticks/ticks.c:4364:24: style: Local variable 'v' shadows outer variable [shadowVariable]
              uint16_t v = d * e;
                       ^
src/ticks/ticks.c:516:9: note: Shadowed declaration
int     v
        ^
src/ticks/ticks.c:4364:24: note: Shadow variable
              uint16_t v = d * e;
                       ^
src/ticks/ticks.c:4376:24: style: Local variable 'v' shadows outer variable [shadowVariable]
              uint16_t v = h * l;
                       ^
src/ticks/ticks.c:516:9: note: Shadowed declaration
int     v
        ^
src/ticks/ticks.c:4376:24: note: Shadow variable
              uint16_t v = h * l;
                       ^
src/ticks/ticks.c:611:19: warning:inconclusive: Found suspicious operator '&&' [constStatement]
  wavpos!=0x20000 && (ear^= 64);
                  ^
src/ticks/ticks.c:794:21: warning:inconclusive: Found suspicious operator '&&' [constStatement]
          counter<0 && (counter= 9e18);
                    ^
src/ticks/ticks.c:1059:16: warning:inconclusive: Found suspicious operator '&&' [constStatement]
        halted && (pc++, halted= 0);
               ^
src/ticks/ticks.c:1731:30: warning:inconclusive: Found suspicious operator '&&' [constStatement]
            (a |ff&256)>0x99 && (u= 0x160);
                             ^
src/ticks/ticks.c:1732:26: warning:inconclusive: Found suspicious operator '&&' [constStatement]
            (a&15 | t)>9 && (u+= 6);
                         ^
src/ticks/ticks.c:4177:16: warning:inconclusive: Found suspicious operator '&&' [constStatement]
            fr && (fr= 1);
               ^
src/ticks/ticks.c:4183:17: warning:inconclusive: Found suspicious operator '&&' [constStatement]
            b|c && (fa= 128);
                ^
src/ticks/ticks.c:4195:16: warning:inconclusive: Found suspicious operator '&&' [constStatement]
            fr && (fr= 1);
               ^
src/ticks/ticks.c:4201:17: warning:inconclusive: Found suspicious operator '&&' [constStatement]
            b|c && (fa= 128);
                ^
src/ticks/ticks.c:4213:16: warning:inconclusive: Found suspicious operator '&&' [constStatement]
            fr && (fr= 1);
               ^
src/ticks/ticks.c:4219:17: warning:inconclusive: Found suspicious operator '&&' [constStatement]
            b|c && ( fa= 128,
                ^
src/ticks/ticks.c:4236:16: warning:inconclusive: Found suspicious operator '&&' [constStatement]
            fr && (fr= 1);
               ^
src/ticks/ticks.c:4242:17: warning:inconclusive: Found suspicious operator '&&' [constStatement]
            b|c && ( fa= 128,
                ^
src/ticks/ticks.c:4471:25: warning:inconclusive: Found suspicious operator '&&' [constStatement]
                     fr && (fr= 1);
                        ^
src/ticks/ticks.c:4477:26: warning:inconclusive: Found suspicious operator '&&' [constStatement]
                     b|c && (fa= 128);
                         ^
src/ticks/ticks.c:4484:25: warning:inconclusive: Found suspicious operator '&&' [constStatement]
                     fr && (fr= 1);
                        ^
src/ticks/ticks.c:4490:26: warning:inconclusive: Found suspicious operator '&&' [constStatement]
                     b|c && (fa= 128);
                         ^
src/ticks/ticks.c:4497:25: warning:inconclusive: Found suspicious operator '&&' [constStatement]
                     fr && (fr= 1);
                        ^
src/ticks/ticks.c:4503:26: warning:inconclusive: Found suspicious operator '&&' [constStatement]
                     b|c && ( fa= 128,
                         ^
src/ticks/ticks.c:4513:25: warning:inconclusive: Found suspicious operator '&&' [constStatement]
                     fr && (fr= 1);
                        ^
src/ticks/ticks.c:4519:26: warning:inconclusive: Found suspicious operator '&&' [constStatement]
                     b|c && ( fa= 128,
                         ^
src/ticks/ticks.c:4533:26: warning:inconclusive: Found suspicious operator '&&' [constStatement]
                     b|c && ( fa|= 128,
                         ^
src/ticks/ticks.c:4549:26: warning:inconclusive: Found suspicious operator '&&' [constStatement]
                     b|c && ( fa|= 128,
                         ^
src/ticks/ticks.c:4565:26: warning:inconclusive: Found suspicious operator '&&' [constStatement]
                     b|c && ( fa|= 128,
                         ^
src/ticks/ticks.c:4582:26: warning:inconclusive: Found suspicious operator '&&' [constStatement]
                     b|c && ( fa|= 128,
                         ^
src/ticks/ticks.c:4619:26: warning:inconclusive: Found suspicious operator '&&' [constStatement]
                     --b && (st+= 5, mp= --pc, --pc);
                         ^
src/ticks/ticks.c:4631:26: warning:inconclusive: Found suspicious operator '&&' [constStatement]
                     --b && (st+= 5, mp= --pc, --pc);
                         ^
src/ticks/ticks.c:4671:24: warning:inconclusive: Found suspicious operator '&&' [constStatement]
                     b && (st+= 5, mp= --pc, --pc);
                       ^
src/ticks/ticks.c:4685:24: warning:inconclusive: Found suspicious operator '&&' [constStatement]
                     b && (st+= 5, mp= --pc, --pc);
                       ^
src/ticks/ticks.c:2736:13: style: Clarify calculation precedence for '|' and '?'. [clarifyCalculation]
            BOOL(h,l, h_, l_, altd);
            ^
src/ticks/ticks.c:2738:13: style: Clarify calculation precedence for '|' and '?'. [clarifyCalculation]
            BOOL(yh, yl, yh, yl, 0);
            ^
src/ticks/ticks.c:2740:13: style: Clarify calculation precedence for '|' and '?'. [clarifyCalculation]
            BOOL(xh,xl,xh,xl, 0);
            ^
src/ticks/utf8.c:111:37: style:inconclusive: Function 'utf8_index' argument 2 names different: declaration 'charindex' definition 'index'. [funcArgNamesDifferent]
int utf8_index(const char *str, int index)
                                    ^
src/ticks/utf8.h:77:37: note: Function 'utf8_index' argument 2 names different: declaration 'charindex' definition 'index'.
int utf8_index(const char *str, int charindex);
                                    ^
src/ticks/utf8.c:111:37: note: Function 'utf8_index' argument 2 names different: declaration 'charindex' definition 'index'.
int utf8_index(const char *str, int index)
                                    ^
src/ucpp/arith.c:1336:10: style: Variable 'warn' is reassigned a value before the old one has been used. [redundantAssignment]
  } warn = 1;
         ^
src/ucpp/arith.c:1333:48: note: warn is assigned
   if (y.msw == SIMUL_TRAP && y.lsw == 0) warn = 1;
                                               ^
src/ucpp/arith.c:1336:10: note: warn is overwritten
  } warn = 1;
         ^
src/ucpp/arith.h:174:0: information: Skipping configuration 'ARITHMETIC_CHECKS;NATIVE_SIGNED' since the value of 'NATIVE_SIGNED' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
typedef NATIVE_SIGNED arith_s;
^
src/ucpp/arith.h:174:0: information: Skipping configuration 'ARITHMETIC_CHECKS;NATIVE_SIGNED;ONES_COMPLEMENT=0' since the value of 'NATIVE_SIGNED' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
typedef NATIVE_SIGNED arith_s;
^
src/ucpp/arith.h:174:0: information: Skipping configuration 'ARITHMETIC_CHECKS;NATIVE_SIGNED;SIGNED_IS_BIGGER=0' since the value of 'NATIVE_SIGNED' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
typedef NATIVE_SIGNED arith_s;
^
src/ucpp/arith.h:174:0: information: Skipping configuration 'NATIVE_SIGNED' since the value of 'NATIVE_SIGNED' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
typedef NATIVE_SIGNED arith_s;
^
src/ucpp/assert.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 15 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/ucpp/arith.c:1021:13: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
 t00 = (a & SIMUL_LSW_HALFMASK) * (b & SIMUL_LSW_HALFMASK);
            ^
src/ucpp/arith.c:1022:13: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
 t01 = (a & SIMUL_LSW_HALFMASK) * (b >> SIMUL_LSW_HALFLEN);
            ^
src/ucpp/arith.c:1023:40: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
 t10 = (a >> SIMUL_LSW_HALFLEN) * (b & SIMUL_LSW_HALFMASK);
                                       ^
src/ucpp/cpp.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 28 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/ucpp/cpp.c:1067:2: error: Address of local auto-variable assigned to a function parameter. [autoVariables]
 ls->output_fifo = &tf2;
 ^
src/ucpp/cpp.c:1319:2: error: Address of local auto-variable assigned to a function parameter. [autoVariables]
 ls->output_fifo = &tf2;
 ^
src/ucpp/cpp.c:1470:2: error: Address of local auto-variable assigned to a function parameter. [autoVariables]
 ls->output_fifo = &tf2;
 ^
src/ucpp/cpp.c:1061:3: error: Memory leak: tf1.t [memleak]
  return -1;
  ^
src/ucpp/cpp.c:1154:3: error: Memory leak: tf2.t [memleak]
  return -1;
  ^
src/ucpp/cpp.c:1182:3: error: Memory leak: tf3.t [memleak]
  return -1;
  ^
src/ucpp/cpp.c:1677:3: error: Memory leak: tf.t [memleak]
  return;
  ^
src/ucpp/cpp.c:1724:13: style: Redundant initialization for 'save_flags'. The initialized value is overwritten before it is read. [redundantInitialization]
 save_flags = ls->flags;
            ^
src/ucpp/cpp.c:1721:27: note: save_flags is initialized
 unsigned long save_flags = ls->flags;
                          ^
src/ucpp/cpp.c:1724:13: note: save_flags is overwritten
 save_flags = ls->flags;
            ^
src/ucpp/cpp.c:674:7: style: Local variable 'i' shadows outer variable [shadowVariable]
  int i;
      ^
src/ucpp/cpp.c:663:6: note: Shadowed declaration
 int i, incdir = -1;
     ^
src/ucpp/cpp.c:674:7: note: Shadow variable
  int i;
      ^
src/ucpp/cpp.c:1091:13: style: Local variable 'ltww' shadows outer variable [shadowVariable]
   int nnp, ltww = 1;
            ^
src/ucpp/cpp.c:994:15: note: Shadowed declaration
 int ret = 0, ltww = 1;
              ^
src/ucpp/cpp.c:1091:13: note: Shadow variable
   int nnp, ltww = 1;
            ^
src/ucpp/cpp.c:1667:17: style: Local variable 't' shadows outer variable [shadowVariable]
   struct token t;
                ^
src/ucpp/cpp.c:1656:15: note: Shadowed declaration
 struct token t;
              ^
src/ucpp/cpp.c:1667:17: note: Shadow variable
   struct token t;
                ^
src/ucpp/cpp.c:185:3: style: Argument '(gf->memgarb=32)*sizeof(char*)' to function malloc is always 256. It does not matter what value 'gf->memgarb' has. [knownArgument]
  * sizeof(char *));
  ^
src/ucpp/cpp.c:363:35: style: Argument 'ls->tknl=64' to function malloc is always 64. It does not matter what value 'ls->tknl' has. [knownArgument]
 ls->ctok->name = getmem(ls->tknl = TOKEN_NAME_MEMG);
                                  ^
src/ucpp/cpp.c:2274:4: warning: Found function call inside sizeof(). [sizeofFunctionCall]
   aol(include_path, include_path_nb,
   ^
src/ucpp/cpp.c:2284:2: warning: Found function call inside sizeof(). [sizeofFunctionCall]
 aol(include_path, include_path_nb, sdup(path), INCPATH_MEMG);
 ^
src/ucpp/cpp.c:1569:2: warning: Suspicious usage of 'sizeof' with a numeric constant as parameter. [sizeofwithnumericparameter]
 wan(buf, p, 0, lp);
 ^
src/ucpp/cpp.c:1589:2: warning: Suspicious usage of 'sizeof' with a numeric constant as parameter. [sizeofwithnumericparameter]
 wan(buf, p, 0, lp);
 ^
src/ucpp/cpp.c:1173:4: error: Uninitialized struct member: rt.line [uninitStructMember]
   aol(tf3.t, tf3.nt, rt, TOKEN_LIST_MEMG);
   ^
src/ucpp/cpp.c:1672:4: error: Uninitialized struct member: t.line [uninitStructMember]
   aol(tf.t, tf.nt, t, TOKEN_LIST_MEMG);
   ^
src/ucpp/cpp.c:817:8: style: Variable 'nffa' is assigned a value that is never used. [unreadVariable]
  nffa = 0;
       ^
src/ucpp/cpp.c:459:15: style: Checking if unsigned expression 'ls_depth' is less than zero. [unsignedLessThanZero]
 if (ls_depth <= 0) ouch("prepare to meet thy creator");
              ^
src/ucpp/cpp.c:185:3: style: Argument '(gf->memgarb=32)*sizeof(char*)' to function getmem is always 256. It does not matter what value 'gf->memgarb' has. [knownArgument]
  * sizeof(char *));
  ^
src/ucpp/cpp.c:363:35: style: Argument 'ls->tknl=64' to function getmem is always 64. It does not matter what value 'ls->tknl' has. [knownArgument]
 ls->ctok->name = getmem(ls->tknl = TOKEN_NAME_MEMG);
                                  ^
src/ucpp/cpp.c:2528:7: style: Condition '!ls->input' is always true [knownConditionTrueFalse]
  if (!ls->input) {
      ^
src/ucpp/cpp.c:2523:15: note: Assignment 'ls->input=0', assigned value is 0
  ls->input = 0;
              ^
src/ucpp/cpp.c:2528:7: note: Condition '!ls->input' is always true
  if (!ls->input) {
      ^
src/ucpp/cpp.c:2570:6: style: Condition 'with_std_incpath' is always false [knownConditionTrueFalse]
 if (with_std_incpath) {
     ^
src/ucpp/cpp.c:2402:25: note: Assignment 'with_std_incpath=0', assigned value is 0
 int with_std_incpath = 0;
                        ^
src/ucpp/cpp.c:2570:6: note: Condition 'with_std_incpath' is always false
 if (with_std_incpath) {
     ^
src/ucpp/cpp.c:2404:6: style: Local variable 'system_macros' shadows outer variable [shadowVariable]
 int system_macros = 0, standard_assertions = 1;
     ^
src/ucpp/cpp.h:280:31: note: Shadowed declaration
extern int no_special_macros, system_macros,
                              ^
src/ucpp/cpp.c:2404:6: note: Shadow variable
 int system_macros = 0, standard_assertions = 1;
     ^
src/ucpp/eval.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 23 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/ucpp/arith.c:266:11: error: Shifting by a negative value is undefined behaviour [shiftNegative]
 return x << y;
          ^
src/ucpp/arith.c:277:11: error: Shifting by a negative value is undefined behaviour [shiftNegative]
 return x >> y;
          ^
src/ucpp/arith.c:566:11: error: Shifting by a negative value is undefined behaviour [shiftNegative]
 return x << y;
          ^
src/ucpp/arith.c:590:11: error: Shifting by a negative value is undefined behaviour [shiftNegative]
 return x >> y;
          ^
src/ucpp/eval.c:311:0: information: Skipping configuration 'CHAR_MIN=0;WCHAR_SIGNEDNESS' since the value of 'WCHAR_SIGNEDNESS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  q.sign = (*c == 'L') ? WCHAR_SIGNEDNESS : 1;
^
src/ucpp/arith.h:194:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_S_U(to_u);
^
src/ucpp/arith.h:195:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_I_U(fromint);
^
src/ucpp/arith.h:196:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_L_U(fromulong);
^
src/ucpp/arith.h:197:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_U_I(toint);
^
src/ucpp/arith.h:198:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_U_L(toulong);
^
src/ucpp/arith.h:200:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_U_U(neg);
^
src/ucpp/arith.h:201:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_U_U(not);
^
src/ucpp/arith.h:202:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_U_I(lnot);
^
src/ucpp/arith.h:203:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_U_I(lval);
^
src/ucpp/arith.h:205:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UU_U(plus);
^
src/ucpp/arith.h:206:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UU_U(minus);
^
src/ucpp/arith.h:207:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UI_U(lsh);
^
src/ucpp/arith.h:208:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UI_U(rsh);
^
src/ucpp/arith.h:209:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UU_I(lt);
^
src/ucpp/arith.h:210:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UU_I(leq);
^
src/ucpp/arith.h:211:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UU_I(gt);
^
src/ucpp/arith.h:212:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UU_I(geq);
^
src/ucpp/arith.h:213:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UU_I(same);
^
src/ucpp/arith.h:214:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UU_I(neq);
^
src/ucpp/arith.h:215:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UU_U(and);
^
src/ucpp/arith.h:216:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UU_U(xor);
^
src/ucpp/arith.h:217:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UU_U(or);
^
src/ucpp/arith.h:218:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UU_U(star);
^
src/ucpp/arith.h:219:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UU_U(slash);
^
src/ucpp/arith.h:220:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UU_U(pct);
^
src/ucpp/arith.h:224:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_U_S(to_s);
^
src/ucpp/arith.h:225:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_I_S(fromint);
^
src/ucpp/arith.h:226:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_L_S(fromlong);
^
src/ucpp/arith.h:227:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_S_I(toint);
^
src/ucpp/arith.h:228:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_S_L(tolong);
^
src/ucpp/arith.h:230:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_S_S(neg);
^
src/ucpp/arith.h:231:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_S_S(not);
^
src/ucpp/arith.h:232:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_S_I(lnot);
^
src/ucpp/arith.h:233:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_S_I(lval);
^
src/ucpp/arith.h:235:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SS_S(plus);
^
src/ucpp/arith.h:236:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SS_S(minus);
^
src/ucpp/arith.h:237:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SI_S(lsh);
^
src/ucpp/arith.h:238:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SI_S(rsh);
^
src/ucpp/arith.h:239:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SS_I(lt);
^
src/ucpp/arith.h:240:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SS_I(leq);
^
src/ucpp/arith.h:241:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SS_I(gt);
^
src/ucpp/arith.h:242:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SS_I(geq);
^
src/ucpp/arith.h:243:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SS_I(same);
^
src/ucpp/arith.h:244:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SS_I(neq);
^
src/ucpp/arith.h:245:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SS_S(and);
^
src/ucpp/arith.h:246:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SS_S(xor);
^
src/ucpp/arith.h:247:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SS_S(or);
^
src/ucpp/arith.h:248:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SS_S(star);
^
src/ucpp/arith.h:249:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SS_S(slash);
^
src/ucpp/arith.h:250:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SS_S(pct);
^
src/ucpp/arith.h:253:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_ST_US(octconst);
^
src/ucpp/arith.h:254:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_ST_US(hexconst);
^
src/ucpp/arith.h:255:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_ST_US(decconst);
^
src/ucpp/arith.c:220:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_S_U(to_u) { return (arith_u)x; }
^
src/ucpp/arith.c:221:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_I_U(fromint) { return (arith_u)x; }
^
src/ucpp/arith.c:222:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_L_U(fromulong) { return (arith_u)x; }
^
src/ucpp/arith.c:224:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_U_I(toint)
^
src/ucpp/arith.c:232:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_U_L(toulong)
^
src/ucpp/arith.c:240:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_U_U(neg) { return -x; }
^
src/ucpp/arith.c:241:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_U_U(not) { return ~x; }
^
src/ucpp/arith.c:242:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_U_I(lnot) { return !x; }
^
src/ucpp/arith.c:243:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_U_I(lval) { return x != 0; }
^
src/ucpp/arith.c:245:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UU_U(plus) { return x + y; }
^
src/ucpp/arith.c:246:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UU_U(minus) { return x - y; }
^
src/ucpp/arith.c:247:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UU_I(lt) { return x < y; }
^
src/ucpp/arith.c:248:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UU_I(leq) { return x <= y; }
^
src/ucpp/arith.c:249:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UU_I(gt) { return x > y; }
^
src/ucpp/arith.c:250:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UU_I(geq) { return x >= y; }
^
src/ucpp/arith.c:251:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UU_I(same) { return x == y; }
^
src/ucpp/arith.c:252:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UU_I(neq) { return x != y; }
^
src/ucpp/arith.c:253:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UU_U(and) { return x & y; }
^
src/ucpp/arith.c:254:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UU_U(xor) { return x ^ y; }
^
src/ucpp/arith.c:255:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UU_U(or) { return x | y; }
^
src/ucpp/arith.c:256:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UU_U(star) { return x * y; }
^
src/ucpp/arith.c:258:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UI_U(lsh)
^
src/ucpp/arith.c:269:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UI_U(rsh)
^
src/ucpp/arith.c:280:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UU_U(slash)
^
src/ucpp/arith.c:286:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_UU_U(pct)
^
src/ucpp/arith.c:294:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_U_S(to_s)
^
src/ucpp/arith.c:305:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_I_S(fromint) { return (arith_s)x; }
^
src/ucpp/arith.c:306:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_L_S(fromlong) { return (arith_s)x; }
^
src/ucpp/arith.c:308:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_S_I(toint)
^
src/ucpp/arith.c:319:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_S_L(tolong)
^
src/ucpp/arith.c:330:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_S_S(neg)
^
src/ucpp/arith.c:341:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_S_S(not)
^
src/ucpp/arith.c:359:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_S_I(lnot) { return !x; }
^
src/ucpp/arith.c:360:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_S_I(lval) { return x != 0; }
^
src/ucpp/arith.c:385:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SS_S(plus)
^
src/ucpp/arith.c:434:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SS_S(minus)
^
src/ucpp/arith.c:469:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SS_I(lt) { return x < y; }
^
src/ucpp/arith.c:470:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SS_I(leq) { return x <= y; }
^
src/ucpp/arith.c:471:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SS_I(gt) { return x > y; }
^
src/ucpp/arith.c:472:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SS_I(geq) { return x >= y; }
^
src/ucpp/arith.c:473:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SS_I(same) { return x == y; }
^
src/ucpp/arith.c:474:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SS_I(neq) { return x != y; }
^
src/ucpp/arith.c:484:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SS_S(and)
^
src/ucpp/arith.c:501:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SS_S(xor)
^
src/ucpp/arith.c:525:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SS_S(or)
^
src/ucpp/arith.c:549:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SI_S(lsh)
^
src/ucpp/arith.c:575:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SI_S(rsh)
^
src/ucpp/arith.c:600:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SS_S(star)
^
src/ucpp/arith.c:647:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SS_S(slash)
^
src/ucpp/arith.c:660:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_BI_SS_S(pct)
^
src/ucpp/arith.c:666:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_ST_US(octconst)
^
src/ucpp/arith.c:698:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_ST_US(decconst)
^
src/ucpp/arith.c:726:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
ARITH_DECL_MONO_ST_US(hexconst)
^
src/ucpp/hash.c:42:18: style: The scope of the variable 'g' can be reduced. [variableScope]
 unsigned h = 0, g;
                 ^
src/ucpp/lexer.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 16 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/ucpp/lexer.c:805:44: style: Condition '(ls->ctok->type=ls->pending_token)==BUNCH' is always false [knownConditionTrueFalse]
  if ((ls->ctok->type = ls->pending_token) == BUNCH) {
                                           ^
src/ucpp/lexer.c:804:8: note: Assuming condition 'ls->pending_token' is true
 if (ls->pending_token) {
       ^
src/ucpp/lexer.c:805:44: note: Condition '(ls->ctok->type=ls->pending_token)==BUNCH' is always false
  if ((ls->ctok->type = ls->pending_token) == BUNCH) {
                                           ^
src/ucpp/lexer.c:844:11: style: Condition '--shift_state' is always false [knownConditionTrueFalse]
      if (-- shift_state) {
          ^
src/ucpp/lexer.c:832:9: note: Assuming condition 'shift_state' is true
    if (shift_state) {
        ^
src/ucpp/lexer.c:844:11: note: Condition '--shift_state' is always false
      if (-- shift_state) {
          ^
src/ucpp/lexer.c:600:6: style: The scope of the variable 'c' can be reduced. [variableScope]
 int c;
     ^
src/ucpp/lexer.c:457:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
static inline void write_char(struct lexer_state *ls, unsigned char c)
^
src/ucpp/lexer.c:484:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
static inline int read_char(struct lexer_state *ls)
^
src/ucpp/lexer.c:547:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
static inline int next_fifo_char(struct lexer_state *ls)
^
src/ucpp/lexer.c:559:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
static inline int char_lka1(struct lexer_state *ls)
^
src/ucpp/lexer.c:568:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
static inline int char_lka2(struct lexer_state *ls)
^
src/ucpp/lexer.c:598:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
static inline int next_char(struct lexer_state *ls)
^
src/ucpp/lexer.c:793:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
static inline int read_token(struct lexer_state *ls)
^
src/ucpp/macro.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/ucpp/macro.c:1442:5: error: Address of local auto-variable assigned to a function parameter. [autoVariables]
    ls->output_fifo = &etl;
    ^
src/ucpp/macro.c:483:7: style: The if condition is the same as the previous if condition [duplicateCondition]
  if (!redef) m->narg = narg;
      ^
src/ucpp/macro.c:475:7: note: First condition
  if (!redef) {
      ^
src/ucpp/macro.c:483:7: note: Second condition
  if (!redef) m->narg = narg;
      ^
src/ucpp/macro.c:638:13: style: Local variable 'l' shadows outer variable [shadowVariable]
  size_t i, l;
            ^
src/ucpp/macro.c:330:7: note: Shadowed declaration
 long l = ls->line;
      ^
src/ucpp/macro.c:638:13: note: Shadow variable
  size_t i, l;
            ^
src/ucpp/macro.c:1240:17: style: Local variable 't' shadows outer variable [shadowVariable]
   struct token t;
                ^
src/ucpp/macro.c:1036:15: note: Shadowed declaration
 struct token t, *ct;
              ^
src/ucpp/macro.c:1240:17: note: Shadow variable
   struct token t;
                ^
src/ucpp/macro.c:420:6: warning: Found function call inside sizeof(). [sizeofFunctionCall]
     aol(m->arg, narg,
     ^
src/ucpp/macro.c:67:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
static inline struct macro *new_macro(void)
^
src/ucpp/macro.c:96:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
static inline int check_special_macro(char *name)
^
src/ucpp/macro.c:860:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
static inline int concat_token(struct token *t1, struct token *t2)
^
src/ucpp/macro.c:933:0: information: Skipping configuration 'INLINE' since the value of 'INLINE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
static inline char *stringify_string(char *x)
^
src/ucpp/nhash.c:336:28: style: The scope of the variable 'fnode' can be reduced. [variableScope]
 hash_item_header *pnode, *fnode, *znode;
                           ^
src/ucpp/nhash.c:209:23: warning: Division by result of sizeof(). malloc() expects a size in bytes, did you intend to multiply instead? [sizeofDivisionMemfunc]
 char *ident = getmem(PTR_SHIFT + sizeof(hash_item_header *));
                      ^
src/ucpp/nhash.c:209:8: warning: Size of pointer 'ident' used instead of size of its data. [pointerSize]
 char *ident = getmem(PTR_SHIFT + sizeof(hash_item_header *));
       ^
src/ucpp/sample.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 15 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/z80asm/src/c/alloc.c:308:5: error: Common realloc mistake: 'block' nulled but not freed upon failure [memleakOnRealloc]
    block = realloc( block, BLOCK_SIZE( size ) );
    ^
src/z80asm/src/c/codearea.c:136:6: style: The scope of the variable 'last_id' can be reduced. [variableScope]
 int last_id;
     ^
src/z80asm/src/c/codearea.c:234:13: style: The scope of the variable 'item' can be reduced. [variableScope]
 int addr, *item;
            ^
src/z80asm/src/c/codearea.c:235:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
src/z80asm/src/c/codearea.c:519:6: style: The scope of the variable 'addr' can be reduced. [variableScope]
 int addr, size;
     ^
src/z80asm/src/c/codearea.c:519:12: style: The scope of the variable 'size' can be reduced. [variableScope]
 int addr, size;
           ^
src/z80asm/src/c/codearea.c:562:6: style: The scope of the variable 'section_size' can be reduced. [variableScope]
 int section_size;
     ^
src/z80asm/src/c/codearea.c:686:12: style: The scope of the variable 'default_section' can be reduced. [variableScope]
 Section1 *default_section;
           ^
src/z80asm/src/c/codearea.c:360:18: style:inconclusive: Function 'set_PC' argument 1 names different: declaration 'n' definition 'addr'. [funcArgNamesDifferent]
void set_PC( int addr )
                 ^
src/z80asm/src/c/codearea.h:130:25: note: Function 'set_PC' argument 1 names different: declaration 'n' definition 'addr'.
extern void set_PC( int n );
                        ^
src/z80asm/src/c/codearea.c:360:18: note: Function 'set_PC' argument 1 names different: declaration 'n' definition 'addr'.
void set_PC( int addr )
                 ^
src/z80asm/src/c/codearea.c:190:10: error: Uninitialized variable: *piter [uninitvar]
 return (*piter == NULL) ? NULL : (Section1 *) (*piter)->value;
         ^
src/z80asm/src/c/codearea.c:187:11: note: Address of variable taken here.
  piter = &iter;  /* user does not need to iterate */
          ^
src/z80asm/src/c/codearea.c:190:10: note: Uninitialized variable: *piter
 return (*piter == NULL) ? NULL : (Section1 *) (*piter)->value;
         ^
src/z80asm/src/c/directives.c:56:11: style: Local variable 'sym' shadows outer variable [shadowVariable]
 Symbol1* sym;
          ^
src/z80asm/src/c/scan.h:33:13: note: Shadowed declaration
extern Sym  sym;   /* last token retrieved */
            ^
src/z80asm/src/c/directives.c:56:11: note: Shadow variable
 Symbol1* sym;
          ^
src/z80asm/src/c/expr1.c:363:1: style:inconclusive: Function 'Expr1List_remove' argument 2 names different: declaration 'iter' definition 'piter'. [funcArgNamesDifferent]
DEF_CLASS_LIST(Expr1);
^
src/z80asm/src/c/expr1.h:137:1: note: Function 'Expr1List_remove' argument 2 names different: declaration 'iter' definition 'piter'.
CLASS_LIST(Expr1);     /* list of expressions */
^
src/z80asm/src/c/expr1.c:363:1: note: Function 'Expr1List_remove' argument 2 names different: declaration 'iter' definition 'piter'.
DEF_CLASS_LIST(Expr1);
^
src/z80asm/src/c/expr1.c:595:45: style:inconclusive: Function 'Expr_parse_ternary_cond' argument 1 names different: declaration 'expr' definition 'self'. [funcArgNamesDifferent]
 static bool Expr_parse_ternary_cond(Expr1* self)
                                            ^
src/z80asm/src/c/expr1.c:402:44: note: Function 'Expr_parse_ternary_cond' argument 1 names different: declaration 'expr' definition 'self'.
static bool Expr_parse_ternary_cond(Expr1* expr);
                                           ^
src/z80asm/src/c/expr1.c:595:45: note: Function 'Expr_parse_ternary_cond' argument 1 names different: declaration 'expr' definition 'self'.
 static bool Expr_parse_ternary_cond(Expr1* self)
                                            ^
src/z80asm/src/c/expr1.c:982:31: style:inconclusive: Function 'Expr_is_addr_diff' argument 1 names different: declaration 'expr' definition 'self'. [funcArgNamesDifferent]
bool Expr_is_addr_diff(Expr1* self) {
                              ^
src/z80asm/src/c/expr1.h:163:31: note: Function 'Expr_is_addr_diff' argument 1 names different: declaration 'expr' definition 'self'.
bool Expr_is_addr_diff(Expr1* expr);
                              ^
src/z80asm/src/c/expr1.c:982:31: note: Function 'Expr_is_addr_diff' argument 1 names different: declaration 'expr' definition 'self'.
bool Expr_is_addr_diff(Expr1* self) {
                              ^
src/z80asm/src/c/expr1.c:561:1: style: Variable 'op' is assigned a value that is never used. [unreadVariable]
DEFINE_PARSER(Expr_parse_multiplication, Expr_parse_power,
^
src/z80asm/src/c/expr1.c:565:2: style: Variable 'op' is assigned a value that is never used. [unreadVariable]
 DEFINE_PARSER(Expr_parse_addition, Expr_parse_multiplication,
 ^
src/z80asm/src/c/expr1.c:569:2: style: Variable 'op' is assigned a value that is never used. [unreadVariable]
 DEFINE_PARSER(Expr_parse_binary_shift, Expr_parse_addition,
 ^
src/z80asm/src/c/expr1.c:573:2: style: Variable 'op' is assigned a value that is never used. [unreadVariable]
 DEFINE_PARSER(Expr_parse_condition, Expr_parse_binary_shift,
 ^
src/z80asm/src/c/expr1.c:579:2: style: Variable 'op' is assigned a value that is never used. [unreadVariable]
 DEFINE_PARSER(Expr_parse_binary_and, Expr_parse_condition,
 ^
src/z80asm/src/c/expr1.c:583:2: style: Variable 'op' is assigned a value that is never used. [unreadVariable]
 DEFINE_PARSER(Expr_parse_binary_or, Expr_parse_binary_and,
 ^
src/z80asm/src/c/expr1.c:587:2: style: Variable 'op' is assigned a value that is never used. [unreadVariable]
 DEFINE_PARSER(Expr_parse_logical_and, Expr_parse_binary_or,
 ^
src/z80asm/src/c/expr1.c:591:2: style: Variable 'op' is assigned a value that is never used. [unreadVariable]
 DEFINE_PARSER(Expr_parse_logical_or, Expr_parse_logical_and,
 ^
src/z80asm/src/c/libfile.c:36:13: style: The scope of the variable 'obj_file_data' can be reduced. [variableScope]
 ByteArray *obj_file_data;
            ^
src/z80asm/src/c/libfile.c:38:14: style: The scope of the variable 'obj_filename' can be reduced. [variableScope]
 const char *obj_filename;
             ^
src/z80asm/src/c/libfile.c:39:10: style: The scope of the variable 'fptr' can be reduced. [variableScope]
 size_t  fptr, obj_size;
         ^
src/z80asm/src/c/libfile.c:39:16: style: The scope of the variable 'obj_size' can be reduced. [variableScope]
 size_t  fptr, obj_size;
               ^
src/z80asm/src/c/modlink.c:283:6: style: The scope of the variable 'base_addr' can be reduced. [variableScope]
 int base_addr, offset;
     ^
src/z80asm/src/c/modlink.c:283:17: style: The scope of the variable 'offset' can be reduced. [variableScope]
 int base_addr, offset;
                ^
src/z80asm/src/c/modlink.c:401:9: style: The scope of the variable 'expr' can be reduced. [variableScope]
 Expr1* expr, * expr2;
        ^
src/z80asm/src/c/modlink.c:405:7: style: The scope of the variable 'computed' can be reduced. [variableScope]
 bool computed;
      ^
src/z80asm/src/c/modlink.c:503:17: style: The scope of the variable 'expr2' can be reduced. [variableScope]
 Expr1* expr, * expr2;
                ^
src/z80asm/src/c/modlink.c:504:7: style: The scope of the variable 'value' can be reduced. [variableScope]
 long value, asmpc;
      ^
src/z80asm/src/c/modlink.c:1136:9: style: The scope of the variable 'expr' can be reduced. [variableScope]
 Expr1* expr;
        ^
src/z80asm/src/c/modlink.c:1138:14: style: The scope of the variable 'old_name' can be reduced. [variableScope]
 const char* old_name;
             ^
src/z80asm/src/c/modlink.c:1252:11: style: The scope of the variable 'sym' can be reduced. [variableScope]
 Symbol1* sym;
          ^
src/z80asm/src/c/modlink.c:416:13: style: Local variable 'sym' shadows outer variable [shadowVariable]
   Symbol1* sym = get_used_symbol(expr->target_name);
            ^
src/z80asm/src/c/scan.h:33:13: note: Shadowed declaration
extern Sym  sym;   /* last token retrieved */
            ^
src/z80asm/src/c/modlink.c:416:13: note: Shadow variable
   Symbol1* sym = get_used_symbol(expr->target_name);
            ^
src/z80asm/src/c/modlink.c:635:11: style: Local variable 'sym' shadows outer variable [shadowVariable]
 Symbol1* sym;
          ^
src/z80asm/src/c/scan.h:33:13: note: Shadowed declaration
extern Sym  sym;   /* last token retrieved */
            ^
src/z80asm/src/c/modlink.c:635:11: note: Shadow variable
 Symbol1* sym;
          ^
src/z80asm/src/c/modlink.c:892:13: style: Local variable 'sym' shadows outer variable [shadowVariable]
   Symbol1* sym = NULL;
            ^
src/z80asm/src/c/scan.h:33:13: note: Shadowed declaration
extern Sym  sym;   /* last token retrieved */
            ^
src/z80asm/src/c/modlink.c:892:13: note: Shadow variable
   Symbol1* sym = NULL;
            ^
src/z80asm/src/c/modlink.c:976:19: style: Local variable 'obj' shadows outer variable [shadowVariable]
 for (obj_file_t* obj = g_objects; !get_num_errors() && obj != NULL; obj = obj->next) {
                  ^
src/z80asm/src/c/modlink.c:964:14: note: Shadowed declaration
 obj_file_t* obj = g_objects;
             ^
src/z80asm/src/c/modlink.c:976:19: note: Shadow variable
 for (obj_file_t* obj = g_objects; !get_num_errors() && obj != NULL; obj = obj->next) {
                  ^
src/z80asm/src/c/modlink.c:1132:11: style: Local variable 'sym' shadows outer variable [shadowVariable]
 Symbol1* sym;
          ^
src/z80asm/src/c/scan.h:33:13: note: Shadowed declaration
extern Sym  sym;   /* last token retrieved */
            ^
src/z80asm/src/c/modlink.c:1132:11: note: Shadow variable
 Symbol1* sym;
          ^
src/z80asm/src/c/modlink.c:1183:11: style: Local variable 'sym' shadows outer variable [shadowVariable]
 Symbol1* sym;
          ^
src/z80asm/src/c/scan.h:33:13: note: Shadowed declaration
extern Sym  sym;   /* last token retrieved */
            ^
src/z80asm/src/c/modlink.c:1183:11: note: Shadow variable
 Symbol1* sym;
          ^
src/z80asm/src/c/modlink.c:1252:11: style: Local variable 'sym' shadows outer variable [shadowVariable]
 Symbol1* sym;
          ^
src/z80asm/src/c/scan.h:33:13: note: Shadowed declaration
extern Sym  sym;   /* last token retrieved */
            ^
src/z80asm/src/c/modlink.c:1252:11: note: Shadow variable
 Symbol1* sym;
          ^
src/z80asm/src/c/module1.c:40:1: style:inconclusive: Function 'Module1List_remove' argument 2 names different: declaration 'iter' definition 'piter'. [funcArgNamesDifferent]
DEF_CLASS_LIST( Module1 );
^
src/z80asm/src/c/module1.h:37:1: note: Function 'Module1List_remove' argument 2 names different: declaration 'iter' definition 'piter'.
CLASS_LIST( Module1 );
^
src/z80asm/src/c/module1.c:40:1: note: Function 'Module1List_remove' argument 2 names different: declaration 'iter' definition 'piter'.
DEF_CLASS_LIST( Module1 );
^
src/z80asm/src/c/module1.c:120:9: error: Uninitialized variable: *piter [uninitvar]
 return *piter == NULL ? NULL : (Module1 *) (*piter)->obj;
        ^
src/z80asm/src/c/module1.c:117:11: note: Address of variable taken here.
  piter = &iter;  /* user does not need to iterate */
          ^
src/z80asm/src/c/module1.c:120:9: note: Uninitialized variable: *piter
 return *piter == NULL ? NULL : (Module1 *) (*piter)->obj;
        ^
src/z80asm/src/c/module1.c:132:9: error: Uninitialized variable: *piter [uninitvar]
 return *piter == NULL ? NULL : (Module1 *) (*piter)->obj;
        ^
src/z80asm/src/c/module1.c:129:11: note: Address of variable taken here.
  piter = &iter;  /* user does not need to iterate */
          ^
src/z80asm/src/c/module1.c:132:9: note: Uninitialized variable: *piter
 return *piter == NULL ? NULL : (Module1 *) (*piter)->obj;
        ^
src/z80asm/src/c/opcodes.c:39:7: style: Variable 'out' is assigned a value that is never used. [unreadVariable]
  out = true;
      ^
src/z80asm/src/c/parse.c:68:6: style: The scope of the variable 'num_errors' can be reduced. [variableScope]
 int num_errors;
     ^
src/z80asm/src/c/parse_rules.h:46449:20: style: Variable 'expr_open_parens' is assigned a value that is never used. [unreadVariable]
  expr_open_parens = 0;
                   ^
src/z80asm/src/c/parse_rules.h:46453:19: style: Variable 'expr_in_parens' is assigned a value that is never used. [unreadVariable]
 { expr_in_parens = check_expr_in_parens(ctx->expr_start, ctx->p);
                  ^
src/z80asm/src/c/parse_rules.h:46662:18: style: Variable 'value1' is assigned a value that is never used. [unreadVariable]
          value1 = expr_error ? 0 : expr_value;
                 ^
src/z80asm/src/c/parse_rules.h:46676:18: style: Variable 'value1' is assigned a value that is never used. [unreadVariable]
          value1 = expr_error ? 0 : expr_value;
                 ^
src/z80asm/src/c/parse_rules.h:47155:15: style: Variable 'value1' is assigned a value that is never used. [unreadVariable]
       value1 = expr_error ? 0 : expr_value;
              ^
src/z80asm/src/c/scan.c:187:7: style: The scope of the variable 'c' can be reduced. [variableScope]
 char c;
      ^
src/z80asm/src/c/scan.c:310:10: style: Local variable 'line' shadows outer variable [shadowVariable]
   char* line = sfile_get_source_line();
         ^
src/z80asm/src/c/scan.c:301:9: note: Shadowed declaration
  char* line = List_pop( input_stack );
        ^
src/z80asm/src/c/scan.c:310:10: note: Shadow variable
   char* line = sfile_get_source_line();
         ^
src/z80asm/src/c/str.c:28:2: warning: Either the condition 'str' is redundant or there is possible null pointer dereference: str. [nullPointerRedundantCheck]
 str->data = NULL;
 ^
src/z80asm/src/c/str.c:26:6: note: Assuming that condition 'str' is not redundant
 if (str && str->flag.data_alloc)
     ^
src/z80asm/src/c/str.c:28:2: note: Null pointer dereference
 str->data = NULL;
 ^
src/z80asm/src/c/str.c:29:2: warning: Either the condition 'str' is redundant or there is possible null pointer dereference: str. [nullPointerRedundantCheck]
 str->flag.data_alloc = false;
 ^
src/z80asm/src/c/str.c:26:6: note: Assuming that condition 'str' is not redundant
 if (str && str->flag.data_alloc)
     ^
src/z80asm/src/c/str.c:29:2: note: Null pointer dereference
 str->flag.data_alloc = false;
 ^
src/z80asm/src/c/str.c:179:6: style: The scope of the variable 'free_space' can be reduced. [variableScope]
 int free_space;      /* may be negative */
     ^
src/z80asm/src/c/str.c:241:10: style: The scope of the variable 'c2' can be reduced. [variableScope]
 int c1, c2;
         ^
src/z80asm/src/c/str.c:184:2: error: va_list 'savearg' used before va_start() was called. [va_list_usedBeforeStarted]
 va_copy(savearg, argptr);
 ^
src/z80asm/src/c/str.c:207:4: error: va_list 'savearg' used before va_start() was called. [va_list_usedBeforeStarted]
   va_copy(argptr, savearg);
   ^
src/z80asm/src/c/strhash.c:156:5: warning: Either the condition 'elem==NULL' is redundant or there is possible null pointer dereference: elem. [nullPointerRedundantCheck]
    elem->value      = value;
    ^
src/z80asm/src/c/strhash.c:136:15: note: Assuming that condition 'elem==NULL' is not redundant
    if ( elem == NULL )
              ^
src/z80asm/src/c/strhash.c:156:5: note: Null pointer dereference
    elem->value      = value;
    ^
src/z80asm/src/c/strhash.c:129:12: style: The scope of the variable 'num_chars' can be reduced. [variableScope]
    size_t num_chars;
           ^
src/z80asm/src/c/symtab1.c:50:22: style: The scope of the variable 'sym' can be reduced. [variableScope]
    Symbol1         *sym;
                     ^
src/z80asm/src/c/symtab1.c:217:22: style: The scope of the variable 'sym' can be reduced. [variableScope]
    Symbol1         *sym;
                     ^
src/z80asm/src/c/symtab1.c:265:22: style: The scope of the variable 'sym' can be reduced. [variableScope]
    Symbol1         *sym;
                     ^
src/z80asm/src/c/symtab1.c:392:21: style: The scope of the variable 'global_sym' can be reduced. [variableScope]
 Symbol1     *sym, *global_sym;
                    ^
src/z80asm/src/c/symtab1.c:451:21: style: The scope of the variable 'global_sym' can be reduced. [variableScope]
 Symbol1     *sym, *global_sym;
                    ^
src/z80asm/src/c/symtab1.c:515:21: style: The scope of the variable 'ext_sym' can be reduced. [variableScope]
 Symbol1     *sym, *ext_sym;
                    ^
src/z80asm/src/c/symtab1.c:585:19: style: The scope of the variable 'sym' can be reduced. [variableScope]
 Symbol1         *sym;
                  ^
src/z80asm/src/c/symtab1.c:681:19: style: The scope of the variable 'sym' can be reduced. [variableScope]
 Symbol1         *sym;
                  ^
src/z80asm/src/c/symtab1.c:50:22: style: Local variable 'sym' shadows outer variable [shadowVariable]
    Symbol1         *sym;
                     ^
src/z80asm/src/c/scan.h:33:13: note: Shadowed declaration
extern Sym  sym;   /* last token retrieved */
            ^
src/z80asm/src/c/symtab1.c:50:22: note: Shadow variable
    Symbol1         *sym;
                     ^
src/z80asm/src/c/symtab1.c:64:11: style: Local variable 'sym' shadows outer variable [shadowVariable]
 Symbol1* sym = Symbol1Hash_get(symtab, name);
          ^
src/z80asm/src/c/scan.h:33:13: note: Shadowed declaration
extern Sym  sym;   /* last token retrieved */
            ^
src/z80asm/src/c/symtab1.c:64:11: note: Shadow variable
 Symbol1* sym = Symbol1Hash_get(symtab, name);
          ^
src/z80asm/src/c/symtab1.c:87:14: style: Local variable 'sym' shadows outer variable [shadowVariable]
    Symbol1 *sym;
             ^
src/z80asm/src/c/scan.h:33:13: note: Shadowed declaration
extern Sym  sym;   /* last token retrieved */
            ^
src/z80asm/src/c/symtab1.c:87:14: note: Shadow variable
    Symbol1 *sym;
             ^
src/z80asm/src/c/symtab1.c:132:18: style: Local variable 'sym' shadows outer variable [shadowVariable]
    Symbol1     *sym;
                 ^
src/z80asm/src/c/scan.h:33:13: note: Shadowed declaration
extern Sym  sym;   /* last token retrieved */
            ^
src/z80asm/src/c/symtab1.c:132:18: note: Shadow variable
    Symbol1     *sym;
                 ^
src/z80asm/src/c/symtab1.c:157:14: style: Local variable 'sym' shadows outer variable [shadowVariable]
    Symbol1 *sym = _define_sym( name, value, TYPE_CONSTANT, SCOPE_LOCAL,
             ^
src/z80asm/src/c/scan.h:33:13: note: Shadowed declaration
extern Sym  sym;   /* last token retrieved */
            ^
src/z80asm/src/c/symtab1.c:157:14: note: Shadow variable
    Symbol1 *sym = _define_sym( name, value, TYPE_CONSTANT, SCOPE_LOCAL,
             ^
src/z80asm/src/c/symtab1.c:176:11: style: Local variable 'sym' shadows outer variable [shadowVariable]
 Symbol1* sym = _define_sym(name, value, TYPE_CONSTANT, SCOPE_PUBLIC,
          ^
src/z80asm/src/c/scan.h:33:13: note: Shadowed declaration
extern Sym  sym;   /* last token retrieved */
            ^
src/z80asm/src/c/symtab1.c:176:11: note: Shadow variable
 Symbol1* sym = _define_sym(name, value, TYPE_CONSTANT, SCOPE_PUBLIC,
          ^
src/z80asm/src/c/symtab1.c:217:22: style: Local variable 'sym' shadows outer variable [shadowVariable]
    Symbol1         *sym;
                     ^
src/z80asm/src/c/scan.h:33:13: note: Shadowed declaration
extern Sym  sym;   /* last token retrieved */
            ^
src/z80asm/src/c/symtab1.c:217:22: note: Shadow variable
    Symbol1         *sym;
                     ^
src/z80asm/src/c/symtab1.c:265:22: style: Local variable 'sym' shadows outer variable [shadowVariable]
    Symbol1         *sym;
                     ^
src/z80asm/src/c/scan.h:33:13: note: Shadowed declaration
extern Sym  sym;   /* last token retrieved */
            ^
src/z80asm/src/c/symtab1.c:265:22: note: Shadow variable
    Symbol1         *sym;
                     ^
src/z80asm/src/c/symtab1.c:300:11: style: Local variable 'sym' shadows outer variable [shadowVariable]
 Symbol1* sym;
          ^
src/z80asm/src/c/scan.h:33:13: note: Shadowed declaration
extern Sym  sym;   /* last token retrieved */
            ^
src/z80asm/src/c/symtab1.c:300:11: note: Shadow variable
 Symbol1* sym;
          ^
src/z80asm/src/c/symtab1.c:337:11: style: Local variable 'sym' shadows outer variable [shadowVariable]
 Symbol1* sym;
          ^
src/z80asm/src/c/scan.h:33:13: note: Shadowed declaration
extern Sym  sym;   /* last token retrieved */
            ^
src/z80asm/src/c/symtab1.c:337:11: note: Shadow variable
 Symbol1* sym;
          ^
src/z80asm/src/c/symtab1.c:370:14: style: Local variable 'sym' shadows outer variable [shadowVariable]
    Symbol1 *sym;
             ^
src/z80asm/src/c/scan.h:33:13: note: Shadowed declaration
extern Sym  sym;   /* last token retrieved */
            ^
src/z80asm/src/c/symtab1.c:370:14: note: Shadow variable
    Symbol1 *sym;
             ^
src/z80asm/src/c/symtab1.c:392:15: style: Local variable 'sym' shadows outer variable [shadowVariable]
 Symbol1     *sym, *global_sym;
              ^
src/z80asm/src/c/scan.h:33:13: note: Shadowed declaration
extern Sym  sym;   /* last token retrieved */
            ^
src/z80asm/src/c/symtab1.c:392:15: note: Shadow variable
 Symbol1     *sym, *global_sym;
              ^
src/z80asm/src/c/symtab1.c:451:15: style: Local variable 'sym' shadows outer variable [shadowVariable]
 Symbol1     *sym, *global_sym;
              ^
src/z80asm/src/c/scan.h:33:13: note: Shadowed declaration
extern Sym  sym;   /* last token retrieved */
            ^
src/z80asm/src/c/symtab1.c:451:15: note: Shadow variable
 Symbol1     *sym, *global_sym;
              ^
src/z80asm/src/c/symtab1.c:515:15: style: Local variable 'sym' shadows outer variable [shadowVariable]
 Symbol1     *sym, *ext_sym;
              ^
src/z80asm/src/c/scan.h:33:13: note: Shadowed declaration
extern Sym  sym;   /* last token retrieved */
            ^
src/z80asm/src/c/symtab1.c:515:15: note: Shadow variable
 Symbol1     *sym, *ext_sym;
              ^
src/z80asm/src/c/symtab1.c:585:19: style: Local variable 'sym' shadows outer variable [shadowVariable]
 Symbol1         *sym;
                  ^
src/z80asm/src/c/scan.h:33:13: note: Shadowed declaration
extern Sym  sym;   /* last token retrieved */
            ^
src/z80asm/src/c/symtab1.c:585:19: note: Shadow variable
 Symbol1         *sym;
                  ^
src/z80asm/src/c/symtab1.c:681:19: style: Local variable 'sym' shadows outer variable [shadowVariable]
 Symbol1         *sym;
                  ^
src/z80asm/src/c/scan.h:33:13: note: Shadowed declaration
extern Sym  sym;   /* last token retrieved */
            ^
src/z80asm/src/c/symtab1.c:681:19: note: Shadow variable
 Symbol1         *sym;
                  ^
src/z80asm/src/c/z80pass.c:26:9: style: The scope of the variable 'expr' can be reduced. [variableScope]
 Expr1* expr, * expr2;
        ^
src/z80asm/src/c/z80pass.c:27:7: style: The scope of the variable 'value' can be reduced. [variableScope]
 long value;
      ^
src/z80asm/src/c/z80pass.c:28:7: style: The scope of the variable 'do_patch' can be reduced. [variableScope]
 bool do_patch;
      ^
src/z80asm/src/c/zobjfile.c:40:7: style: The scope of the variable 'range' can be reduced. [variableScope]
 char range;
      ^
src/z80asm/src/c/zobjfile.c:109:11: style: The scope of the variable 'sym' can be reduced. [variableScope]
 Symbol1* sym;
          ^
src/z80asm/src/c/zobjfile.c:111:7: style: The scope of the variable 'scope' can be reduced. [variableScope]
 char scope, type;
      ^
src/z80asm/src/c/zobjfile.c:173:11: style: The scope of the variable 'sym' can be reduced. [variableScope]
 Symbol1* sym;
          ^
src/z80asm/src/c/zobjfile.c:467:6: style: The scope of the variable 'code_size' can be reduced. [variableScope]
 int code_size;
     ^
src/z80asm/src/c/zobjfile.c:469:12: style: The scope of the variable 'section' can be reduced. [variableScope]
 Section1* section;
           ^
src/z80asm/src/c/zobjfile.c:222:33: style:inconclusive: Function 'write_obj_file' argument 1 names different: declaration 'src_filename' definition 'source_filename'. [funcArgNamesDifferent]
void write_obj_file(const char* source_filename)
                                ^
src/z80asm/src/c/zobjfile.h:27:40: note: Function 'write_obj_file' argument 1 names different: declaration 'src_filename' definition 'source_filename'.
extern void write_obj_file(const char* src_filename);
                                       ^
src/z80asm/src/c/zobjfile.c:222:33: note: Function 'write_obj_file' argument 1 names different: declaration 'src_filename' definition 'source_filename'.
void write_obj_file(const char* source_filename)
                                ^
src/z80asm/src/c/zobjfile.c:109:11: style: Local variable 'sym' shadows outer variable [shadowVariable]
 Symbol1* sym;
          ^
src/z80asm/src/c/scan.h:33:13: note: Shadowed declaration
extern Sym  sym;   /* last token retrieved */
            ^
src/z80asm/src/c/zobjfile.c:109:11: note: Shadow variable
 Symbol1* sym;
          ^
src/z80asm/src/c/zobjfile.c:173:11: style: Local variable 'sym' shadows outer variable [shadowVariable]
 Symbol1* sym;
          ^
src/z80asm/src/c/scan.h:33:13: note: Shadowed declaration
extern Sym  sym;   /* last token retrieved */
            ^
src/z80asm/src/c/zobjfile.c:173:11: note: Shadow variable
 Symbol1* sym;
          ^
src/z80asm/src/cpp/args.def:61:1: error: There is an unknown macro here somewhere. Configuration is required. If TOSTR is a macro then please configure it. [unknownMacro]
OPT("+zx", nullptr, \
^
src/z80asm/src/cpp/defines.h:18:2: style: Class 'Macro' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
 Macro(const string& name, const string& body = "");
 ^
src/z80asm/src/cpp/lex.h:64:7: style:inconclusive: Technically the member function 'Token::is' can be const. [functionConst]
 bool is(TType ttype) { return this->ttype == ttype; }
      ^
src/z80asm/src/cpp/lex.h:65:7: style:inconclusive: Technically the member function 'Token::is' can be const. [functionConst]
 bool is(Keyword keyword) { return this->keyword == keyword; }
      ^
src/z80asm/src/cpp/float.h:18:2: style: Class 'FloatExpr' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
 FloatExpr(Lexer& lexer);
 ^
src/z80asm/src/cpp/errors.cpp:23:34: style:inconclusive: Function 'Location' argument 1 names different: declaration 'filename' definition 'filename_'. [funcArgNamesDifferent]
Location::Location(const string& filename_, int line_num_,
                                 ^
src/z80asm/src/cpp/errors.h:25:25: note: Function 'Location' argument 1 names different: declaration 'filename' definition 'filename_'.
 Location(const string& filename = "", int line_num = 0,
                        ^
src/z80asm/src/cpp/errors.cpp:23:34: note: Function 'Location' argument 1 names different: declaration 'filename' definition 'filename_'.
Location::Location(const string& filename_, int line_num_,
                                 ^
src/z80asm/src/cpp/errors.cpp:23:49: style:inconclusive: Function 'Location' argument 2 names different: declaration 'line_num' definition 'line_num_'. [funcArgNamesDifferent]
Location::Location(const string& filename_, int line_num_,
                                                ^
src/z80asm/src/cpp/errors.h:25:44: note: Function 'Location' argument 2 names different: declaration 'line_num' definition 'line_num_'.
 Location(const string& filename = "", int line_num = 0,
                                           ^
src/z80asm/src/cpp/errors.cpp:23:49: note: Function 'Location' argument 2 names different: declaration 'line_num' definition 'line_num_'.
Location::Location(const string& filename_, int line_num_,
                                                ^
src/z80asm/src/cpp/errors.cpp:24:16: style:inconclusive: Function 'Location' argument 3 names different: declaration 'source_line' definition 'source_line_'. [funcArgNamesDifferent]
 const string& source_line_, const string& expanded_line_)
               ^
src/z80asm/src/cpp/errors.h:26:17: note: Function 'Location' argument 3 names different: declaration 'source_line' definition 'source_line_'.
  const string& source_line = "", const string& expanded_line = "");
                ^
src/z80asm/src/cpp/errors.cpp:24:16: note: Function 'Location' argument 3 names different: declaration 'source_line' definition 'source_line_'.
 const string& source_line_, const string& expanded_line_)
               ^
src/z80asm/src/cpp/errors.cpp:24:44: style:inconclusive: Function 'Location' argument 4 names different: declaration 'expanded_line' definition 'expanded_line_'. [funcArgNamesDifferent]
 const string& source_line_, const string& expanded_line_)
                                           ^
src/z80asm/src/cpp/errors.h:26:49: note: Function 'Location' argument 4 names different: declaration 'expanded_line' definition 'expanded_line_'.
  const string& source_line = "", const string& expanded_line = "");
                                                ^
src/z80asm/src/cpp/errors.cpp:24:44: note: Function 'Location' argument 4 names different: declaration 'expanded_line' definition 'expanded_line_'.
 const string& source_line_, const string& expanded_line_)
                                           ^
src/z80asm/src/cpp/float.cpp:42:9: style: Condition '*c==0x76' is always false [knownConditionTrueFalse]
 if (*c == 0x76)
        ^
src/z80asm/src/cpp/float.cpp:40:15: note: Assignment 'x=0x76543210', assigned value is 1985229328
 unsigned x = 0x76543210;
              ^
src/z80asm/src/cpp/float.cpp:42:9: note: Condition '*c==0x76' is always false
 if (*c == 0x76)
        ^
src/z80asm/src/cpp/float.cpp:44:14: style: Condition '*c==0x10' is always false [knownConditionTrueFalse]
 else if (*c == 0x10)
             ^
src/z80asm/src/cpp/float.cpp:40:15: note: Assignment 'x=0x76543210', assigned value is 1985229328
 unsigned x = 0x76543210;
              ^
src/z80asm/src/cpp/float.cpp:44:14: note: Condition '*c==0x10' is always false
 else if (*c == 0x10)
             ^
src/z80asm/src/cpp/float.cpp:618:6: style: Condition '!out.empty()' is always true [knownConditionTrueFalse]
 if (!out.empty()) out.pop_back(); // remove end comma
     ^
src/z80asm/src/cpp/float.cpp:110:10: style: Local variable 'res' shadows outer variable [shadowVariable]
     int res = fs->mantissa[i] + carry;
         ^
src/z80asm/src/cpp/float.cpp:101:10: note: Shadowed declaration
  double res = floor(mult);
         ^
src/z80asm/src/cpp/float.cpp:110:10: note: Shadow variable
     int res = fs->mantissa[i] + carry;
         ^
src/z80asm/src/cpp/args.h:46:24: style:inconclusive: Technically the member function 'Args::include_path' can be const. [functionConst]
 const vector<string>& include_path() { return m_include_path; }
                       ^
src/z80asm/src/cpp/args.h:47:24: style:inconclusive: Technically the member function 'Args::files' can be const. [functionConst]
 const vector<string>& files() { return m_files; }
                       ^
src/z80asm/src/cpp/lex.cpp:2866:27: style: Local variable 'p' shadows outer variable [shadowVariable]
         for (const char* p = p0+2; p < p1; p++) {
                          ^
src/z80asm/src/cpp/lex.cpp:1584:14: note: Shadowed declaration
 const char* p = text.c_str(), * YYMARKER{ nullptr };
             ^
src/z80asm/src/cpp/lex.cpp:2866:27: note: Shadow variable
         for (const char* p = p0+2; p < p1; p++) {
                          ^
src/z80asm/src/cpp/lex.cpp:77:4: style: Variable 'p' is assigned a value that is never used. [unreadVariable]
   ++p;
   ^
src/z80asm/src/cpp/lex.cpp:91:4: style: Variable 'p' is assigned a value that is never used. [unreadVariable]
   ++p;
   ^
src/z80asm/src/cpp/lex.cpp:182:4: style: Variable 'p' is assigned a value that is never used. [unreadVariable]
   ++p;
   ^
src/z80asm/src/cpp/lex.cpp:207:4: style: Variable 'p' is assigned a value that is never used. [unreadVariable]
   ++p;
   ^
src/z80asm/src/cpp/lex.cpp:425:4: style: Variable 'p' is assigned a value that is never used. [unreadVariable]
   ++p;
   ^
src/z80asm/src/cpp/lex.cpp:535:4: style: Variable 'p' is assigned a value that is never used. [unreadVariable]
   ++p;
   ^
src/z80asm/src/cpp/lex.cpp:1199:4: style: Variable 'p' is assigned a value that is never used. [unreadVariable]
   ++p;
   ^
src/z80asm/src/cpp/lex.cpp:1484:4: style: Variable 'p' is assigned a value that is never used. [unreadVariable]
   ++p;
   ^
src/z80asm/src/cpp/lex.cpp:1514:4: style: Variable 'p' is assigned a value that is never used. [unreadVariable]
   ++p;
   ^
src/z80asm/src/cpp/lex.cpp:1697:4: style: Variable 'p' is assigned a value that is never used. [unreadVariable]
   ++p;
   ^
src/z80asm/src/cpp/lex.cpp:1700:4: style: Variable 'p' is assigned a value that is never used. [unreadVariable]
   ++p;
   ^
src/z80asm/src/cpp/lstfile.h:20:1: style: The class 'LstFile' does not have a constructor although it has private member variables. [noConstructor]
class LstFile {
^
src/z80asm/src/cpp/lstfile.h:47:6: style:inconclusive: Technically the member function 'LstFile::num_rows' can be const. [functionConst]
 int num_rows();
     ^
src/z80asm/src/cpp/lstfile.cpp:188:14: note: Technically the member function 'LstFile::num_rows' can be const.
int LstFile::num_rows() {
             ^
src/z80asm/src/cpp/lstfile.h:47:6: note: Technically the member function 'LstFile::num_rows' can be const.
 int num_rows();
     ^
src/z80asm/src/cpp/lstfile.cpp:56:36: performance: Function parameter 'location' should be passed by const reference. [passedByValue]
void LstFile::source_line(Location location, int asmpc, int phased_pc, const string& text) {
                                   ^
src/z80asm/src/cpp/preproc.h:150:9: performance:inconclusive: Technically the member function 'Preproc::collect_param' can be static (but you may consider moving to unnamed namespace). [functionStatic]
 string collect_param(Lexer& lexer);
        ^
src/z80asm/src/cpp/preproc.cpp:1185:17: note: Technically the member function 'Preproc::collect_param' can be static (but you may consider moving to unnamed namespace).
string Preproc::collect_param(Lexer& lexer) {
                ^
src/z80asm/src/cpp/preproc.h:150:9: note: Technically the member function 'Preproc::collect_param' can be static (but you may consider moving to unnamed namespace).
 string collect_param(Lexer& lexer);
        ^
src/z80asm/src/cpp/preproc.h:152:17: performance:inconclusive: Technically the member function 'Preproc::collect_name_list' can be static (but you may consider moving to unnamed namespace). [functionStatic]
 vector<string> collect_name_list(Lexer& lexer);
                ^
src/z80asm/src/cpp/preproc.cpp:1243:25: note: Technically the member function 'Preproc::collect_name_list' can be static (but you may consider moving to unnamed namespace).
vector<string> Preproc::collect_name_list(Lexer& lexer) {
                        ^
src/z80asm/src/cpp/preproc.h:152:17: note: Technically the member function 'Preproc::collect_name_list' can be static (but you may consider moving to unnamed namespace).
 vector<string> collect_name_list(Lexer& lexer);
                ^
src/z80asm/src/cpp/preproc.cpp:166:34: style:inconclusive: Function 'open' argument 1 names different: declaration 'filename' definition 'filename_'. [funcArgNamesDifferent]
bool Preproc::open(const string& filename_, bool search_include_path) {
                                 ^
src/z80asm/src/cpp/preproc.h:83:26: note: Function 'open' argument 1 names different: declaration 'filename' definition 'filename_'.
 bool open(const string& filename, bool search_include_path);
                         ^
src/z80asm/src/cpp/preproc.cpp:166:34: note: Function 'open' argument 1 names different: declaration 'filename' definition 'filename_'.
bool Preproc::open(const string& filename_, bool search_include_path) {
                                 ^
src/z80asm/src/cpp/preproc.cpp:157:42: performance: Function parameter 'location' should be passed by const reference. [passedByValue]
IfNest::IfNest(Keyword keyword, Location location, bool flag)
                                         ^
src/z80asm/src/cpp/preproc.cpp:290:0: style: Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]
  if (elem.filename == filename)
^
src/z80asm/src/cpp/preproc.cpp:361:0: style: Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]
  if (!f.flag)
^
src/z80asm/src/cpp/preproc.cpp:942:13: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
      param = expand(param);
            ^
src/z80asm/src/cpp/preproc.cpp:1301:9: style: Unused variable: out [unusedVariable]
 string out;
        ^
src/z80asm/src/cpp/utils.cpp:119:32: style:inconclusive: Function 'str_chomp' argument 1 names different: declaration 'str' definition 'str_'. [funcArgNamesDifferent]
string str_chomp(const string& str_) {
                               ^
src/z80asm/src/cpp/utils.h:45:32: note: Function 'str_chomp' argument 1 names different: declaration 'str' definition 'str_'.
string str_chomp(const string& str);    // remove end blanks
                               ^
src/z80asm/src/cpp/utils.cpp:119:32: note: Function 'str_chomp' argument 1 names different: declaration 'str' definition 'str_'.
string str_chomp(const string& str_) {
                               ^
src/z80asm/src/cpp/utils.cpp:225:14: style: Local variable 'new_path' shadows outer variable [shadowVariable]
    fs::path new_path{ entry };
             ^
src/z80asm/src/cpp/utils.cpp:218:12: note: Shadowed declaration
  fs::path new_path{ prefix };
           ^
src/z80asm/src/cpp/utils.cpp:225:14: note: Shadow variable
    fs::path new_path{ entry };
             ^
src/z80asm/src/cpp/utils.cpp:263:9: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
  elems.push_back(elem.generic_string());
        ^
src/z80asm/src/cpp/utils.cpp:287:10: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
  result.push_back(file.generic_string());
         ^
src/z80asm/src/cpp/utils.cpp:33:11: style: Variable 'base' is assigned a value that is never used. [unreadVariable]
 int base = 0, max_digits = 0, digit = 0;
          ^
src/z88dk-lib/z88dk-lib.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 37 configurations. Use --force to check all configurations. [toomanyconfigs]

^
src/z88dk-lib/z88dk-lib.c:103:10: style: The scope of the variable 'tmplen' can be reduced. [variableScope]
    int  tmplen;
         ^
src/z88dk-lib/z88dk-lib.c:248:10: style: The scope of the variable 'yes' can be reduced. [variableScope]
    char yes;
         ^
src/zcc/zcc.c:810:13: style: Condition 'linker_output_separate_arg' is always false [knownConditionTrueFalse]
            linker_output_separate_arg ? " " : "",
            ^
src/zcc/zcc.c:1944:17: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
                fprintf(stderr, "Ignoring %s line %u: %s", globaldefrefile, lineno, buffer);
                ^
src/zcc/zcc.c:1000:9: error: Common realloc mistake: 'aliases' nulled but not freed upon failure [memleakOnRealloc]
        aliases = realloc(aliases, (aliases_num + 2) * sizeof(aliases[0]));
        ^
src/zcc/zcc.c:1930:18: error: Common realloc mistake: 'filter' nulled but not freed upon failure [memleakOnRealloc]
            if ((filter = realloc(filter, (nfilter + 1) * sizeof(*filter))) == NULL)
                 ^
src/zcc/zcc.c:2240:5: error: Common realloc mistake: 'arr' nulled but not freed upon failure [memleakOnRealloc]
    arr = realloc(arr, *argument->num_ptr * sizeof(char *));
    ^
src/zcc/zcc.c:2533:18: error: Common realloc mistake: 'original_filenames' nulled but not freed upon failure [memleakOnRealloc]
            if ((original_filenames = realloc(original_filenames, (nfiles + 1) * sizeof(char *))) == NULL) {
                 ^
src/zcc/zcc.c:2537:18: error: Common realloc mistake: 'filelist' nulled but not freed upon failure [memleakOnRealloc]
            if ((filelist = realloc(filelist, (nfiles + 1) * sizeof(char *))) == NULL) {
                 ^
src/zcc/zcc.c:2541:18: error: Common realloc mistake: 'temporary_filenames' nulled but not freed upon failure [memleakOnRealloc]
            if ((temporary_filenames = realloc(temporary_filenames, (nfiles + 1) * sizeof(char *))) == NULL) {
                 ^
src/zcc/zcc.c:2939:9: error: Common realloc mistake: 'aliases' nulled but not freed upon failure [memleakOnRealloc]
        aliases = realloc(aliases, (aliases_num + 2) * sizeof(aliases[0]));
        ^
src/zcc/zcc.c:3248:5: error: Common realloc mistake: 'zccopt' nulled but not freed upon failure [memleakOnRealloc]
    zccopt = realloc(zccopt, len + extra + 1);
    ^
src/zcc/zcc.c:1898:22: style: The scope of the variable 'rules' can be reduced. [variableScope]
    FILE *in, *out, *rules;
                     ^
src/zcc/zcc.c:1900:18: style: The scope of the variable 'ptr' can be reduced. [variableScope]
    char *line, *ptr;
                 ^
src/zcc/zcc.c:1903:18: style: The scope of the variable 'errcode' can be reduced. [variableScope]
    int nfilter, errcode, lineno;
                 ^
src/zcc/zcc.c:2112:10: style: The scope of the variable 'i' can be reduced. [variableScope]
    int  i;
         ^
src/zcc/zcc.c:2471:11: style: The scope of the variable 'fclaim' can be reduced. [variableScope]
    FILE *fclaim;
          ^
src/zcc/zcc.c:2472:10: style: The scope of the variable 'tname' can be reduced. [variableScope]
    char tname[FILENAME_MAX + 1];
         ^
src/zcc/zcc.c:3027:21: style: The scope of the variable 'ptr' can be reduced. [variableScope]
    char           *ptr, *p, *name;
                    ^
src/zcc/zcc.c:3090:21: style: The scope of the variable 'j' can be reduced. [variableScope]
    int             j;
                    ^
src/zcc/zcc.c:3187:21: style: The scope of the variable 'fp' can be reduced. [variableScope]
    FILE           *fp;
                    ^
src/zcc/zcc.c:3222:21: style: The scope of the variable 'ptr' can be reduced. [variableScope]
    char           *ptr;
                    ^
src/zcc/zcc.c:3258:12: style: The scope of the variable 'count' can be reduced. [variableScope]
    size_t count, retlen, newlen = strlen(new);
           ^
src/zcc/zcc.c:640:28: style:inconclusive: Function 'hassuffix' argument 1 names different: declaration 'file' definition 'name'. [funcArgNamesDifferent]
static int hassuffix(char *name, char *suffix)
                           ^
src/zcc/zcc.c:161:40: note: Function 'hassuffix' argument 1 names different: declaration 'file' definition 'name'.
static int             hassuffix(char *file, char *suffix_to_check);
                                       ^
src/zcc/zcc.c:640:28: note: Function 'hassuffix' argument 1 names different: declaration 'file' definition 'name'.
static int hassuffix(char *name, char *suffix)
                           ^
src/zcc/zcc.c:640:40: style:inconclusive: Function 'hassuffix' argument 2 names different: declaration 'suffix_to_check' definition 'suffix'. [funcArgNamesDifferent]
static int hassuffix(char *name, char *suffix)
                                       ^
src/zcc/zcc.c:161:52: note: Function 'hassuffix' argument 2 names different: declaration 'suffix_to_check' definition 'suffix'.
static int             hassuffix(char *file, char *suffix_to_check);
                                                   ^
src/zcc/zcc.c:640:40: note: Function 'hassuffix' argument 2 names different: declaration 'suffix_to_check' definition 'suffix'.
static int hassuffix(char *name, char *suffix)
                                       ^
src/zcc/zcc.c:2023:28: style:inconclusive: Function 'copyprepend_file' argument 1 names different: declaration 'src' definition 'name1'. [funcArgNamesDifferent]
int copyprepend_file(char *name1, char *ext1, char *name2, char *ext2, char *prepend)
                           ^
src/zcc/zcc.c:189:47: note: Function 'copyprepend_file' argument 1 names different: declaration 'src' definition 'name1'.
static int             copyprepend_file(char *src, char *src_extension, char *dest, char *dest_extension, char *prepend);
                                              ^
src/zcc/zcc.c:2023:28: note: Function 'copyprepend_file' argument 1 names different: declaration 'src' definition 'name1'.
int copyprepend_file(char *name1, char *ext1, char *name2, char *ext2, char *prepend)
                           ^
src/zcc/zcc.c:2023:41: style:inconclusive: Function 'copyprepend_file' argument 2 names different: declaration 'src_extension' definition 'ext1'. [funcArgNamesDifferent]
int copyprepend_file(char *name1, char *ext1, char *name2, char *ext2, char *prepend)
                                        ^
src/zcc/zcc.c:189:58: note: Function 'copyprepend_file' argument 2 names different: declaration 'src_extension' definition 'ext1'.
static int             copyprepend_file(char *src, char *src_extension, char *dest, char *dest_extension, char *prepend);
                                                         ^
src/zcc/zcc.c:2023:41: note: Function 'copyprepend_file' argument 2 names different: declaration 'src_extension' definition 'ext1'.
int copyprepend_file(char *name1, char *ext1, char *name2, char *ext2, char *prepend)
                                        ^
src/zcc/zcc.c:2023:53: style:inconclusive: Function 'copyprepend_file' argument 3 names different: declaration 'dest' definition 'name2'. [funcArgNamesDifferent]
int copyprepend_file(char *name1, char *ext1, char *name2, char *ext2, char *prepend)
                                                    ^
src/zcc/zcc.c:189:79: note: Function 'copyprepend_file' argument 3 names different: declaration 'dest' definition 'name2'.
static int             copyprepend_file(char *src, char *src_extension, char *dest, char *dest_extension, char *prepend);
                                                                              ^
src/zcc/zcc.c:2023:53: note: Function 'copyprepend_file' argument 3 names different: declaration 'dest' definition 'name2'.
int copyprepend_file(char *name1, char *ext1, char *name2, char *ext2, char *prepend)
                                                    ^
src/zcc/zcc.c:2023:66: style:inconclusive: Function 'copyprepend_file' argument 4 names different: declaration 'dest_extension' definition 'ext2'. [funcArgNamesDifferent]
int copyprepend_file(char *name1, char *ext1, char *name2, char *ext2, char *prepend)
                                                                 ^
src/zcc/zcc.c:189:91: note: Function 'copyprepend_file' argument 4 names different: declaration 'dest_extension' definition 'ext2'.
static int             copyprepend_file(char *src, char *src_extension, char *dest, char *dest_extension, char *prepend);
                                                                                          ^
src/zcc/zcc.c:2023:66: note: Function 'copyprepend_file' argument 4 names different: declaration 'dest_extension' definition 'ext2'.
int copyprepend_file(char *name1, char *ext1, char *name2, char *ext2, char *prepend)
                                                                 ^
src/zcc/zcc.c:2066:21: style:inconclusive: Function 'copy_file' argument 1 names different: declaration 'src' definition 'name1'. [funcArgNamesDifferent]
int copy_file(char *name1, char *ext1, char *name2, char *ext2)
                    ^
src/zcc/zcc.c:190:40: note: Function 'copy_file' argument 1 names different: declaration 'src' definition 'name1'.
static int             copy_file(char *src, char *src_extension, char *dest, char *dest_extension);
                                       ^
src/zcc/zcc.c:2066:21: note: Function 'copy_file' argument 1 names different: declaration 'src' definition 'name1'.
int copy_file(char *name1, char *ext1, char *name2, char *ext2)
                    ^
src/zcc/zcc.c:2066:34: style:inconclusive: Function 'copy_file' argument 2 names different: declaration 'src_extension' definition 'ext1'. [funcArgNamesDifferent]
int copy_file(char *name1, char *ext1, char *name2, char *ext2)
                                 ^
src/zcc/zcc.c:190:51: note: Function 'copy_file' argument 2 names different: declaration 'src_extension' definition 'ext1'.
static int             copy_file(char *src, char *src_extension, char *dest, char *dest_extension);
                                                  ^
src/zcc/zcc.c:2066:34: note: Function 'copy_file' argument 2 names different: declaration 'src_extension' definition 'ext1'.
int copy_file(char *name1, char *ext1, char *name2, char *ext2)
                                 ^
src/zcc/zcc.c:2066:46: style:inconclusive: Function 'copy_file' argument 3 names different: declaration 'dest' definition 'name2'. [funcArgNamesDifferent]
int copy_file(char *name1, char *ext1, char *name2, char *ext2)
                                             ^
src/zcc/zcc.c:190:72: note: Function 'copy_file' argument 3 names different: declaration 'dest' definition 'name2'.
static int             copy_file(char *src, char *src_extension, char *dest, char *dest_extension);
                                                                       ^
src/zcc/zcc.c:2066:46: note: Function 'copy_file' argument 3 names different: declaration 'dest' definition 'name2'.
int copy_file(char *name1, char *ext1, char *name2, char *ext2)
                                             ^
src/zcc/zcc.c:2066:59: style:inconclusive: Function 'copy_file' argument 4 names different: declaration 'dest_extension' definition 'ext2'. [funcArgNamesDifferent]
int copy_file(char *name1, char *ext1, char *name2, char *ext2)
                                                          ^
src/zcc/zcc.c:190:84: note: Function 'copy_file' argument 4 names different: declaration 'dest_extension' definition 'ext2'.
static int             copy_file(char *src, char *src_extension, char *dest, char *dest_extension);
                                                                                   ^
src/zcc/zcc.c:2066:59: note: Function 'copy_file' argument 4 names different: declaration 'dest_extension' definition 'ext2'.
int copy_file(char *name1, char *ext1, char *name2, char *ext2)
                                                          ^
src/zcc/zcc.c:2071:24: style:inconclusive: Function 'prepend_file' argument 1 names different: declaration 'src' definition 'name1'. [funcArgNamesDifferent]
int prepend_file(char *name1, char *ext1, char *name2, char *ext2, char *prepend)
                       ^
src/zcc/zcc.c:191:43: note: Function 'prepend_file' argument 1 names different: declaration 'src' definition 'name1'.
static int             prepend_file(char *src, char *src_extension, char *dest, char *dest_extension, char *prepend);
                                          ^
src/zcc/zcc.c:2071:24: note: Function 'prepend_file' argument 1 names different: declaration 'src' definition 'name1'.
int prepend_file(char *name1, char *ext1, char *name2, char *ext2, char *prepend)
                       ^
src/zcc/zcc.c:2071:37: style:inconclusive: Function 'prepend_file' argument 2 names different: declaration 'src_extension' definition 'ext1'. [funcArgNamesDifferent]
int prepend_file(char *name1, char *ext1, char *name2, char *ext2, char *prepend)
                                    ^
src/zcc/zcc.c:191:54: note: Function 'prepend_file' argument 2 names different: declaration 'src_extension' definition 'ext1'.
static int             prepend_file(char *src, char *src_extension, char *dest, char *dest_extension, char *prepend);
                                                     ^
src/zcc/zcc.c:2071:37: note: Function 'prepend_file' argument 2 names different: declaration 'src_extension' definition 'ext1'.
int prepend_file(char *name1, char *ext1, char *name2, char *ext2, char *prepend)
                                    ^
src/zcc/zcc.c:2071:49: style:inconclusive: Function 'prepend_file' argument 3 names different: declaration 'dest' definition 'name2'. [funcArgNamesDifferent]
int prepend_file(char *name1, char *ext1, char *name2, char *ext2, char *prepend)
                                                ^
src/zcc/zcc.c:191:75: note: Function 'prepend_file' argument 3 names different: declaration 'dest' definition 'name2'.
static int             prepend_file(char *src, char *src_extension, char *dest, char *dest_extension, char *prepend);
                                                                          ^
src/zcc/zcc.c:2071:49: note: Function 'prepend_file' argument 3 names different: declaration 'dest' definition 'name2'.
int prepend_file(char *name1, char *ext1, char *name2, char *ext2, char *prepend)
                                                ^
src/zcc/zcc.c:2071:62: style:inconclusive: Function 'prepend_file' argument 4 names different: declaration 'dest_extension' definition 'ext2'. [funcArgNamesDifferent]
int prepend_file(char *name1, char *ext1, char *name2, char *ext2, char *prepend)
                                                             ^
src/zcc/zcc.c:191:87: note: Function 'prepend_file' argument 4 names different: declaration 'dest_extension' definition 'ext2'.
static int             prepend_file(char *src, char *src_extension, char *dest, char *dest_extension, char *prepend);
                                                                                      ^
src/zcc/zcc.c:2071:62: note: Function 'prepend_file' argument 4 names different: declaration 'dest_extension' definition 'ext2'.
int prepend_file(char *name1, char *ext1, char *name2, char *ext2, char *prepend)
                                                             ^
src/zcc/zcc.c:2235:22: warning: Function 'AddArray' argument order different: declaration 'arg, ' definition 'argument, arg' [funcArgOrderDifferent]
void AddArray(arg_t *argument, char *arg)
                     ^
src/zcc/zcc.c:152:40: note: Function 'AddArray' argument order different: declaration 'arg, ' definition 'argument, arg'
static void            AddArray(arg_t *arg, char *);
                                       ^
src/zcc/zcc.c:2235:22: note: Function 'AddArray' argument order different: declaration 'arg, ' definition 'argument, arg'
void AddArray(arg_t *argument, char *arg)
                     ^
src/zcc/zcc.c:2246:34: warning: Function 'conf_opt_code_speed' argument order different: declaration 'arg, ' definition 'argument, arg' [funcArgOrderDifferent]
void conf_opt_code_speed(option *argument, char *arg)
                                 ^
src/zcc/zcc.c:153:52: note: Function 'conf_opt_code_speed' argument order different: declaration 'arg, ' definition 'argument, arg'
static void            conf_opt_code_speed(option *arg, char *);
                                                   ^
src/zcc/zcc.c:2246:34: note: Function 'conf_opt_code_speed' argument order different: declaration 'arg, ' definition 'argument, arg'
void conf_opt_code_speed(option *argument, char *arg)
                                 ^
src/zcc/zcc.c:2261:24: warning: Function 'AddToArgs' argument order different: declaration 'arg, ' definition 'argument, arg' [funcArgOrderDifferent]
void AddToArgs(option *argument, char *arg)
                       ^
src/zcc/zcc.c:138:42: note: Function 'AddToArgs' argument order different: declaration 'arg, ' definition 'argument, arg'
static void            AddToArgs(option *arg, char *);
                                         ^
src/zcc/zcc.c:2261:24: note: Function 'AddToArgs' argument order different: declaration 'arg, ' definition 'argument, arg'
void AddToArgs(option *argument, char *arg)
                       ^
src/zcc/zcc.c:2266:30: warning: Function 'AddToArgsQuoted' argument order different: declaration 'arg, ' definition 'argument, arg' [funcArgOrderDifferent]
void AddToArgsQuoted(option *argument, char *arg)
                             ^
src/zcc/zcc.c:139:48: note: Function 'AddToArgsQuoted' argument order different: declaration 'arg, ' definition 'argument, arg'
static void            AddToArgsQuoted(option *arg, char *);
                                               ^
src/zcc/zcc.c:2266:30: note: Function 'AddToArgsQuoted' argument order different: declaration 'arg, ' definition 'argument, arg'
void AddToArgsQuoted(option *argument, char *arg)
                             ^
src/zcc/zcc.c:2271:32: warning: Function 'AddPreProcIncPath' argument order different: declaration 'arg, ' definition 'argument, arg' [funcArgOrderDifferent]
void AddPreProcIncPath(option *argument, char *arg)
                               ^
src/zcc/zcc.c:137:50: note: Function 'AddPreProcIncPath' argument order different: declaration 'arg, ' definition 'argument, arg'
static void            AddPreProcIncPath(option *arg, char *);
                                                 ^
src/zcc/zcc.c:2271:32: note: Function 'AddPreProcIncPath' argument order different: declaration 'arg, ' definition 'argument, arg'
void AddPreProcIncPath(option *argument, char *arg)
                               ^
src/zcc/zcc.c:2280:25: warning: Function 'AddPreProc' argument order different: declaration 'arg, ' definition 'argument, arg' [funcArgOrderDifferent]
void AddPreProc(option *argument, char *arg)
                        ^
src/zcc/zcc.c:136:43: note: Function 'AddPreProc' argument order different: declaration 'arg, ' definition 'argument, arg'
static void            AddPreProc(option *arg, char *);
                                          ^
src/zcc/zcc.c:2280:25: note: Function 'AddPreProc' argument order different: declaration 'arg, ' definition 'argument, arg'
void AddPreProc(option *argument, char *arg)
                        ^
src/zcc/zcc.c:2287:29: warning: Function 'AddLinkLibrary' argument order different: declaration 'arg, ' definition 'argument, arg' [funcArgOrderDifferent]
void AddLinkLibrary(option *argument, char *arg)
                            ^
src/zcc/zcc.c:140:47: note: Function 'AddLinkLibrary' argument order different: declaration 'arg, ' definition 'argument, arg'
static void            AddLinkLibrary(option *arg, char *);
                                              ^
src/zcc/zcc.c:2287:29: note: Function 'AddLinkLibrary' argument order different: declaration 'arg, ' definition 'argument, arg'
void AddLinkLibrary(option *argument, char *arg)
                            ^
src/zcc/zcc.c:2296:32: warning: Function 'AddLinkSearchPath' argument order different: declaration 'arg, ' definition 'argument, arg' [funcArgOrderDifferent]
void AddLinkSearchPath(option *argument, char *arg)
                               ^
src/zcc/zcc.c:141:50: note: Function 'AddLinkSearchPath' argument order different: declaration 'arg, ' definition 'argument, arg'
static void            AddLinkSearchPath(option *arg, char *);
                                                 ^
src/zcc/zcc.c:2296:32: note: Function 'AddLinkSearchPath' argument order different: declaration 'arg, ' definition 'argument, arg'
void AddLinkSearchPath(option *argument, char *arg)
                               ^
src/zcc/zcc.c:2380:28: style:inconclusive: Function 'is_path_absolute' argument 1 names different: declaration 'filename' definition 'p'. [funcArgNamesDifferent]
int is_path_absolute(char *p)
                           ^
src/zcc/zcc.c:165:47: note: Function 'is_path_absolute' argument 1 names different: declaration 'filename' definition 'p'.
static int             is_path_absolute(char *filename);
                                              ^
src/zcc/zcc.c:2380:28: note: Function 'is_path_absolute' argument 1 names different: declaration 'filename' definition 'p'.
int is_path_absolute(char *p)
                           ^
src/zcc/zcc.c:2709:35: style:inconclusive: Function 'parse_configfile' argument 1 names different: declaration 'config_line' definition 'filename'. [funcArgNamesDifferent]
void parse_configfile(const char *filename)
                                  ^
src/zcc/zcc.c:175:53: note: Function 'parse_configfile' argument 1 names different: declaration 'config_line' definition 'filename'.
static void            parse_configfile(const char *config_line);
                                                    ^
src/zcc/zcc.c:2709:35: note: Function 'parse_configfile' argument 1 names different: declaration 'config_line' definition 'filename'.
void parse_configfile(const char *filename)
                                  ^
src/zcc/zcc.c:2727:34: style:inconclusive: Function 'parse_configfile_line' argument 1 names different: declaration 'config_line' definition 'arg'. [funcArgNamesDifferent]
void parse_configfile_line(char *arg)
                                 ^
src/zcc/zcc.c:176:52: note: Function 'parse_configfile_line' argument 1 names different: declaration 'config_line' definition 'arg'.
static void            parse_configfile_line(char *config_line);
                                                   ^
src/zcc/zcc.c:2727:34: note: Function 'parse_configfile_line' argument 1 names different: declaration 'config_line' definition 'arg'.
void parse_configfile_line(char *arg)
                                 ^
src/zcc/zcc.c:3012:20: style:inconclusive: Function 'KillEOL' argument 1 names different: declaration 'line' definition 'str'. [funcArgNamesDifferent]
void KillEOL(char *str)
                   ^
src/zcc/zcc.c:177:38: note: Function 'KillEOL' argument 1 names different: declaration 'line' definition 'str'.
static void            KillEOL(char *line);
                                     ^
src/zcc/zcc.c:3012:20: note: Function 'KillEOL' argument 1 names different: declaration 'line' definition 'str'.
void KillEOL(char *str)
                   ^
src/zcc/zcc.c:3119:51: style:inconclusive: Function 'remove_file_with_extension' argument 2 names different: declaration 'suffix' definition 'ext'. [funcArgNamesDifferent]
void remove_file_with_extension(char *file, char *ext)
                                                  ^
src/zcc/zcc.c:188:69: note: Function 'remove_file_with_extension' argument 2 names different: declaration 'suffix' definition 'ext'.
static void            remove_file_with_extension(char *file, char *suffix);
                                                                    ^
src/zcc/zcc.c:3119:51: note: Function 'remove_file_with_extension' argument 2 names different: declaration 'suffix' definition 'ext'.
void remove_file_with_extension(char *file, char *ext)
                                                  ^
src/zcc/zcc.c:992:15: style: Local variable 'ptr' shadows outer variable [shadowVariable]
        char *ptr = c_aliases_array[i];
              ^
src/zcc/zcc.c:895:21: note: Shadowed declaration
    char           *ptr;
                    ^
src/zcc/zcc.c:992:15: note: Shadow variable
        char *ptr = c_aliases_array[i];
              ^
src/zcc/zcc.c:1229:18: style: Local variable 'buffer' shadows outer variable [shadowVariable]
            char buffer[LINEMAX + 1];
                 ^
src/zcc/zcc.c:898:21: note: Shadowed declaration
    char            buffer[LINEMAX + 1];    /* For reading in option file */
                    ^
src/zcc/zcc.c:1229:18: note: Shadow variable
            char buffer[LINEMAX + 1];
                 ^
src/zcc/zcc.c:1955:12: warning: Suspicious usage of 'sizeof' with a numeric constant as parameter. [sizeofwithnumericparameter]
    buffer[sizeof(LINEMAX)] = 0;
           ^
src/zcc/zcc.c:2032:12: warning: Suspicious usage of 'sizeof' with a numeric constant as parameter. [sizeofwithnumericparameter]
    buffer[sizeof(LINEMAX)] = 0;
           ^
src/zcc/zcc.c:3335:14: style: Variable 'type' is assigned a value that is never used. [unreadVariable]
    int type = 0;
             ^
src/zcc/zcc.c:3473:15: error: va_list 'saveap' was opened but not closed by va_end(). [va_end_missing]
    return req;
              ^
src/zcc/zcc.c:2556:0: information: Skipping configuration 'S_ISDIR;WIN32' since the value of 'S_ISDIR' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                    if ( stat(p, &tmp) == 0 && !S_ISDIR(tmp.st_mode) ) {
^
src/zcc/zcc.c:1077:0: information: Skipping configuration 'S_ISREG;WIN32' since the value of 'S_ISREG' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
            if (stat(expanded, &sb) == 0 && S_ISREG(sb.st_mode)) {
^
src/zcc/zcc.c:2677:0: information: Skipping configuration 'S_ISREG;WIN32' since the value of 'S_ISREG' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
        if ( stat(buf, &sb) == 0 && S_ISREG(sb.st_mode)) {
^
src/zcc/zcc.c:2685:0: information: Skipping configuration 'S_ISREG;WIN32' since the value of 'S_ISREG' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
            if ( stat(buf, &sb) == 0 && S_ISREG(sb.st_mode)) {
^
src/zcc/zcc.c:2692:0: information: Skipping configuration 'S_ISREG;WIN32' since the value of 'S_ISREG' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
        if ( stat(buf, &sb) == 0 && S_ISREG(sb.st_mode)) {
^
src/zcc/zcc.c:2698:0: information: Skipping configuration 'S_ISREG;WIN32' since the value of 'S_ISREG' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
        if ( stat(buf, &sb) == 0 && S_ISREG(sb.st_mode)) {
^
src/zcc/zcc.c:3450:5: error: va_list 'saveap' used before va_start() was called. [va_list_usedBeforeStarted]
    saveap = ap;
    ^
src/zcc/zcc.c:3466:44: error: va_list 'saveap' used before va_start() was called. [va_list_usedBeforeStarted]
        req = vsnprintf(ret, req + 1, fmt, saveap);
                                           ^
src/zobjcopy/zobjcopy.c:145:5: warning: %x in format string (no. 1) requires 'unsigned int *' but the argument type is 'signed int *'. [invalidScanfArgType_int]
    sscanf(options.optarg + 2, "%x", &val);
    ^
src/zobjcopy/zobjcopy.c:244:5: warning: %x in format string (no. 1) requires 'unsigned int *' but the argument type is 'signed int *'. [invalidScanfArgType_int]
    sscanf(arg + 2, "%x", &val);
    ^
src/zobjcopy/zobjcopy.c:255:5: warning: %x in format string (no. 1) requires 'unsigned int *' but the argument type is 'signed int *'. [invalidScanfArgType_int]
    sscanf(arg + 2, "%x", &val);
    ^
src/zobjcopy/zobjcopy.c:209:9: style: Local variable 'command' shadows outer variable [shadowVariable]
  char *command = *(char**)utarray_eltptr(commands, 0);
        ^
src/zobjcopy/zobjcopy.c:68:8: note: Shadowed declaration
 char *command = xstrdup("X");
       ^
src/zobjcopy/zobjcopy.c:209:9: note: Shadow variable
  char *command = *(char**)utarray_eltptr(commands, 0);
        ^
src/zpragma/zpragma.c:457:17: warning: sscanf() without field width limits can crash with huge input data. [invalidscanf]
                sscanf(ptr,"%d %s",&num,tmp);
                ^
src/zpragma/zpragma.c:49:11: style: The scope of the variable 'fp' can be reduced. [variableScope]
    FILE *fp;
          ^
src/zpragma/zpragma.c:76:13: style: The scope of the variable 'fp' can be reduced. [variableScope]
    FILE   *fp;
            ^
src/zpragma/zpragma.c:79:10: style: The scope of the variable 'value' can be reduced. [variableScope]
    long value;
         ^
src/zpragma/zpragma.c:80:13: style: The scope of the variable 'count' can be reduced. [variableScope]
    int     count;
            ^
src/zpragma/zpragma.c:335:13: style: The scope of the variable 'ptr' can be reduced. [variableScope]
    char   *ptr;
            ^
src/zpragma/zpragma.c:100:13: style: Variable 'ptr' is assigned a value that is never used. [unreadVariable]
        ptr = skip_ws(line);
            ^
src/zx0/dzx0.c:202:25: error: Return value of allocation function 'fopen' is not stored. [leakReturnValNotUsed]
    if (!forced_mode && fopen(output_name, "rb") != NULL) {
                        ^
src/zx0/dzx0.c:87:9: style: The scope of the variable 'i' can be reduced. [variableScope]
    int i;
        ^
src/zx0/dzx0.c:57:33: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
    return bit_value & bit_mask ? 1 : 0;
                                ^
src/zx0/optimize.c:54:9: style: The scope of the variable 'best_length_size' can be reduced. [variableScope]
    int best_length_size;
        ^
src/zx0/zx0.c:137:25: error: Return value of allocation function 'fopen' is not stored. [leakReturnValNotUsed]
    if (!forced_mode && fopen(output_name, "rb") != NULL) {
                        ^
src/zx0/zx0.c:36:19: style: The scope of the variable 'c' can be reduced. [variableScope]
    unsigned char c;
                  ^
src/zx7/compress.c:73:12: style: The scope of the variable 'input_prev' can be reduced. [variableScope]
    size_t input_prev;
           ^
src/zx7/dzx7.c:218:13: error: Return value of allocation function 'fopen' is not stored. [leakReturnValNotUsed]
        if (fopen(output_name, "rb") != NULL) {
            ^
src/zx7/dzx7.c:88:9: style: The scope of the variable 'i' can be reduced. [variableScope]
    int i;
        ^
src/zx7/dzx7.c:121:9: style: The scope of the variable 'i' can be reduced. [variableScope]
    int i;
        ^
src/zx7/dzx7.c:65:33: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
    return bit_value & bit_mask ? 1 : 0;
                                ^
src/zx7/optimize.c:56:12: style: The scope of the variable 'best_len' can be reduced. [variableScope]
    size_t best_len;
           ^
src/zx7/zx7.c:142:25: error: Return value of allocation function 'fopen' is not stored. [leakReturnValNotUsed]
    if (!forced_mode && fopen(output_name, "rb") != NULL) {
                        ^
src/zx7/zx7.c:43:19: style: The scope of the variable 'c' can be reduced. [variableScope]
    unsigned char c;
                  ^
support/basck/basck.c:4018:13: style: Expression is always false because 'else if' condition matches previous condition at line 4015. [multiCondition]
        if (SKOOLMODE)
            ^
support/basck/basck.c:3694:10: style: The if condition is the same as the previous if condition [duplicateCondition]
  if (res>0) {
         ^
support/basck/basck.c:3692:10: note: First condition
  if (res>0) dlbl("CMDTABLE", res, "HuBASIC command list");
         ^
support/basck/basck.c:3694:10: note: Second condition
  if (res>0) {
         ^
support/basck/basck.c:3076:56: style: Condition 'img[i-2]!=('='+0x80)' is always true [knownConditionTrueFalse]
     if ((c == '<') && ((img[i-2] != '=') || (img[i-2] != ('='+0x80)))) {
                                                       ^
support/basck/basck.c:3076:35: note: Assuming that condition 'img[i-2]!='='' is not redundant
     if ((c == '<') && ((img[i-2] != '=') || (img[i-2] != ('='+0x80)))) {
                                  ^
support/basck/basck.c:3076:56: note: Condition 'img[i-2]!=('='+0x80)' is always true
     if ((c == '<') && ((img[i-2] != '=') || (img[i-2] != ('='+0x80)))) {
                                                       ^
support/basck/basck.c:1362:7: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
      printf("\n#    (Detected position for ORG:  %d)", (unsigned int) pos);
      ^
support/basck/basck.c:1379:4: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
   printf("\n#    (Detected position basing on TSTSGN:  %d)", (unsigned int) pos);
   ^
support/basck/basck.c:1389:4: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
   printf("\n#    (Detected position basing on DVBCDE:  %d)", (unsigned int) pos);
   ^
support/basck/basck.c:2833:5: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
    printf("\n#\t= assignment\t\t[%d]\t", (unsigned int) res2);
    ^
support/basck/basck.c:2994:5: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
    printf("\n#\tELSE\t\t[%d]\n", (unsigned int) (res2));
    ^
support/basck/basck.c:3228:3: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
  printf("\n#\t STKEND system variable = %d  ; ", (unsigned int) res);
  ^
support/basck/basck.c:3702:6: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
     printf("\n#    ORG shift detected, %d bytes\n\n", (unsigned int) pos);
     ^
support/basck/basck.c:3711:7: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
      printf("\n#    ORG shift detected, %d bytes\n\n", (unsigned int) pos);
      ^
support/basck/basck.c:2992:8: style: Variable 'res2' is reassigned a value before the old one has been used. [redundantAssignment]
   res2=find_skel(else_token_skel);
       ^
support/basck/basck.c:2977:16: note: res2 is assigned
           res2--;
               ^
support/basck/basck.c:2992:8: note: res2 is overwritten
   res2=find_skel(else_token_skel);
       ^
support/basck/basck.c:3120:75: style: Same expression on both sides of '||' because 'img[i+3]=='B'' and 'img[i+3]==('B')' represent the same value. [knownConditionTrueFalse]
      ((img[i+1]  == 'T'+0x80) && (img[i+2] == 'A') && ((img[i+3] == 'B') || (img[i+3] == ('B'))))
                                                                          ^
support/basck/basck.c:1055:8: style: The scope of the variable 'retval' can be reduced. [variableScope]
 int i,retval;
       ^
support/basck/basck.c:1194:9: style: The scope of the variable 'flg' can be reduced. [variableScope]
 int i, flg;
        ^
support/basck/basck.c:1195:18: style: The scope of the variable 'res3' can be reduced. [variableScope]
 long res, res2, res3;
                 ^
support/basck/basck.c:1196:6: style: The scope of the variable 'token_range' can be reduced. [variableScope]
 int token_range;
     ^
support/basck/basck.c:1197:6: style: The scope of the variable 'new_tk_found' can be reduced. [variableScope]
 int new_tk_found;
     ^
support/bin2var/bin2var.c:69:35: warning: The address of local variable 'i' might be accessed at non-zero index. [objectIndex]
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/bin2var/bin2var.c:174:13: note: Address of variable taken here.
    cfwrite(&i, 1, fp, &chk);
            ^
support/bin2var/bin2var.c:174:13: note: Calling function 'cfwrite', 1st argument '&i' value is lifetime=i
    cfwrite(&i, 1, fp, &chk);
            ^
support/bin2var/bin2var.c:69:35: note: The address of local variable 'i' might be accessed at non-zero index.
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/bin2var/bin2var.c:69:35: warning: The address of local variable 'i' might be accessed at non-zero index. [objectIndex]
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/bin2var/bin2var.c:184:11: note: Address of variable taken here.
  cfwrite(&i, 2, fp, &chk);
          ^
support/bin2var/bin2var.c:184:11: note: Calling function 'cfwrite', 1st argument '&i' value is lifetime=i
  cfwrite(&i, 2, fp, &chk);
          ^
support/bin2var/bin2var.c:69:35: note: The address of local variable 'i' might be accessed at non-zero index.
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/bin2var/bin2var.c:69:35: warning: The address of local variable 'i' might be accessed at non-zero index. [objectIndex]
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/bin2var/bin2var.c:193:13: note: Address of variable taken here.
    cfwrite(&i, 1, fp, &chk);
            ^
support/bin2var/bin2var.c:193:13: note: Calling function 'cfwrite', 1st argument '&i' value is lifetime=i
    cfwrite(&i, 1, fp, &chk);
            ^
support/bin2var/bin2var.c:69:35: note: The address of local variable 'i' might be accessed at non-zero index.
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/bin2var/bin2var.c:69:35: warning: The address of local variable 'i' might be accessed at non-zero index. [objectIndex]
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/bin2var/bin2var.c:208:11: note: Address of variable taken here.
  cfwrite(&i, 2, fp, &chk);
          ^
support/bin2var/bin2var.c:208:11: note: Calling function 'cfwrite', 1st argument '&i' value is lifetime=i
  cfwrite(&i, 2, fp, &chk);
          ^
support/bin2var/bin2var.c:69:35: note: The address of local variable 'i' might be accessed at non-zero index.
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/bin2var/bin2var.c:55:13: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  p = ftell(fp);
            ^
support/bin2var/bin2var.c:136:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/bin2var/bin2var.c:138:13: note: Calling function 'fsize', 1st argument 'fp' value is 0
  n = fsize(fp);
            ^
support/bin2var/bin2var.c:55:13: note: Null pointer dereference
  p = ftell(fp);
            ^
support/bin2var/bin2var.c:56:9: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  fseek(fp, 0L, SEEK_END);
        ^
support/bin2var/bin2var.c:136:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/bin2var/bin2var.c:138:13: note: Calling function 'fsize', 1st argument 'fp' value is 0
  n = fsize(fp);
            ^
support/bin2var/bin2var.c:56:9: note: Null pointer dereference
  fseek(fp, 0L, SEEK_END);
        ^
support/bin2var/bin2var.c:57:16: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  size = ftell(fp);
               ^
support/bin2var/bin2var.c:136:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/bin2var/bin2var.c:138:13: note: Calling function 'fsize', 1st argument 'fp' value is 0
  n = fsize(fp);
            ^
support/bin2var/bin2var.c:57:16: note: Null pointer dereference
  size = ftell(fp);
               ^
support/bin2var/bin2var.c:58:9: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  fseek(fp, p, SEEK_SET);
        ^
support/bin2var/bin2var.c:136:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/bin2var/bin2var.c:138:13: note: Calling function 'fsize', 1st argument 'fp' value is 0
  n = fsize(fp);
            ^
support/bin2var/bin2var.c:58:9: note: Null pointer dereference
  fseek(fp, p, SEEK_SET);
        ^
support/bin2var/bin2var.c:76:39: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  fwrite(comment, strlen(comment), 1, fp);
                                      ^
support/bin2var/bin2var.c:145:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/bin2var/bin2var.c:159:16: note: Calling function 'writecomment', 1st argument 'fp' value is 0
  writecomment(fp, comment);
               ^
support/bin2var/bin2var.c:76:39: note: Null pointer dereference
  fwrite(comment, strlen(comment), 1, fp);
                                      ^
support/bin2var/bin2var.c:78:40: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  fwrite(str, 42 - strlen(comment), 1, fp);
                                       ^
support/bin2var/bin2var.c:145:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/bin2var/bin2var.c:159:16: note: Calling function 'writecomment', 1st argument 'fp' value is 0
  writecomment(fp, comment);
               ^
support/bin2var/bin2var.c:78:40: note: Null pointer dereference
  fwrite(str, 42 - strlen(comment), 1, fp);
                                       ^
support/bin2var/bin2var.c:140:20: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  fread(buf, n, 1, fp);
                   ^
support/bin2var/bin2var.c:136:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/bin2var/bin2var.c:140:20: note: Null pointer dereference
  fread(buf, n, 1, fp);
                   ^
support/bin2var/bin2var.c:141:14: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  if (ferror(fp))
             ^
support/bin2var/bin2var.c:136:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/bin2var/bin2var.c:141:14: note: Null pointer dereference
  if (ferror(fp))
             ^
support/bin2var/bin2var.c:143:10: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  fclose(fp);
         ^
support/bin2var/bin2var.c:136:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/bin2var/bin2var.c:143:10: note: Null pointer dereference
  fclose(fp);
         ^
support/bin2var/bin2var.c:36:11: style: The scope of the variable 'argptr' can be reduced. [variableScope]
  va_list argptr;
          ^
support/bin2var/bin2var.c:108:25: style: Unused variable: c [unusedVariable]
  char *buf, str[256], *c;
                        ^
support/bin2var/bin2var2.c:82:18: error: Array 'charbuffer[1]' accessed at index 1, which is out of bounds. [arrayIndexOutOfBounds]
   if( charbuffer[1] == 0 )
                 ^
support/bin2var/bin2var2.c:84:15: error: Array 'charbuffer[1]' accessed at index 1, which is out of bounds. [arrayIndexOutOfBounds]
    charbuffer[1] = charbuffer[0];
              ^
support/bin2var/bin2var2.c:91:22: error: Array 'charbuffer[1]' accessed at index 1, which is out of bounds. [arrayIndexOutOfBounds]
   *chk += charbuffer[1];
                     ^
support/bin2var/bin2var2.c:70:35: warning: The address of local variable 'i' might be accessed at non-zero index. [objectIndex]
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/bin2var/bin2var2.c:201:13: note: Address of variable taken here.
    cfwrite(&i, 1, fp, &chk);
            ^
support/bin2var/bin2var2.c:201:13: note: Calling function 'cfwrite', 1st argument '&i' value is lifetime=i
    cfwrite(&i, 1, fp, &chk);
            ^
support/bin2var/bin2var2.c:70:35: note: The address of local variable 'i' might be accessed at non-zero index.
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/bin2var/bin2var2.c:70:35: warning: The address of local variable 'i' might be accessed at non-zero index. [objectIndex]
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/bin2var/bin2var2.c:213:11: note: Address of variable taken here.
  cfwrite(&i, 2, fp, &chk);
          ^
support/bin2var/bin2var2.c:213:11: note: Calling function 'cfwrite', 1st argument '&i' value is lifetime=i
  cfwrite(&i, 2, fp, &chk);
          ^
support/bin2var/bin2var2.c:70:35: note: The address of local variable 'i' might be accessed at non-zero index.
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/bin2var/bin2var2.c:70:35: warning: The address of local variable 'i' might be accessed at non-zero index. [objectIndex]
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/bin2var/bin2var2.c:222:13: note: Address of variable taken here.
    cfwrite(&i, 1, fp, &chk);
            ^
support/bin2var/bin2var2.c:222:13: note: Calling function 'cfwrite', 1st argument '&i' value is lifetime=i
    cfwrite(&i, 1, fp, &chk);
            ^
support/bin2var/bin2var2.c:70:35: note: The address of local variable 'i' might be accessed at non-zero index.
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/bin2var/bin2var2.c:70:35: warning: The address of local variable 'i' might be accessed at non-zero index. [objectIndex]
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/bin2var/bin2var2.c:242:11: note: Address of variable taken here.
  cfwrite(&i, 2, fp, &chk);
          ^
support/bin2var/bin2var2.c:242:11: note: Calling function 'cfwrite', 1st argument '&i' value is lifetime=i
  cfwrite(&i, 2, fp, &chk);
          ^
support/bin2var/bin2var2.c:70:35: note: The address of local variable 'i' might be accessed at non-zero index.
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/bin2var/bin2var2.c:56:13: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  p = ftell(fp);
            ^
support/bin2var/bin2var2.c:161:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/bin2var/bin2var2.c:163:13: note: Calling function 'fsize', 1st argument 'fp' value is 0
  n = fsize(fp);
            ^
support/bin2var/bin2var2.c:56:13: note: Null pointer dereference
  p = ftell(fp);
            ^
support/bin2var/bin2var2.c:57:9: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  fseek(fp, 0L, SEEK_END);
        ^
support/bin2var/bin2var2.c:161:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/bin2var/bin2var2.c:163:13: note: Calling function 'fsize', 1st argument 'fp' value is 0
  n = fsize(fp);
            ^
support/bin2var/bin2var2.c:57:9: note: Null pointer dereference
  fseek(fp, 0L, SEEK_END);
        ^
support/bin2var/bin2var2.c:58:16: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  size = ftell(fp);
               ^
support/bin2var/bin2var2.c:161:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/bin2var/bin2var2.c:163:13: note: Calling function 'fsize', 1st argument 'fp' value is 0
  n = fsize(fp);
            ^
support/bin2var/bin2var2.c:58:16: note: Null pointer dereference
  size = ftell(fp);
               ^
support/bin2var/bin2var2.c:59:9: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  fseek(fp, p, SEEK_SET);
        ^
support/bin2var/bin2var2.c:161:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/bin2var/bin2var2.c:163:13: note: Calling function 'fsize', 1st argument 'fp' value is 0
  n = fsize(fp);
            ^
support/bin2var/bin2var2.c:59:9: note: Null pointer dereference
  fseek(fp, p, SEEK_SET);
        ^
support/bin2var/bin2var2.c:101:39: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  fwrite(comment, strlen(comment), 1, fp);
                                      ^
support/bin2var/bin2var2.c:170:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/bin2var/bin2var2.c:184:16: note: Calling function 'writecomment', 1st argument 'fp' value is 0
  writecomment(fp, comment);
               ^
support/bin2var/bin2var2.c:101:39: note: Null pointer dereference
  fwrite(comment, strlen(comment), 1, fp);
                                      ^
support/bin2var/bin2var2.c:103:40: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  fwrite(str, 42 - strlen(comment), 1, fp);
                                       ^
support/bin2var/bin2var2.c:170:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/bin2var/bin2var2.c:184:16: note: Calling function 'writecomment', 1st argument 'fp' value is 0
  writecomment(fp, comment);
               ^
support/bin2var/bin2var2.c:103:40: note: Null pointer dereference
  fwrite(str, 42 - strlen(comment), 1, fp);
                                       ^
support/bin2var/bin2var2.c:165:20: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  fread(buf, n, 1, fp);
                   ^
support/bin2var/bin2var2.c:161:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/bin2var/bin2var2.c:165:20: note: Null pointer dereference
  fread(buf, n, 1, fp);
                   ^
support/bin2var/bin2var2.c:166:14: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  if (ferror(fp))
             ^
support/bin2var/bin2var2.c:161:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/bin2var/bin2var2.c:166:14: note: Null pointer dereference
  if (ferror(fp))
             ^
support/bin2var/bin2var2.c:168:10: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  fclose(fp);
         ^
support/bin2var/bin2var2.c:161:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/bin2var/bin2var2.c:168:10: note: Null pointer dereference
  fclose(fp);
         ^
support/bin2var/bin2var2.c:195:20: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  fwrite(&i, 2, 1, fp);
                   ^
support/bin2var/bin2var2.c:170:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/bin2var/bin2var2.c:195:20: note: Null pointer dereference
  fwrite(&i, 2, 1, fp);
                   ^
support/bin2var/bin2var2.c:37:11: style: The scope of the variable 'argptr' can be reduced. [variableScope]
  va_list argptr;
          ^
support/bin2var/bin2var2.c:75:10: style: The scope of the variable 'n' can be reduced. [variableScope]
  int i, n;
         ^
support/bin2var/bin2var2.c:77:9: style: The scope of the variable 'charbufferp' can be reduced. [variableScope]
  char *charbufferp;
        ^
support/bin2var/bin2var2.c:133:25: style: Unused variable: c [unusedVariable]
  char *buf, str[256], *c;
                        ^
support/debugger/client_debug.c:65:8: style: Unused variable: n_read [unusedVariable]
   int n_read;
       ^
support/debugger/dbgbin.c:42:7: error: fprintf format string requires 1 parameter but only 0 are given. [wrongPrintfScanfArgNum]
      fprintf(stderr, "Command: ``%s`` failed\n");
      ^
support/debugger/dbgbin.c:154:7: error: fprintf format string requires 1 parameter but only 0 are given. [wrongPrintfScanfArgNum]
      fprintf(stderr, "Command: ``%s`` failed\n");
      ^
support/debugger/dbgbin.c:130:7: style: Unused variable: i [unusedVariable]
  int i;
      ^
support/debugger/dbgbin.c:185:9: style: Unused variable: ports [unusedVariable]
    int ports[2];
        ^
support/debugger/debugger.c:214:25: portability: Assigning an integer to a pointer is not portable. [AssignmentIntegerToAddress]
     unsigned char *addr=str[2] | (str[3]<<8);
                        ^
support/debugger/debugger.c:238:25: portability: Assigning an integer to a pointer is not portable. [AssignmentIntegerToAddress]
     unsigned char *addr=str[2] | (str[3]<<8);
                        ^
support/debugger/debugger.c:73:7: style: The scope of the variable 'len' can be reduced. [variableScope]
  int len,i;
      ^
support/debugger/debugger_test.c:37:12: warning: Unused variable value 'len' [constStatement]
  pop de ; len ;
           ^
support/debugger/debugger_test.c:36:7: style: Unused variable: bc [unusedVariable]
  pop bc ; save return ;
      ^
support/debugger/debugger_test.c:36:17: style: Unused variable: return [unusedVariable]
  pop bc ; save return ;
                ^
support/debugger/debugger_test.c:37:7: style: Unused variable: de [unusedVariable]
  pop de ; len ;
      ^
support/debugger/debugger_test.c:38:7: style: Unused variable: hl [unusedVariable]
  pop hl ; pointer to string ;
      ^
support/debugger/debugger_test.c:40:8: style: Unused variable: hl [unusedVariable]
  push hl ; balance stack
       ^
support/debugger/debugger_test.c:44:6: style: Unused variable: a [unusedVariable]
  ld a,(_cmd_debug_as_int) ; CMD_DBG ;
     ^
support/debugger/debugger_test.c:49:6: style: Unused variable: h [unusedVariable]
  ld h,0 ;
     ^
support/debugger/debugger_test.c:50:6: style: Unused variable: l [unusedVariable]
  ld l,e ;
     ^
support/debugger/debugger_test.c:50:8: style: Unused variable: e [unusedVariable]
  ld l,e ;
       ^
support/debugger/debugger_test.c:52:8: style: Unused variable: bc [unusedVariable]
  push bc ;
       ^
support/debugger/debugtarget_test.c:176:6: warning: %x in format string (no. 1) requires 'unsigned int *' but the argument type is 'signed int *'. [invalidScanfArgType_int]
     sscanf(tmp,"%x",&hexval);
     ^
support/debugger/debugtarget_test.c:136:21: style: The scope of the variable 'n_read' can be reduced. [variableScope]
 int strlen_linebf, n_read;
                    ^
support/debugger/mysock.c:183:7: style: The scope of the variable 'sent_this_time' can be reduced. [variableScope]
  int sent_this_time=0;
      ^
support/debugger/mysock.c:24:32: style:inconclusive: Function 'mysock_create_listener' argument 1 names different: declaration 'portno' definition 'use_socket'. [funcArgNamesDifferent]
int mysock_create_listener(int use_socket)
                               ^
support/debugger/mysock.h:5:32: note: Function 'mysock_create_listener' argument 1 names different: declaration 'portno' definition 'use_socket'.
int mysock_create_listener(int portno);
                               ^
support/debugger/mysock.c:24:32: note: Function 'mysock_create_listener' argument 1 names different: declaration 'portno' definition 'use_socket'.
int mysock_create_listener(int use_socket)
                               ^
support/debugger/mysock.c:60:40: style:inconclusive: Function 'mysock_create_listener_random' argument 1 names different: declaration 'portno' definition 'use_socketp'. [funcArgNamesDifferent]
int mysock_create_listener_random(int* use_socketp)
                                       ^
support/debugger/mysock.h:6:40: note: Function 'mysock_create_listener_random' argument 1 names different: declaration 'portno' definition 'use_socketp'.
int mysock_create_listener_random(int* portno);
                                       ^
support/debugger/mysock.c:60:40: note: Function 'mysock_create_listener_random' argument 1 names different: declaration 'portno' definition 'use_socketp'.
int mysock_create_listener_random(int* use_socketp)
                                       ^
support/debugger/mysock.c:183:21: style: Variable 'sent_this_time' is assigned a value that is never used. [unreadVariable]
  int sent_this_time=0;
                    ^
support/font/fontpack.c:25:6: style: Unused variable: c [unusedVariable]
 int c;
     ^
support/font/fonttopbm.c:43:48: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
                    fprintf(fp,"%d ", byte & k ? 1 :0);
                                               ^
support/graphics/z80svg.c:401:17: style: Redundant condition: If 'pen > 1', the comparison 'pen != 0' is always true. [redundantCondition]
     if ((pen>1)&&(pen!=0)) {
                ^
support/graphics/z80svg.c:492:19: style: Redundant condition: If 'pen > 1', the comparison 'pen != 0' is always true. [redundantCondition]
       if ((pen>1)&&(pen!=0)) {
                  ^
support/graphics/z80svg.c:843:11: style: The statement 'if (*p!=arg) *p=arg' is logically equivalent to '*p=arg'. [duplicateConditionalAssign]
   if (*p != arg) *p = arg;
          ^
support/graphics/z80svg.c:843:22: note: Assignment '*p=arg'
   if (*p != arg) *p = arg;
                     ^
support/graphics/z80svg.c:843:11: note: Condition '*p!=arg' is redundant
   if (*p != arg) *p = arg;
          ^
support/graphics/z80svg.c:849:12: style: The statement 'if (*p!=arg) *p=arg' is logically equivalent to '*p=arg'. [duplicateConditionalAssign]
    if (*p != arg) *p = arg;
           ^
support/graphics/z80svg.c:849:23: note: Assignment '*p=arg'
    if (*p != arg) *p = arg;
                      ^
support/graphics/z80svg.c:849:12: note: Condition '*p!=arg' is redundant
    if (*p != arg) *p = arg;
           ^
support/graphics/z80svg.c:861:22: warning: Either the condition 'arg' is redundant or there is possible null pointer dereference: arg. [nullPointerRedundantCheck]
 sprintf(sname,"%s", arg);
                     ^
support/graphics/z80svg.c:710:7: note: Assuming that condition 'arg' is not redundant
  if (arg && *arg == '-') {
      ^
support/graphics/z80svg.c:861:22: note: Null pointer dereference
 sprintf(sname,"%s", arg);
                     ^
support/graphics/z80svg.c:315:11: style: The scope of the variable 'attr' can be reduced. [variableScope]
 xmlChar *attr;
          ^
support/graphics/z80svg.c:416:8: style: The scope of the variable 'style' can be reduced. [variableScope]
 char *style;
       ^
support/graphics/z80svg.c:418:6: style: The scope of the variable 'retcode' can be reduced. [variableScope]
 int retcode;
     ^
support/graphics/z80svg.c:419:8: style: The scope of the variable 'forceline' can be reduced. [variableScope]
 float forceline;
       ^
support/graphics/z80svg.c:420:8: style: The scope of the variable 'opacity' can be reduced. [variableScope]
 float opacity;
       ^
support/graphics/z80svg.c:421:8: style: The scope of the variable 'stroke_opacity' can be reduced. [variableScope]
 float stroke_opacity;
       ^
support/graphics/z80svg.c:623:7: style: The scope of the variable 'ax' can be reduced. [variableScope]
float ax;
      ^
support/graphics/z80svg.c:272:6: style: Local variable 'color' shadows outer variable [shadowVariable]
 int color;
     ^
support/graphics/z80svg.c:207:15: note: Shadowed declaration
unsigned char color;
              ^
support/graphics/z80svg.c:272:6: note: Shadow variable
 int color;
     ^
support/graphics/z80svg.c:572:49: error: Undefined behavior: Variable 'destline' is used as parameter and destination in sprintf(). [sprintfOverlappingData]
    sprintf(destline,"%s 0x%2X,0x%02X,0x%02X,", destline, CMD_AREA_LINETO, x, y);
                                                ^
support/graphics/z80svg.c:574:43: error: Undefined behavior: Variable 'destline' is used as parameter and destination in sprintf(). [sprintfOverlappingData]
    sprintf(destline,"%s 0x%02X,0x%02X,", destline, x, y);
                                          ^
support/graphics/z80svg.c:578:50: error: Undefined behavior: Variable 'destline' is used as parameter and destination in sprintf(). [sprintfOverlappingData]
     sprintf(destline,"%s 0x%2X,0x%02X,0x%02X,", destline, CMD_LINETO|pen, x, y);
                                                 ^
support/graphics/z80svg.c:580:44: error: Undefined behavior: Variable 'destline' is used as parameter and destination in sprintf(). [sprintfOverlappingData]
     sprintf(destline,"%s 0x%02X,0x%02X,", destline, x, y);
                                           ^
support/graphics/z80svg.c:427:11: style: Variable 'opacity' is assigned a value that is never used. [unreadVariable]
  opacity = 0;
          ^
support/oz/makewzd.c:150:3: error: Resource leak: in [resourceLeak]
  return 5;
  ^
support/oz/makewzd.c:169:13: error: Resource leak: in [resourceLeak]
            return 6;
            ^
support/oz/makewzd.c:169:13: error: Resource leak: out [resourceLeak]
            return 6;
            ^
support/oz/makewzd.c:195:13: error: Resource leak: in [resourceLeak]
            return 17;
            ^
support/oz/makewzd.c:97:9: style: The scope of the variable 'r' can be reduced. [variableScope]
    int r;
        ^
support/p2000/stripcas.c:56:6: error: Unmatched '('. Configuration: ''. [syntaxError]
  if ((i==0x33)||(i==0x35)||(i==0x1B)||(i==0x43) {
     ^
support/rcmx000/baudmeas.asm:5:24: error: syntax error [syntaxError]
; $Id: baudmeas.asm,v 1.1 2007-05-18 06:36:50 stefano Exp $
                       ^
support/rcmx000/boot.c:177:8: style: Condition 'debug_poll' is always true [knownConditionTrueFalse]
   if (debug_poll) fprintf(stderr, "fd=%d, we have pollin data\n", anfd);
       ^
support/rcmx000/boot.c:173:7: note: Assuming that condition 'debug_poll' is not redundant
  if (debug_poll)
      ^
support/rcmx000/boot.c:177:8: note: Condition 'debug_poll' is always true
   if (debug_poll) fprintf(stderr, "fd=%d, we have pollin data\n", anfd);
       ^
support/rcmx000/boot.c:181:8: style: Condition 'debug_poll' is always true [knownConditionTrueFalse]
   if (debug_poll) fprintf(stderr, "fd=%d, we have NO pollin data\n", anfd);
       ^
support/rcmx000/boot.c:173:7: note: Assuming that condition 'debug_poll' is not redundant
  if (debug_poll)
      ^
support/rcmx000/boot.c:181:8: note: Condition 'debug_poll' is always true
   if (debug_poll) fprintf(stderr, "fd=%d, we have NO pollin data\n", anfd);
       ^
support/rcmx000/boot.c:775:18: style: Condition 'do_flash' is always true [knownConditionTrueFalse]
   if (i==0x8 && do_flash)
                 ^
support/rcmx000/boot.c:751:11: note: Assuming that condition 'do_flash' is not redundant
      if (do_flash)
          ^
support/rcmx000/boot.c:775:18: note: Condition 'do_flash' is always true
   if (i==0x8 && do_flash)
                 ^
support/rcmx000/boot.c:524:7: style: Local variable 'ch' shadows outer variable [shadowVariable]
 char ch;
      ^
support/rcmx000/boot.c:374:17: note: Shadowed declaration
  unsigned char ch;
                ^
support/rcmx000/boot.c:524:7: note: Shadow variable
 char ch;
      ^
support/rcmx000/mk_boot_code.c:69:6: warning: %x in format string (no. 1) requires 'unsigned int *' but the argument type is 'signed int *'. [invalidScanfArgType_int]
     sscanf(peki, "%x", &retval);
     ^
support/rcmx000/mk_boot_code.c:74:6: style:inconclusive: Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]
     break;
     ^
support/rcmx000/mk_boot_code.c:143:7: style: Unused variable: i [unusedVariable]
  int i;
      ^
support/rcmx000/mysock.c:183:7: style: The scope of the variable 'sent_this_time' can be reduced. [variableScope]
  int sent_this_time=0;
      ^
support/rcmx000/mysock.c:24:32: style:inconclusive: Function 'mysock_create_listener' argument 1 names different: declaration 'portno' definition 'use_socket'. [funcArgNamesDifferent]
int mysock_create_listener(int use_socket)
                               ^
support/rcmx000/mysock.h:5:32: note: Function 'mysock_create_listener' argument 1 names different: declaration 'portno' definition 'use_socket'.
int mysock_create_listener(int portno);
                               ^
support/rcmx000/mysock.c:24:32: note: Function 'mysock_create_listener' argument 1 names different: declaration 'portno' definition 'use_socket'.
int mysock_create_listener(int use_socket)
                               ^
support/rcmx000/mysock.c:60:40: style:inconclusive: Function 'mysock_create_listener_random' argument 1 names different: declaration 'portno' definition 'use_socketp'. [funcArgNamesDifferent]
int mysock_create_listener_random(int* use_socketp)
                                       ^
support/rcmx000/mysock.h:6:40: note: Function 'mysock_create_listener_random' argument 1 names different: declaration 'portno' definition 'use_socketp'.
int mysock_create_listener_random(int* portno);
                                       ^
support/rcmx000/mysock.c:60:40: note: Function 'mysock_create_listener_random' argument 1 names different: declaration 'portno' definition 'use_socketp'.
int mysock_create_listener_random(int* use_socketp)
                                       ^
support/rcmx000/mysock.c:183:21: style: Variable 'sent_this_time' is assigned a value that is never used. [unreadVariable]
  int sent_this_time=0;
                    ^
support/rel/REL2BIN.C:177:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    Type = AddressType( Type, AType );
    ^
support/rel/REL2BIN.C:413:29: style: Expression is always false because 'else if' condition matches previous condition at line 410. [multiCondition]
                   if (Pass == 2)
                            ^
support/rel/REL2BIN.C:119:5: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
    printf ( "Switched to pass %u\n", Pass );
    ^
support/rel/REL2BIN.C:397:19: style: The scope of the variable 'byt' can be reduced. [variableScope]
    unsigned char byt;
                  ^
support/rel/REL2BIN.C:398:9: style: The scope of the variable 'RelPtr' can be reduced. [variableScope]
    int RelPtr;
        ^
support/rel/REL2BIN.C:177:10: style: Variable 'Type' is assigned a value that is never used. [unreadVariable]
    Type = AddressType( Type, AType );
         ^
support/rel/REL2Z80.C:287:9: portability: %c in format string (no. 1) requires 'unsigned int' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_uint]
        fprintf( Z80File, "%c%s%c", strlen( TmpExp -> Name ), TmpExp -> Name, 0 );
        ^
support/rel/REL2Z80.C:294:5: portability: %c in format string (no. 1) requires 'unsigned int' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_uint]
    fprintf( Z80File, "%c%s", strlen( Z80Module -> ModuleName ), Z80Module -> ModuleName );
    ^
support/rel/REL2Z80.C:302:13: portability: %c in format string (no. 1) requires 'unsigned int' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_uint]
            fprintf( Z80File, "%c%s", strlen( TmpName -> Name ), TmpName -> Name );
            ^
support/rel/REL2Z80.C:309:13: portability: %c in format string (no. 1) requires 'unsigned int' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_uint]
            fprintf( Z80File, "%c%s", strlen( TmpName -> Name ), TmpName -> Name );
            ^
support/rel/REL2Z80.C:316:9: portability: %c in format string (no. 1) requires 'unsigned int' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_uint]
        fprintf( Z80File, "%c%s", strlen( TmpLib -> Name ), TmpLib -> Name );
        ^
support/rel/REL2Z80.C:320:5: portability: %c in format string (no. 1) requires 'unsigned int' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_uint]
    fprintf( Z80File, "%c%s", strlen( Z80Module -> ModuleName ), Z80Module -> ModuleName );
    ^
support/rel/REL2Z80.C:694:13: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
            printf ( "%s\t\tProgram Size: %u  \tData Size: %u\n", Z80Module -> ModuleName, Z80Module -> ProgramSize, Z80Module -> DataSize );
            ^
support/rel/REL2Z80.C:694:13: warning: %u in format string (no. 3) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
            printf ( "%s\t\tProgram Size: %u  \tData Size: %u\n", Z80Module -> ModuleName, Z80Module -> ProgramSize, Z80Module -> DataSize );
            ^
support/rel/REL2Z80.C:73:11: style: C-style pointer casting [cstyleCast]
    New = (ExpDecl *) malloc( sizeof( struct ExpDecl ) );
          ^
support/rel/REL2Z80.C:156:11: style: C-style pointer casting [cstyleCast]
    New = (NameDecl *) malloc( sizeof( struct NameDecl ) );
          ^
support/rel/REL2Z80.C:212:11: style: C-style pointer casting [cstyleCast]
    New = (LibNameDecl *) malloc( sizeof( struct LibNameDecl ) );
          ^
support/rel/REL2Z80.C:96:9: style: The scope of the variable 'Address' can be reduced. [variableScope]
    int Address, TmpAddr;
        ^
support/rel/REL2Z80.C:726:9: style: The scope of the variable 'RelativePtr' can be reduced. [variableScope]
    int RelativePtr;
        ^
support/rel/REL2Z80.C:552:21: style: Variable 'Address' is assigned a value that is never used. [unreadVariable]
            Address = ReadAddress ( FilePtr, Z80Module );
                    ^
support/rel/REL2Z80.C:599:21: style: Variable 'Address' is assigned a value that is never used. [unreadVariable]
            Address = ReadAddress ( FilePtr, Z80Module );
                    ^
support/rel/REL2Z80.C:660:21: style: Variable 'Address' is assigned a value that is never used. [unreadVariable]
            Address = ReadAddress ( FilePtr, Z80Module );
                    ^
support/rel/REL2Z80.C:513:10: style: Unused variable: Type [unusedVariable]
    char Type[ 3 ];
         ^
support/rel/REL2Z80.C:515:18: style: Unused variable: TmpAddr [unusedVariable]
    int Address, TmpAddr;
                 ^
support/rel/msbasic/baslib.c:789:25: error: There is an unknown macro here somewhere. Configuration is required. If RAND_MAX is a macro then please configure it. [unknownMacro]
 B_TMPFLOAT = (rand() / RAND_MAX.0) * (float) B_TMPINT;
                        ^
support/rel/msbasic/baslib.c:420:0: information: Skipping configuration 'DEBUG' since the value of 'DEBUG' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
;#ifdef DEBUG
^
support/sound/wavzb4.c:92:5: warning: %d in format string (no. 1) requires 'int' but the argument type is 'signed long'. [invalidPrintfArgType_sint]
    printf ("Sample rate: %d\n",rate);
    ^
support/sound/wavzb4.c:101:9: style: Variable 'len0' is assigned a value that is never used. [unreadVariable]
    len0=getc(fpin)+256*getc(fpin);
        ^
support/sound/wavzb4.c:20:13: style: Unused variable: name [unusedVariable]
    char    name[11];
            ^
support/sprites/csp2sgz.c:44:12: style: The scope of the variable 'f' can be reduced. [variableScope]
 PACKFILE *f;
           ^
support/sprites/csp2sgz.c:57:12: style: The scope of the variable 'f' can be reduced. [variableScope]
 PACKFILE *f;
           ^
support/sprites/sprite.c:913:8: warning: %X in format string (no. 1) requires 'unsigned int *' but the argument type is 'signed int *'. [invalidScanfArgType_int]
       fscanf(fpin,"%2X",&pixel);
       ^
support/sprites/sprite.c:861:4: warning: fscanf() without field width limits can crash with huge input data. [invalidscanf]
   fscanf(fpin,"%s %s",xsz,ysz);
   ^
support/sprites/sprite.c:882:3: warning: fscanf() without field width limits can crash with huge input data. [invalidscanf]
  fscanf(fpin,"%s",row);
  ^
support/sprites/sprite.c:898:6: warning: sscanf() without field width limits can crash with huge input data. [invalidscanf]
     sscanf(row,"%s %s %s %s %s",foo,xsz,ysz,foo,pos);
     ^
support/sprites/sprite.c:824:4: error: Resource leak: fpin [resourceLeak]
   return;
   ^
support/sprites/sprite.c:518:12: style: The scope of the variable 'x_offset' can be reduced. [variableScope]
 int x, y, x_offset, y_offset;
           ^
support/sprites/sprite.c:688:6: style: The scope of the variable 'x' can be reduced. [variableScope]
 int x, y, i;
     ^
support/sprites/sprite.c:688:9: style: The scope of the variable 'y' can be reduced. [variableScope]
 int x, y, i;
        ^
support/sprites/sprite.c:688:12: style: The scope of the variable 'i' can be reduced. [variableScope]
 int x, y, i;
           ^
support/sprites/sprite.c:689:16: style: The scope of the variable 'b' can be reduced. [variableScope]
 unsigned char b,id;
               ^
support/sprites/sprite.c:691:25: style: The scope of the variable 'bflag' can be reduced. [variableScope]
 int spcount, exitflag, bflag;
                        ^
support/sprites/sprite.c:692:6: style: The scope of the variable 'index' can be reduced. [variableScope]
 int index, pindex;
     ^
support/sprites/sprite.c:692:13: style: The scope of the variable 'pindex' can be reduced. [variableScope]
 int index, pindex;
            ^
support/sprites/sprite.c:784:7: style: The scope of the variable 'len' can be reduced. [variableScope]
 long len;
      ^
support/sprites/sprite.c:785:12: style: The scope of the variable 'i' can be reduced. [variableScope]
 int x, y, i, j;
           ^
support/sprites/sprite.c:785:15: style: The scope of the variable 'j' can be reduced. [variableScope]
 int x, y, i, j;
              ^
support/sprites/sprite.c:789:7: style: The scope of the variable 'c' can be reduced. [variableScope]
 char c;
      ^
support/sprites/sprite.c:790:7: style: The scope of the variable 'xsz' can be reduced. [variableScope]
 char xsz[10];
      ^
support/sprites/sprite.c:791:7: style: The scope of the variable 'ysz' can be reduced. [variableScope]
 char ysz[10];
      ^
support/sprites/sprite.c:792:7: style: The scope of the variable 'pos' can be reduced. [variableScope]
 char pos[10];
      ^
support/sprites/sprite.c:793:6: style: The scope of the variable 'maxy' can be reduced. [variableScope]
 int maxy;
     ^
support/sprites/sprite.c:795:7: style: The scope of the variable 'row' can be reduced. [variableScope]
 char row[1000];
      ^
support/sprites/sprite.c:796:7: style: The scope of the variable 'foo' can be reduced. [variableScope]
 char foo[10];
      ^
support/sprites/sprite.c:797:6: style: The scope of the variable 'exitflag' can be reduced. [variableScope]
 int exitflag;
     ^
support/sprites/sprite.c:799:6: style: The scope of the variable 'spcount' can be reduced. [variableScope]
 int spcount = 0;
     ^
support/sprites/sprite.c:1071:6: style: The scope of the variable 'x' can be reduced. [variableScope]
 int x, y, i, spcount;
     ^
support/sprites/sprite.c:1071:9: style: The scope of the variable 'y' can be reduced. [variableScope]
 int x, y, i, spcount;
        ^
support/sprites/sprite.c:1606:6: style: The scope of the variable 'x1' can be reduced. [variableScope]
 int x1, x2, y;
     ^
support/sprites/sprite.c:1606:10: style: The scope of the variable 'x2' can be reduced. [variableScope]
 int x1, x2, y;
         ^
support/sprites/sprite.c:1607:6: style: The scope of the variable 'fx1' can be reduced. [variableScope]
 int fx1, fx2;
     ^
support/sprites/sprite.c:1607:11: style: The scope of the variable 'fx2' can be reduced. [variableScope]
 int fx1, fx2;
          ^
support/sprites/sprite.c:1609:6: style: The scope of the variable 'y1' can be reduced. [variableScope]
 int y1, y2, x;
     ^
support/sprites/sprite.c:1609:10: style: The scope of the variable 'y2' can be reduced. [variableScope]
 int y1, y2, x;
         ^
support/sprites/sprite.c:1610:6: style: The scope of the variable 'fy1' can be reduced. [variableScope]
 int fy1, fy2;
     ^
support/sprites/sprite.c:1610:11: style: The scope of the variable 'fy2' can be reduced. [variableScope]
 int fy1, fy2;
          ^
support/sprites/sprite.c:1946:6: style: The scope of the variable 'd' can be reduced. [variableScope]
 int d;
     ^
support/sprites/sprite.c:236:36: error: Undefined behavior: Variable 'hexcode' is used as parameter and destination in sprintf(). [sprintfOverlappingData]
  sprintf( hexcode, "%s, 0x%c%c ", hexcode, hexc[ hstring[ p ] ], hexc[ hstring[ p + 1] ] );
                                   ^
support/sprites/sprite.c:240:30: error: Undefined behavior: Variable 'hexcode' is used as parameter and destination in sprintf(). [sprintfOverlappingData]
   sprintf( hexcode, "%s\n", hexcode );
                             ^
support/sprites/sprite.c:245:32: error: Undefined behavior: Variable 'hexcode' is used as parameter and destination in sprintf(). [sprintfOverlappingData]
  sprintf( hexcode, "%s };\n", hexcode );
                               ^
support/sprites/sprite.c:247:30: error: Undefined behavior: Variable 'hexcode' is used as parameter and destination in sprintf(). [sprintfOverlappingData]
  sprintf( hexcode, "%s \n", hexcode );
                             ^
support/sprites/sprite.c:586:3: error: Memory leak: ScreenBuffer [memleak]
  return;
  ^
support/squsq/sq.c:931:4: warning: Obsolete function 'gets' called. It is recommended to use 'fgets' or 'gets_s' instead. [getsCalled]
   gets(inparg);
   ^
support/squsq/sq.c:334:6: style: The scope of the variable 'lch' can be reduced. [variableScope]
 int lch, rch;  /* temporaries for left, right children */
     ^
support/squsq/sq.c:334:11: style: The scope of the variable 'rch' can be reduced. [variableScope]
 int lch, rch;  /* temporaries for left, right children */
          ^
support/squsq/sq.c:335:13: style: The scope of the variable 'frnp' can be reduced. [variableScope]
 struct nd *frnp; /* free node pointer */
            ^
support/squsq/sq.c:605:12: style: The scope of the variable 'l' can be reduced. [variableScope]
 int i, k, l, r;
           ^
support/squsq/sq.c:605:15: style: The scope of the variable 'r' can be reduced. [variableScope]
 int i, k, l, r;
              ^
support/squsq/sq.c:919:7: style: The scope of the variable 'inparg' can be reduced. [variableScope]
 char inparg[128]; /* parameter from input */
      ^
support/squsq/sq.c:807:1: style: Label 'closeall' is not used. [unusedLabel]
closeall:
^
support/squsq/sq.c:336:6: style: Unused variable: i [unusedVariable]
 int i;
     ^
support/squsq/sq.c:386:6: style: Unused variable: c [unusedVariable]
 int c, ovflw, divisor, i;
     ^
support/squsq/sq.c:660:13: style: Unused variable: take [unusedVariable]
 char need, take; /* numbers of bits */
            ^
support/squsq/sq.c:768:6: style: Unused variable: i [unusedVariable]
 int i, c,c2;
     ^
support/squsq/sq.c:768:11: style: Unused variable: c2 [unusedVariable]
 int i, c,c2;
          ^
support/squsq/sq.c:856:6: style: Unused variable: x [unusedVariable]
 int x;
     ^
support/squsq/sq.c:918:8: style: Unused variable: c [unusedVariable]
 int i,c;
       ^
support/squsq/sq.c:176:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
support/squsq/sq.c:191:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
support/squsq/sq.c:904:3: style: Variable 'q' is assigned a value that is never used. [unreadVariable]
  --q;
  ^
support/squsq/usq.c:440:4: warning: Obsolete function 'gets' called. It is recommended to use 'fgets' or 'gets_s' instead. [getsCalled]
   gets(inparg);
   ^
support/squsq/usq.c:427:7: style: The scope of the variable 'inparg' can be reduced. [variableScope]
 char inparg[128]; /* parameter from input */
      ^
support/squsq/usq.c:121:33: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
if (temp & 0x8000) temp |= (~0) << 15; /* propogate sign for big ints */
                                ^
support/squsq/usq.c:157:6: style: Unused variable: bitval [unusedVariable]
 int bitval;
     ^
support/squsq/usq.c:389:11: style: Unused variable: cc [unusedVariable]
 char *q, cc;
          ^
support/squsq/usq.c:390:6: style: Unused variable: x [unusedVariable]
 int x;
     ^
support/squsq/usq.c:426:8: style: Unused variable: c [unusedVariable]
 int i,c;
       ^
support/ticalc/bin2var/bin2var.c:73:35: warning: The address of local variable 'i' might be accessed at non-zero index. [objectIndex]
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/ticalc/bin2var/bin2var.c:178:13: note: Address of variable taken here.
    cfwrite(&i, 1, fp, &chk);
            ^
support/ticalc/bin2var/bin2var.c:178:13: note: Calling function 'cfwrite', 1st argument '&i' value is lifetime=i
    cfwrite(&i, 1, fp, &chk);
            ^
support/ticalc/bin2var/bin2var.c:73:35: note: The address of local variable 'i' might be accessed at non-zero index.
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/ticalc/bin2var/bin2var.c:73:35: warning: The address of local variable 'i' might be accessed at non-zero index. [objectIndex]
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/ticalc/bin2var/bin2var.c:188:11: note: Address of variable taken here.
  cfwrite(&i, 2, fp, &chk);
          ^
support/ticalc/bin2var/bin2var.c:188:11: note: Calling function 'cfwrite', 1st argument '&i' value is lifetime=i
  cfwrite(&i, 2, fp, &chk);
          ^
support/ticalc/bin2var/bin2var.c:73:35: note: The address of local variable 'i' might be accessed at non-zero index.
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/ticalc/bin2var/bin2var.c:73:35: warning: The address of local variable 'i' might be accessed at non-zero index. [objectIndex]
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/ticalc/bin2var/bin2var.c:197:13: note: Address of variable taken here.
    cfwrite(&i, 1, fp, &chk);
            ^
support/ticalc/bin2var/bin2var.c:197:13: note: Calling function 'cfwrite', 1st argument '&i' value is lifetime=i
    cfwrite(&i, 1, fp, &chk);
            ^
support/ticalc/bin2var/bin2var.c:73:35: note: The address of local variable 'i' might be accessed at non-zero index.
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/ticalc/bin2var/bin2var.c:73:35: warning: The address of local variable 'i' might be accessed at non-zero index. [objectIndex]
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/ticalc/bin2var/bin2var.c:212:11: note: Address of variable taken here.
  cfwrite(&i, 2, fp, &chk);
          ^
support/ticalc/bin2var/bin2var.c:212:11: note: Calling function 'cfwrite', 1st argument '&i' value is lifetime=i
  cfwrite(&i, 2, fp, &chk);
          ^
support/ticalc/bin2var/bin2var.c:73:35: note: The address of local variable 'i' might be accessed at non-zero index.
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/ticalc/bin2var/bin2var.c:59:13: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  p = ftell(fp);
            ^
support/ticalc/bin2var/bin2var.c:140:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/ticalc/bin2var/bin2var.c:142:13: note: Calling function 'fsize', 1st argument 'fp' value is 0
  n = fsize(fp);
            ^
support/ticalc/bin2var/bin2var.c:59:13: note: Null pointer dereference
  p = ftell(fp);
            ^
support/ticalc/bin2var/bin2var.c:60:9: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  fseek(fp, 0L, SEEK_END);
        ^
support/ticalc/bin2var/bin2var.c:140:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/ticalc/bin2var/bin2var.c:142:13: note: Calling function 'fsize', 1st argument 'fp' value is 0
  n = fsize(fp);
            ^
support/ticalc/bin2var/bin2var.c:60:9: note: Null pointer dereference
  fseek(fp, 0L, SEEK_END);
        ^
support/ticalc/bin2var/bin2var.c:61:16: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  size = ftell(fp);
               ^
support/ticalc/bin2var/bin2var.c:140:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/ticalc/bin2var/bin2var.c:142:13: note: Calling function 'fsize', 1st argument 'fp' value is 0
  n = fsize(fp);
            ^
support/ticalc/bin2var/bin2var.c:61:16: note: Null pointer dereference
  size = ftell(fp);
               ^
support/ticalc/bin2var/bin2var.c:62:9: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  fseek(fp, p, SEEK_SET);
        ^
support/ticalc/bin2var/bin2var.c:140:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/ticalc/bin2var/bin2var.c:142:13: note: Calling function 'fsize', 1st argument 'fp' value is 0
  n = fsize(fp);
            ^
support/ticalc/bin2var/bin2var.c:62:9: note: Null pointer dereference
  fseek(fp, p, SEEK_SET);
        ^
support/ticalc/bin2var/bin2var.c:80:39: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  fwrite(comment, strlen(comment), 1, fp);
                                      ^
support/ticalc/bin2var/bin2var.c:149:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/ticalc/bin2var/bin2var.c:163:16: note: Calling function 'writecomment', 1st argument 'fp' value is 0
  writecomment(fp, comment);
               ^
support/ticalc/bin2var/bin2var.c:80:39: note: Null pointer dereference
  fwrite(comment, strlen(comment), 1, fp);
                                      ^
support/ticalc/bin2var/bin2var.c:82:40: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  fwrite(str, 42 - strlen(comment), 1, fp);
                                       ^
support/ticalc/bin2var/bin2var.c:149:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/ticalc/bin2var/bin2var.c:163:16: note: Calling function 'writecomment', 1st argument 'fp' value is 0
  writecomment(fp, comment);
               ^
support/ticalc/bin2var/bin2var.c:82:40: note: Null pointer dereference
  fwrite(str, 42 - strlen(comment), 1, fp);
                                       ^
support/ticalc/bin2var/bin2var.c:144:20: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  fread(buf, n, 1, fp);
                   ^
support/ticalc/bin2var/bin2var.c:140:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/ticalc/bin2var/bin2var.c:144:20: note: Null pointer dereference
  fread(buf, n, 1, fp);
                   ^
support/ticalc/bin2var/bin2var.c:145:14: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  if (ferror(fp))
             ^
support/ticalc/bin2var/bin2var.c:140:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/ticalc/bin2var/bin2var.c:145:14: note: Null pointer dereference
  if (ferror(fp))
             ^
support/ticalc/bin2var/bin2var.c:147:10: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  fclose(fp);
         ^
support/ticalc/bin2var/bin2var.c:140:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/ticalc/bin2var/bin2var.c:147:10: note: Null pointer dereference
  fclose(fp);
         ^
support/ticalc/bin2var/bin2var.c:40:11: style: The scope of the variable 'argptr' can be reduced. [variableScope]
  va_list argptr;
          ^
support/ticalc/bin2var/bin2var.c:112:25: style: Unused variable: c [unusedVariable]
  char *buf, str[256], *c;
                        ^
support/ticalc/bin2var/bin2var2.c:86:18: error: Array 'charbuffer[1]' accessed at index 1, which is out of bounds. [arrayIndexOutOfBounds]
   if( charbuffer[1] == 0 )
                 ^
support/ticalc/bin2var/bin2var2.c:88:15: error: Array 'charbuffer[1]' accessed at index 1, which is out of bounds. [arrayIndexOutOfBounds]
    charbuffer[1] = charbuffer[0];
              ^
support/ticalc/bin2var/bin2var2.c:95:22: error: Array 'charbuffer[1]' accessed at index 1, which is out of bounds. [arrayIndexOutOfBounds]
   *chk += charbuffer[1];
                     ^
support/ticalc/bin2var/bin2var2.c:74:35: warning: The address of local variable 'i' might be accessed at non-zero index. [objectIndex]
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/ticalc/bin2var/bin2var2.c:205:13: note: Address of variable taken here.
    cfwrite(&i, 1, fp, &chk);
            ^
support/ticalc/bin2var/bin2var2.c:205:13: note: Calling function 'cfwrite', 1st argument '&i' value is lifetime=i
    cfwrite(&i, 1, fp, &chk);
            ^
support/ticalc/bin2var/bin2var2.c:74:35: note: The address of local variable 'i' might be accessed at non-zero index.
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/ticalc/bin2var/bin2var2.c:74:35: warning: The address of local variable 'i' might be accessed at non-zero index. [objectIndex]
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/ticalc/bin2var/bin2var2.c:217:11: note: Address of variable taken here.
  cfwrite(&i, 2, fp, &chk);
          ^
support/ticalc/bin2var/bin2var2.c:217:11: note: Calling function 'cfwrite', 1st argument '&i' value is lifetime=i
  cfwrite(&i, 2, fp, &chk);
          ^
support/ticalc/bin2var/bin2var2.c:74:35: note: The address of local variable 'i' might be accessed at non-zero index.
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/ticalc/bin2var/bin2var2.c:74:35: warning: The address of local variable 'i' might be accessed at non-zero index. [objectIndex]
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/ticalc/bin2var/bin2var2.c:226:13: note: Address of variable taken here.
    cfwrite(&i, 1, fp, &chk);
            ^
support/ticalc/bin2var/bin2var2.c:226:13: note: Calling function 'cfwrite', 1st argument '&i' value is lifetime=i
    cfwrite(&i, 1, fp, &chk);
            ^
support/ticalc/bin2var/bin2var2.c:74:35: note: The address of local variable 'i' might be accessed at non-zero index.
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/ticalc/bin2var/bin2var2.c:74:35: warning: The address of local variable 'i' might be accessed at non-zero index. [objectIndex]
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/ticalc/bin2var/bin2var2.c:246:11: note: Address of variable taken here.
  cfwrite(&i, 2, fp, &chk);
          ^
support/ticalc/bin2var/bin2var2.c:246:11: note: Calling function 'cfwrite', 1st argument '&i' value is lifetime=i
  cfwrite(&i, 2, fp, &chk);
          ^
support/ticalc/bin2var/bin2var2.c:74:35: note: The address of local variable 'i' might be accessed at non-zero index.
    *chk += ((unsigned char *)buf)[i];
                                  ^
support/ticalc/bin2var/bin2var2.c:60:13: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  p = ftell(fp);
            ^
support/ticalc/bin2var/bin2var2.c:165:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/ticalc/bin2var/bin2var2.c:167:13: note: Calling function 'fsize', 1st argument 'fp' value is 0
  n = fsize(fp);
            ^
support/ticalc/bin2var/bin2var2.c:60:13: note: Null pointer dereference
  p = ftell(fp);
            ^
support/ticalc/bin2var/bin2var2.c:61:9: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  fseek(fp, 0L, SEEK_END);
        ^
support/ticalc/bin2var/bin2var2.c:165:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/ticalc/bin2var/bin2var2.c:167:13: note: Calling function 'fsize', 1st argument 'fp' value is 0
  n = fsize(fp);
            ^
support/ticalc/bin2var/bin2var2.c:61:9: note: Null pointer dereference
  fseek(fp, 0L, SEEK_END);
        ^
support/ticalc/bin2var/bin2var2.c:62:16: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  size = ftell(fp);
               ^
support/ticalc/bin2var/bin2var2.c:165:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/ticalc/bin2var/bin2var2.c:167:13: note: Calling function 'fsize', 1st argument 'fp' value is 0
  n = fsize(fp);
            ^
support/ticalc/bin2var/bin2var2.c:62:16: note: Null pointer dereference
  size = ftell(fp);
               ^
support/ticalc/bin2var/bin2var2.c:63:9: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  fseek(fp, p, SEEK_SET);
        ^
support/ticalc/bin2var/bin2var2.c:165:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/ticalc/bin2var/bin2var2.c:167:13: note: Calling function 'fsize', 1st argument 'fp' value is 0
  n = fsize(fp);
            ^
support/ticalc/bin2var/bin2var2.c:63:9: note: Null pointer dereference
  fseek(fp, p, SEEK_SET);
        ^
support/ticalc/bin2var/bin2var2.c:105:39: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  fwrite(comment, strlen(comment), 1, fp);
                                      ^
support/ticalc/bin2var/bin2var2.c:174:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/ticalc/bin2var/bin2var2.c:188:16: note: Calling function 'writecomment', 1st argument 'fp' value is 0
  writecomment(fp, comment);
               ^
support/ticalc/bin2var/bin2var2.c:105:39: note: Null pointer dereference
  fwrite(comment, strlen(comment), 1, fp);
                                      ^
support/ticalc/bin2var/bin2var2.c:107:40: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  fwrite(str, 42 - strlen(comment), 1, fp);
                                       ^
support/ticalc/bin2var/bin2var2.c:174:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/ticalc/bin2var/bin2var2.c:188:16: note: Calling function 'writecomment', 1st argument 'fp' value is 0
  writecomment(fp, comment);
               ^
support/ticalc/bin2var/bin2var2.c:107:40: note: Null pointer dereference
  fwrite(str, 42 - strlen(comment), 1, fp);
                                       ^
support/ticalc/bin2var/bin2var2.c:169:20: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  fread(buf, n, 1, fp);
                   ^
support/ticalc/bin2var/bin2var2.c:165:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/ticalc/bin2var/bin2var2.c:169:20: note: Null pointer dereference
  fread(buf, n, 1, fp);
                   ^
support/ticalc/bin2var/bin2var2.c:170:14: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  if (ferror(fp))
             ^
support/ticalc/bin2var/bin2var2.c:165:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/ticalc/bin2var/bin2var2.c:170:14: note: Null pointer dereference
  if (ferror(fp))
             ^
support/ticalc/bin2var/bin2var2.c:172:10: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  fclose(fp);
         ^
support/ticalc/bin2var/bin2var2.c:165:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/ticalc/bin2var/bin2var2.c:172:10: note: Null pointer dereference
  fclose(fp);
         ^
support/ticalc/bin2var/bin2var2.c:199:20: warning: Either the condition '!fp' is redundant or there is possible null pointer dereference: fp. [nullPointerRedundantCheck]
  fwrite(&i, 2, 1, fp);
                   ^
support/ticalc/bin2var/bin2var2.c:174:7: note: Assuming that condition '!fp' is not redundant
  if (!fp)
      ^
support/ticalc/bin2var/bin2var2.c:199:20: note: Null pointer dereference
  fwrite(&i, 2, 1, fp);
                   ^
support/ticalc/bin2var/bin2var2.c:41:11: style: The scope of the variable 'argptr' can be reduced. [variableScope]
  va_list argptr;
          ^
support/ticalc/bin2var/bin2var2.c:79:10: style: The scope of the variable 'n' can be reduced. [variableScope]
  int i, n;
         ^
support/ticalc/bin2var/bin2var2.c:81:9: style: The scope of the variable 'charbufferp' can be reduced. [variableScope]
  char *charbufferp;
        ^
support/ticalc/bin2var/bin2var2.c:137:25: style: Unused variable: c [unusedVariable]
  char *buf, str[256], *c;
                        ^
support/trs80/cas.c:83:7: style: Variable 'a' is reassigned a value before the old one has been used. [redundantAssignment]
    a = addr&0xFF;
      ^
support/trs80/cas.c:81:7: note: a is assigned
    a = blocksize;
      ^
support/trs80/cas.c:83:7: note: a is overwritten
    a = addr&0xFF;
      ^
support/trs80/cmd.c:44:17: portability: %i in format string (no. 3) requires 'int' but the argument type is 'long int {aka signed long}'. [invalidPrintfArgType_sint]
                fprintf( stdout, "unsupported block type %i of size %i, at offset: %i.\n",
                ^
support/trs80/cmd.c:28:16: style: The scope of the variable 'count' can be reduced. [variableScope]
    int btype, count, c, i, j = 0;
               ^
support/trs80/cmd.c:28:23: style: The scope of the variable 'c' can be reduced. [variableScope]
    int btype, count, c, i, j = 0;
                      ^
support/trs80/cmd.c:28:9: style: Unused variable: btype [unusedVariable]
    int btype, count, c, i, j = 0;
        ^
support/trs80/cmd.c:28:26: style: Unused variable: i [unusedVariable]
    int btype, count, c, i, j = 0;
                         ^
support/trs80/main.c:74:9: portability: %i in format string (no. 1) requires 'int' but the argument type is 'long int {aka signed long}'. [invalidPrintfArgType_sint]
        printf( "Conversion ready. CAS file size: %i bytes\n", ftell(cas));
        ^
support/trs80/main.c:60:13: error: Resource leak: cmd [resourceLeak]
            return 2;
            ^
support/trs80/main.c:42:19: style: Variable 'ck' is assigned a value that is never used. [unreadVariable]
 unsigned char ck = 0;
                  ^
support/trs80/main.c:41:8: style: Unused variable: inp [unusedVariable]
 FILE *inp, *outp;
       ^
support/trs80/main.c:41:14: style: Unused variable: outp [unusedVariable]
 FILE *inp, *outp;
             ^
support/zx/bin2bas-rem.c:119:3: style: Variable 'c' is reassigned a value before the old one has been used. [redundantAssignment]
 c=getc(fpin);
  ^
support/zx/bin2bas-rem.c:118:3: note: c is assigned
 c=getc(fpin);
  ^
support/zx/bin2bas-rem.c:119:3: note: c is overwritten
 c=getc(fpin);
  ^
support/zx/bin2bas-rem.c:120:3: style: Variable 'c' is reassigned a value before the old one has been used. [redundantAssignment]
 c=getc(fpin);
  ^
support/zx/bin2bas-rem.c:119:3: note: c is assigned
 c=getc(fpin);
  ^
support/zx/bin2bas-rem.c:120:3: note: c is overwritten
 c=getc(fpin);
  ^
support/zx/bin2bas-rem.c:121:3: style: Variable 'c' is reassigned a value before the old one has been used. [redundantAssignment]
 c=getc(fpin);
  ^
support/zx/bin2bas-rem.c:120:3: note: c is assigned
 c=getc(fpin);
  ^
support/zx/bin2bas-rem.c:121:3: note: c is overwritten
 c=getc(fpin);
  ^
support/zx/bin2bas-rem.c:121:3: style: Variable 'c' is assigned a value that is never used. [unreadVariable]
 c=getc(fpin);
  ^
support/zx/bin2bas-rem.c:47:7: style: Unused variable: name [unusedVariable]
 char name[11];
      ^
support/zx/bin2bas-rem.c:48:7: style: Unused variable: mybuf [unusedVariable]
 char mybuf[20];
      ^
support/zx/tapmaker.c:30:6: style: The scope of the variable 'c' can be reduced. [variableScope]
 int c;
     ^
test/feature/feature.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 15 configurations. Use --force to check all configurations. [toomanyconfigs]

^
test/feature/feature.c:15:9: style: Unused variable: buf [unusedVariable]
   char buf[10];
        ^
test/feature/feature.c:16:9: style: Unused variable: c [unusedVariable]
   int  c;
        ^
test/feature/feature.c:20:6: style: Variable 'c' is assigned a value that is never used. [unreadVariable]
   c = fgetc_cons();
     ^
test/feature/feature.c:22:6: style: Variable 'c' is reassigned a value before the old one has been used. [redundantAssignment]
   c = getk();
     ^
test/feature/feature.c:20:6: note: c is assigned
   c = fgetc_cons();
     ^
test/feature/feature.c:22:6: note: c is overwritten
   c = getk();
     ^
test/feature/feature.c:22:6: style: Variable 'c' is assigned a value that is never used. [unreadVariable]
   c = getk();
     ^
test/feature/feature.c:47:4: warning: Return value of function fopen() is not used. [ignoredReturnValue]
   fopen("asfsf","r");
   ^
test/feature/feature.c:47:4: error: Return value of allocation function 'fopen' is not stored. [leakReturnValNotUsed]
   fopen("asfsf","r");
   ^
test/feature/feature.c:49:11: error: Null pointer dereference [nullPointer]
   fclose(NULL);
          ^
test/feature/feature.c:48:6: style: Variable 'c' is assigned a value that is never used. [unreadVariable]
   c = read(0, buf, 0);
     ^
test/feature/feature.c:27:6: style: Variable 'c' is reassigned a value before the old one has been used. [redundantAssignment]
   c = in_KeyPressed(2);
     ^
test/feature/feature.c:26:6: note: c is assigned
   c = in_LookupKey('2');
     ^
test/feature/feature.c:27:6: note: c is overwritten
   c = in_KeyPressed(2);
     ^
test/feature/feature.c:28:6: style: Variable 'c' is reassigned a value before the old one has been used. [redundantAssignment]
   c = in_Inkey();
     ^
test/feature/feature.c:27:6: note: c is assigned
   c = in_KeyPressed(2);
     ^
test/feature/feature.c:28:6: note: c is overwritten
   c = in_Inkey();
     ^
test/feature/feature.c:28:6: style: Variable 'c' is assigned a value that is never used. [unreadVariable]
   c = in_Inkey();
     ^
test/feature/feature.c:52:6: style: Variable 'c' is assigned a value that is never used. [unreadVariable]
   c = joystick(1);
     ^
test/feature/feature.c:54:14: style: Variable 'd' is assigned a value that is never used. [unreadVariable]
     char *d = joystick_type[0];
             ^
test/machine/Z80/rcmx_io.c:87:2: style: Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]
 break;
 ^
test/machine/hook_io.c:50:19: error: Array 'slots[256]' accessed at index 1023, which is out of bounds. [arrayIndexOutOfBounds]
        if ( slots[i] == 0 ) {
                  ^
test/machine/hook_io.c:190:14: error: Array 'slots[256]' accessed at index 1023, which is out of bounds. [arrayIndexOutOfBounds]
        slots[i] = -1;
             ^
test/machine/main.c:42:11: style: Unused variable: val [unusedVariable]
    int   val;
          ^
test/suites/ctype/create.c:13:13: style: The scope of the variable 'ident' can be reduced. [variableScope]
    char    ident[20];
            ^
test/suites/ctype/create.c:14:13: style: The scope of the variable 'fname' can be reduced. [variableScope]
    char    fname[100];
            ^
test/suites/ctype/create.c:16:13: style: The scope of the variable 'i' can be reduced. [variableScope]
    int     i,res;
            ^
test/suites/ctype/create.c:16:15: style: The scope of the variable 'res' can be reduced. [variableScope]
    int     i,res;
              ^
test/suites/ctype/main.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 15 configurations. Use --force to check all configurations. [toomanyconfigs]

^
test/suites/md5/md5sum.c:410:8: style: The scope of the variable 'size' can be reduced. [variableScope]
   int size;
       ^
test/suites/md5/md5sum.c:378:20: error: va_list 'v' was opened but not closed by va_end(). [va_end_missing]
   return (int)ebuf;
                   ^
test/suites/regex/regex.c:36:15: style: The scope of the variable 're' can be reduced. [variableScope]
    regexp   *re;
              ^
test/suites/regex/regex.c:37:15: style: The scope of the variable 'result' can be reduced. [variableScope]
    int       result;
              ^
test/suites/sccz80/bitfields.c:223:16: style: Variable 'size2b_bf.b0' is reassigned a value before the old one has been used. [redundantAssignment]
  size2b_bf.b0 = c;
               ^
test/suites/sccz80/bitfields.c:210:16: note: size2b_bf.b0 is assigned
  size2b_bf.b0 = c;
               ^
test/suites/sccz80/bitfields.c:223:16: note: size2b_bf.b0 is overwritten
  size2b_bf.b0 = c;
               ^
test/suites/sccz80/bitwise.h:66:9: style: Condition 'a&0x4321' is always true [knownConditionTrueFalse]
  if (a & 0x4321)
        ^
test/suites/sccz80/bitwise.h:64:7: note: Assignment 'a=0x1234', assigned value is 4660
  a = 0x1234;
      ^
test/suites/sccz80/bitwise.h:66:9: note: Condition 'a&0x4321' is always true
  if (a & 0x4321)
        ^
test/suites/sccz80/bitwise.h:72:9: style: Condition 'a&0x4321' is always true [knownConditionTrueFalse]
  if (a & 0x4321)
        ^
test/suites/sccz80/bitwise.h:64:7: note: Assignment 'a=0x1234', assigned value is 4660
  a = 0x1234;
      ^
test/suites/sccz80/bitwise.h:72:9: note: Condition 'a&0x4321' is always true
  if (a & 0x4321)
        ^
test/suites/sccz80/bitwise.h:79:7: style: Condition '!(a&0x4321)' is always false [knownConditionTrueFalse]
  if (!(a & 0x4321))
      ^
test/suites/sccz80/bitwise.h:64:7: note: Assignment 'a=0x1234', assigned value is 4660
  a = 0x1234;
      ^
test/suites/sccz80/bitwise.h:79:7: note: Condition '!(a&0x4321)' is always false
  if (!(a & 0x4321))
      ^
test/suites/sccz80/bitwise.h:85:7: style: Condition '!(a&0x4321)' is always false [knownConditionTrueFalse]
  if (!(a & 0x4321))
      ^
test/suites/sccz80/bitwise.h:64:7: note: Assignment 'a=0x1234', assigned value is 4660
  a = 0x1234;
      ^
test/suites/sccz80/bitwise.h:85:7: note: Condition '!(a&0x4321)' is always false
  if (!(a & 0x4321))
      ^
test/suites/sccz80/bitwise.h:95:9: style: Condition 'a&0x1004' is always true [knownConditionTrueFalse]
  if (a & 0x1004)
        ^
test/suites/sccz80/bitwise.h:93:7: note: Assignment 'a=0xffff', assigned value is 65535
  a = 0xffff;
      ^
test/suites/sccz80/bitwise.h:95:9: note: Condition 'a&0x1004' is always true
  if (a & 0x1004)
        ^
test/suites/sccz80/bitwise.h:101:7: style: Condition '!(a&0x1004)' is always false [knownConditionTrueFalse]
  if (!(a & 0x1004))
      ^
test/suites/sccz80/bitwise.h:93:7: note: Assignment 'a=0xffff', assigned value is 65535
  a = 0xffff;
      ^
test/suites/sccz80/bitwise.h:101:7: note: Condition '!(a&0x1004)' is always false
  if (!(a & 0x1004))
      ^
test/suites/sccz80/bitwise.h:109:9: style: Condition 'a&0x1004' is always false [knownConditionTrueFalse]
  if (a & 0x1004)
        ^
test/suites/sccz80/bitwise.h:107:7: note: Assignment 'a=0x0000', assigned value is 0
  a = 0x0000;
      ^
test/suites/sccz80/bitwise.h:109:9: note: Condition 'a&0x1004' is always false
  if (a & 0x1004)
        ^
test/suites/sccz80/bitwise.h:115:7: style: Condition '!(a&0x1004)' is always true [knownConditionTrueFalse]
  if (!(a & 0x1004))
      ^
test/suites/sccz80/bitwise.h:107:7: note: Assignment 'a=0x0000', assigned value is 0
  a = 0x0000;
      ^
test/suites/sccz80/bitwise.h:115:7: note: Condition '!(a&0x1004)' is always true
  if (!(a & 0x1004))
      ^
test/suites/sccz80/bitwise.h:123:9: style: Condition 'a&0x1004' is always true [knownConditionTrueFalse]
  if (a & 0x1004)
        ^
test/suites/sccz80/bitwise.h:121:7: note: Assignment 'a=0x00ff', assigned value is 255
  a = 0x00ff;
      ^
test/suites/sccz80/bitwise.h:123:9: note: Condition 'a&0x1004' is always true
  if (a & 0x1004)
        ^
test/suites/sccz80/bitwise.h:129:7: style: Condition '!(a&0x1004)' is always false [knownConditionTrueFalse]
  if (!(a & 0x1004))
      ^
test/suites/sccz80/bitwise.h:121:7: note: Assignment 'a=0x00ff', assigned value is 255
  a = 0x00ff;
      ^
test/suites/sccz80/bitwise.h:129:7: note: Condition '!(a&0x1004)' is always false
  if (!(a & 0x1004))
      ^
test/suites/sccz80/bitwise.h:137:9: style: Condition 'a&0x1004' is always true [knownConditionTrueFalse]
  if (a & 0x1004)
        ^
test/suites/sccz80/bitwise.h:135:7: note: Assignment 'a=0xff00', assigned value is 65280
  a = 0xff00;
      ^
test/suites/sccz80/bitwise.h:137:9: note: Condition 'a&0x1004' is always true
  if (a & 0x1004)
        ^
test/suites/sccz80/bitwise.h:143:7: style: Condition '!(a&0x1004)' is always false [knownConditionTrueFalse]
  if (!(a & 0x1004))
      ^
test/suites/sccz80/bitwise.h:135:7: note: Assignment 'a=0xff00', assigned value is 65280
  a = 0xff00;
      ^
test/suites/sccz80/bitwise.h:143:7: note: Condition '!(a&0x1004)' is always false
  if (!(a & 0x1004))
      ^
test/suites/sccz80/bitwise.h:152:9: style: Condition 'a&0x4300' is always true [knownConditionTrueFalse]
  if (a & 0x4300)
        ^
test/suites/sccz80/bitwise.h:150:7: note: Assignment 'a=0x1234', assigned value is 4660
  a = 0x1234;
      ^
test/suites/sccz80/bitwise.h:152:9: note: Condition 'a&0x4300' is always true
  if (a & 0x4300)
        ^
test/suites/sccz80/bitwise.h:157:9: style: Condition 'a&0x0012' is always true [knownConditionTrueFalse]
  if (a & 0x0012)
        ^
test/suites/sccz80/bitwise.h:150:7: note: Assignment 'a=0x1234', assigned value is 4660
  a = 0x1234;
      ^
test/suites/sccz80/bitwise.h:157:9: note: Condition 'a&0x0012' is always true
  if (a & 0x0012)
        ^
test/suites/sccz80/bitwise.h:163:7: style: Condition '!(a&0x4300)' is always false [knownConditionTrueFalse]
  if (!(a & 0x4300))
      ^
test/suites/sccz80/bitwise.h:150:7: note: Assignment 'a=0x1234', assigned value is 4660
  a = 0x1234;
      ^
test/suites/sccz80/bitwise.h:163:7: note: Condition '!(a&0x4300)' is always false
  if (!(a & 0x4300))
      ^
test/suites/sccz80/bitwise.h:169:7: style: Condition '!(a&0x0012)' is always false [knownConditionTrueFalse]
  if (!(a & 0x0012))
      ^
test/suites/sccz80/bitwise.h:150:7: note: Assignment 'a=0x1234', assigned value is 4660
  a = 0x1234;
      ^
test/suites/sccz80/bitwise.h:169:7: note: Condition '!(a&0x0012)' is always false
  if (!(a & 0x0012))
      ^
test/suites/sccz80/bitwise.h:189:9: style: Condition 'a|0x4321' is always true [knownConditionTrueFalse]
  if (a | 0x4321)
        ^
test/suites/sccz80/bitwise.h:183:20: note: Assignment 'a=0x1234', assigned value is 4660
  volatile int a = 0x1234;
                   ^
test/suites/sccz80/bitwise.h:189:9: note: Condition 'a|0x4321' is always true
  if (a | 0x4321)
        ^
test/suites/sccz80/bitwise.h:196:7: style: Condition '!(a|0x4321)' is always false [knownConditionTrueFalse]
  if (!(a | 0x4321))
      ^
test/suites/sccz80/bitwise.h:183:20: note: Assignment 'a=0x1234', assigned value is 4660
  volatile int a = 0x1234;
                   ^
test/suites/sccz80/bitwise.h:196:7: note: Condition '!(a|0x4321)' is always false
  if (!(a | 0x4321))
      ^
test/suites/sccz80/bitwise.h:202:9: style: Condition 'a|0x4321' is always true [knownConditionTrueFalse]
  if (a | 0x4321)
        ^
test/suites/sccz80/bitwise.h:183:20: note: Assignment 'a=0x1234', assigned value is 4660
  volatile int a = 0x1234;
                   ^
test/suites/sccz80/bitwise.h:202:9: note: Condition 'a|0x4321' is always true
  if (a | 0x4321)
        ^
test/suites/sccz80/bitwise.h:208:7: style: Condition '!(a|0x4321)' is always false [knownConditionTrueFalse]
  if (!(a | 0x4321))
      ^
test/suites/sccz80/bitwise.h:183:20: note: Assignment 'a=0x1234', assigned value is 4660
  volatile int a = 0x1234;
                   ^
test/suites/sccz80/bitwise.h:208:7: note: Condition '!(a|0x4321)' is always false
  if (!(a | 0x4321))
      ^
test/suites/sccz80/bitwise.h:217:9: style: Condition 'a|0' is always true [knownConditionTrueFalse]
  if (a | 0)
        ^
test/suites/sccz80/bitwise.h:183:20: note: Assignment 'a=0x1234', assigned value is 4660
  volatile int a = 0x1234;
                   ^
test/suites/sccz80/bitwise.h:217:9: note: Condition 'a|0' is always true
  if (a | 0)
        ^
test/suites/sccz80/bitwise.h:226:7: style: Condition '!(a|0)' is always false [knownConditionTrueFalse]
  if (!(a | 0))
      ^
test/suites/sccz80/bitwise.h:183:20: note: Assignment 'a=0x1234', assigned value is 4660
  volatile int a = 0x1234;
                   ^
test/suites/sccz80/bitwise.h:226:7: note: Condition '!(a|0)' is always false
  if (!(a | 0))
      ^
test/suites/sccz80/bitwise.h:233:9: style: Condition 'a|0' is always true [knownConditionTrueFalse]
  if (a | 0)
        ^
test/suites/sccz80/bitwise.h:183:20: note: Assignment 'a=0x1234', assigned value is 4660
  volatile int a = 0x1234;
                   ^
test/suites/sccz80/bitwise.h:233:9: note: Condition 'a|0' is always true
  if (a | 0)
        ^
test/suites/sccz80/bitwise.h:239:7: style: Condition '!(a|0)' is always false [knownConditionTrueFalse]
  if (!(a | 0))
      ^
test/suites/sccz80/bitwise.h:183:20: note: Assignment 'a=0x1234', assigned value is 4660
  volatile int a = 0x1234;
                   ^
test/suites/sccz80/bitwise.h:239:7: note: Condition '!(a|0)' is always false
  if (!(a | 0))
      ^
test/suites/sccz80/bitwise.h:254:9: style: Condition 'a^0x4321' is always true [knownConditionTrueFalse]
  if (a ^ 0x4321)
        ^
test/suites/sccz80/bitwise.h:249:20: note: Assignment 'a=0x1234', assigned value is 4660
  volatile int a = 0x1234;
                   ^
test/suites/sccz80/bitwise.h:254:9: note: Condition 'a^0x4321' is always true
  if (a ^ 0x4321)
        ^
test/suites/sccz80/bitwise.h:260:9: style: Condition 'a^0x4321' is always true [knownConditionTrueFalse]
  if (a ^ 0x4321)
        ^
test/suites/sccz80/bitwise.h:249:20: note: Assignment 'a=0x1234', assigned value is 4660
  volatile int a = 0x1234;
                   ^
test/suites/sccz80/bitwise.h:260:9: note: Condition 'a^0x4321' is always true
  if (a ^ 0x4321)
        ^
test/suites/sccz80/bitwise.h:266:7: style: Condition '!(a^0x4321)' is always false [knownConditionTrueFalse]
  if (!(a ^ 0x4321))
      ^
test/suites/sccz80/bitwise.h:249:20: note: Assignment 'a=0x1234', assigned value is 4660
  volatile int a = 0x1234;
                   ^
test/suites/sccz80/bitwise.h:266:7: note: Condition '!(a^0x4321)' is always false
  if (!(a ^ 0x4321))
      ^
test/suites/sccz80/bitwise.h:272:7: style: Condition '!(a^0x4321)' is always false [knownConditionTrueFalse]
  if (!(a ^ 0x4321))
      ^
test/suites/sccz80/bitwise.h:249:20: note: Assignment 'a=0x1234', assigned value is 4660
  volatile int a = 0x1234;
                   ^
test/suites/sccz80/bitwise.h:272:7: note: Condition '!(a^0x4321)' is always false
  if (!(a ^ 0x4321))
      ^
test/suites/sccz80/bitwise.h:280:9: style: Condition 'a^0xff04' is always true [knownConditionTrueFalse]
  if (a ^ 0xff04)
        ^
test/suites/sccz80/bitwise.h:249:20: note: Assignment 'a=0x1234', assigned value is 4660
  volatile int a = 0x1234;
                   ^
test/suites/sccz80/bitwise.h:280:9: note: Condition 'a^0xff04' is always true
  if (a ^ 0xff04)
        ^
test/suites/sccz80/bitwise.h:286:7: style: Condition '!(a^0xff04)' is always false [knownConditionTrueFalse]
  if (!(a ^ 0xff04))
      ^
test/suites/sccz80/bitwise.h:249:20: note: Assignment 'a=0x1234', assigned value is 4660
  volatile int a = 0x1234;
                   ^
test/suites/sccz80/bitwise.h:286:7: note: Condition '!(a^0xff04)' is always false
  if (!(a ^ 0xff04))
      ^
test/suites/sccz80/bitwise.h:293:9: style: Condition 'a^0x0004' is always true [knownConditionTrueFalse]
  if (a ^ 0x0004)
        ^
test/suites/sccz80/bitwise.h:249:20: note: Assignment 'a=0x1234', assigned value is 4660
  volatile int a = 0x1234;
                   ^
test/suites/sccz80/bitwise.h:293:9: note: Condition 'a^0x0004' is always true
  if (a ^ 0x0004)
        ^
test/suites/sccz80/bitwise.h:299:7: style: Condition '!(a^0x0004)' is always false [knownConditionTrueFalse]
  if (!(a ^ 0x0004))
      ^
test/suites/sccz80/bitwise.h:249:20: note: Assignment 'a=0x1234', assigned value is 4660
  volatile int a = 0x1234;
                   ^
test/suites/sccz80/bitwise.h:299:7: note: Condition '!(a^0x0004)' is always false
  if (!(a ^ 0x0004))
      ^
test/suites/sccz80/bitwise.h:189:9: warning: Result of operator '|' is always true if one operand is non-zero. Did you intend to use '&'? [badBitmaskCheck]
  if (a | 0x4321)
        ^
test/suites/sccz80/bitwise.h:202:9: warning: Result of operator '|' is always true if one operand is non-zero. Did you intend to use '&'? [badBitmaskCheck]
  if (a | 0x4321)
        ^
test/suites/sccz80/bitwise.h:217:9: warning: Result of operator '|' is always true if one operand is non-zero. Did you intend to use '&'? [badBitmaskCheck]
  if (a | 0)
        ^
test/suites/sccz80/bitwise.h:233:9: warning: Result of operator '|' is always true if one operand is non-zero. Did you intend to use '&'? [badBitmaskCheck]
  if (a | 0)
        ^
test/suites/sccz80/callee.c:14:12: style: Unused variable: a [unusedVariable]
    double a,b,c;
           ^
test/suites/sccz80/callee.c:14:14: style: Unused variable: b [unusedVariable]
    double a,b,c;
             ^
test/suites/sccz80/callee.c:14:16: style: Unused variable: c [unusedVariable]
    double a,b,c;
               ^
test/suites/sccz80/callee.c:23:12: style: Unused variable: a [unusedVariable]
    double a,b,c;
           ^
test/suites/sccz80/callee.c:23:14: style: Unused variable: b [unusedVariable]
    double a,b,c;
             ^
test/suites/sccz80/callee.c:23:16: style: Unused variable: c [unusedVariable]
    double a,b,c;
               ^
test/suites/sccz80/callee.c:32:12: style: Unused variable: a [unusedVariable]
    double a,b,c;
           ^
test/suites/sccz80/callee.c:32:14: style: Unused variable: b [unusedVariable]
    double a,b,c;
             ^
test/suites/sccz80/callee.c:32:16: style: Unused variable: c [unusedVariable]
    double a,b,c;
               ^
test/suites/sccz80/callee2.c:56:20: error: Uninitialized variable: func [uninitvar]
   long long ret = func(3,5);
                   ^
test/suites/sccz80/callee2.c:73:20: error: Uninitialized variable: func [uninitvar]
   long long ret = func(3,5);
                   ^
test/suites/sccz80/compare.c:46:12: style: Condition 'a<b' is always true [knownConditionTrueFalse]
    if ( a < b ) {} else { Assert(0, "a < b"); }
           ^
test/suites/sccz80/compare.c:42:23: note: Assignment 'a=10', assigned value is 10
    unsigned int  a = 10;
                      ^
test/suites/sccz80/compare.c:46:12: note: Condition 'a<b' is always true
    if ( a < b ) {} else { Assert(0, "a < b"); }
           ^
test/suites/sccz80/compare.c:48:12: style: Condition 'a<=b' is always true [knownConditionTrueFalse]
    if ( a <= b ) {} else { Assert(0, "a <= b"); }
           ^
test/suites/sccz80/compare.c:42:23: note: Assignment 'a=10', assigned value is 10
    unsigned int  a = 10;
                      ^
test/suites/sccz80/compare.c:48:12: note: Condition 'a<=b' is always true
    if ( a <= b ) {} else { Assert(0, "a <= b"); }
           ^
test/suites/sccz80/compare.c:50:12: style: Condition 'a!=b' is always true [knownConditionTrueFalse]
    if ( a != b ) {} else { Assert(0, "a != b"); }
           ^
test/suites/sccz80/compare.c:42:23: note: Assignment 'a=10', assigned value is 10
    unsigned int  a = 10;
                      ^
test/suites/sccz80/compare.c:50:12: note: Condition 'a!=b' is always true
    if ( a != b ) {} else { Assert(0, "a != b"); }
           ^
test/suites/sccz80/compare.c:54:12: style: Condition 'b>a' is always true [knownConditionTrueFalse]
    if ( b > a ) {} else { Assert(0, "b > a"); }
           ^
test/suites/sccz80/compare.c:43:23: note: Assignment 'b=20', assigned value is 20
    unsigned int  b = 20;
                      ^
test/suites/sccz80/compare.c:54:12: note: Condition 'b>a' is always true
    if ( b > a ) {} else { Assert(0, "b > a"); }
           ^
test/suites/sccz80/compare.c:56:12: style: Condition 'b>=a' is always true [knownConditionTrueFalse]
    if ( b >= a ) {} else { Assert(0, "b >= a"); }
           ^
test/suites/sccz80/compare.c:43:23: note: Assignment 'b=20', assigned value is 20
    unsigned int  b = 20;
                      ^
test/suites/sccz80/compare.c:56:12: note: Condition 'b>=a' is always true
    if ( b >= a ) {} else { Assert(0, "b >= a"); }
           ^
test/suites/sccz80/compare.c:66:12: style: Condition 'a<b' is always true [knownConditionTrueFalse]
    if ( a < b ) {} else { Assert(0, "a < b"); }
           ^
test/suites/sccz80/compare.c:62:16: note: Assignment 'a=-10', assigned value is -10
    long  a = -10;
               ^
test/suites/sccz80/compare.c:66:12: note: Condition 'a<b' is always true
    if ( a < b ) {} else { Assert(0, "a < b"); }
           ^
test/suites/sccz80/compare.c:68:12: style: Condition 'a<=b' is always true [knownConditionTrueFalse]
    if ( a <= b ) {} else { Assert(0, "a <= b"); }
           ^
test/suites/sccz80/compare.c:62:16: note: Assignment 'a=-10', assigned value is -10
    long  a = -10;
               ^
test/suites/sccz80/compare.c:68:12: note: Condition 'a<=b' is always true
    if ( a <= b ) {} else { Assert(0, "a <= b"); }
           ^
test/suites/sccz80/compare.c:70:12: style: Condition 'a!=b' is always true [knownConditionTrueFalse]
    if ( a != b ) {} else { Assert(0, "a != b"); }
           ^
test/suites/sccz80/compare.c:62:16: note: Assignment 'a=-10', assigned value is -10
    long  a = -10;
               ^
test/suites/sccz80/compare.c:70:12: note: Condition 'a!=b' is always true
    if ( a != b ) {} else { Assert(0, "a != b"); }
           ^
test/suites/sccz80/compare.c:74:12: style: Condition 'b>a' is always true [knownConditionTrueFalse]
    if ( b > a ) {} else { Assert(0, "b > a"); }
           ^
test/suites/sccz80/compare.c:63:15: note: Assignment 'b=20', assigned value is 20
    long  b = 20;
              ^
test/suites/sccz80/compare.c:74:12: note: Condition 'b>a' is always true
    if ( b > a ) {} else { Assert(0, "b > a"); }
           ^
test/suites/sccz80/compare.c:76:12: style: Condition 'b>=a' is always true [knownConditionTrueFalse]
    if ( b >= a ) {} else { Assert(0, "b >= a"); }
           ^
test/suites/sccz80/compare.c:63:15: note: Assignment 'b=20', assigned value is 20
    long  b = 20;
              ^
test/suites/sccz80/compare.c:76:12: note: Condition 'b>=a' is always true
    if ( b >= a ) {} else { Assert(0, "b >= a"); }
           ^
test/suites/sccz80/compare.c:85:12: style: Condition 'a<b' is always true [knownConditionTrueFalse]
    if ( a < b ) {} else { Assert(0, "a < b"); }
           ^
test/suites/sccz80/compare.c:81:24: note: Assignment 'a=10', assigned value is 10
    unsigned long  a = 10;
                       ^
test/suites/sccz80/compare.c:85:12: note: Condition 'a<b' is always true
    if ( a < b ) {} else { Assert(0, "a < b"); }
           ^
test/suites/sccz80/compare.c:87:12: style: Condition 'a<=b' is always true [knownConditionTrueFalse]
    if ( a <= b ) {} else { Assert(0, "a <= b"); }
           ^
test/suites/sccz80/compare.c:81:24: note: Assignment 'a=10', assigned value is 10
    unsigned long  a = 10;
                       ^
test/suites/sccz80/compare.c:87:12: note: Condition 'a<=b' is always true
    if ( a <= b ) {} else { Assert(0, "a <= b"); }
           ^
test/suites/sccz80/compare.c:89:12: style: Condition 'a!=b' is always true [knownConditionTrueFalse]
    if ( a != b ) {} else { Assert(0, "a != b"); }
           ^
test/suites/sccz80/compare.c:81:24: note: Assignment 'a=10', assigned value is 10
    unsigned long  a = 10;
                       ^
test/suites/sccz80/compare.c:89:12: note: Condition 'a!=b' is always true
    if ( a != b ) {} else { Assert(0, "a != b"); }
           ^
test/suites/sccz80/compare.c:93:12: style: Condition 'b>a' is always true [knownConditionTrueFalse]
    if ( b > a ) {} else { Assert(0, "b > a"); }
           ^
test/suites/sccz80/compare.c:82:24: note: Assignment 'b=20', assigned value is 20
    unsigned long  b = 20;
                       ^
test/suites/sccz80/compare.c:93:12: note: Condition 'b>a' is always true
    if ( b > a ) {} else { Assert(0, "b > a"); }
           ^
test/suites/sccz80/compare.c:95:12: style: Condition 'b>=a' is always true [knownConditionTrueFalse]
    if ( b >= a ) {} else { Assert(0, "b >= a"); }
           ^
test/suites/sccz80/compare.c:82:24: note: Assignment 'b=20', assigned value is 20
    unsigned long  b = 20;
                       ^
test/suites/sccz80/compare.c:95:12: note: Condition 'b>=a' is always true
    if ( b >= a ) {} else { Assert(0, "b >= a"); }
           ^
test/suites/sccz80/compare.c:105:12: style: Condition 'a<b' is always true [knownConditionTrueFalse]
    if ( a < b ) {} else { Assert(0, "a < b"); }
           ^
test/suites/sccz80/compare.c:101:20: note: Assignment 'a=-10', assigned value is -10
    long long a = -10;
                   ^
test/suites/sccz80/compare.c:105:12: note: Condition 'a<b' is always true
    if ( a < b ) {} else { Assert(0, "a < b"); }
           ^
test/suites/sccz80/compare.c:107:12: style: Condition 'a<=b' is always true [knownConditionTrueFalse]
    if ( a <= b ) {} else { Assert(0, "a <= b"); }
           ^
test/suites/sccz80/compare.c:101:20: note: Assignment 'a=-10', assigned value is -10
    long long a = -10;
                   ^
test/suites/sccz80/compare.c:107:12: note: Condition 'a<=b' is always true
    if ( a <= b ) {} else { Assert(0, "a <= b"); }
           ^
test/suites/sccz80/compare.c:109:12: style: Condition 'a!=b' is always true [knownConditionTrueFalse]
    if ( a != b ) {} else { Assert(0, "a != b"); }
           ^
test/suites/sccz80/compare.c:101:20: note: Assignment 'a=-10', assigned value is -10
    long long a = -10;
                   ^
test/suites/sccz80/compare.c:109:12: note: Condition 'a!=b' is always true
    if ( a != b ) {} else { Assert(0, "a != b"); }
           ^
test/suites/sccz80/compare.c:113:12: style: Condition 'b>a' is always true [knownConditionTrueFalse]
    if ( b > a ) {} else { Assert(0, "b > a"); }
           ^
test/suites/sccz80/compare.c:102:19: note: Assignment 'b=20', assigned value is 20
    long long b = 20;
                  ^
test/suites/sccz80/compare.c:113:12: note: Condition 'b>a' is always true
    if ( b > a ) {} else { Assert(0, "b > a"); }
           ^
test/suites/sccz80/compare.c:115:12: style: Condition 'b>=a' is always true [knownConditionTrueFalse]
    if ( b >= a ) {} else { Assert(0, "b >= a"); }
           ^
test/suites/sccz80/compare.c:102:19: note: Assignment 'b=20', assigned value is 20
    long long b = 20;
                  ^
test/suites/sccz80/compare.c:115:12: note: Condition 'b>=a' is always true
    if ( b >= a ) {} else { Assert(0, "b >= a"); }
           ^
test/suites/sccz80/compare.c:124:12: style: Condition 'a<b' is always true [knownConditionTrueFalse]
    if ( a < b ) {} else { Assert(0, "a < b"); }
           ^
test/suites/sccz80/compare.c:120:28: note: Assignment 'a=10', assigned value is 10
    unsigned long long a = 10;
                           ^
test/suites/sccz80/compare.c:124:12: note: Condition 'a<b' is always true
    if ( a < b ) {} else { Assert(0, "a < b"); }
           ^
test/suites/sccz80/compare.c:126:12: style: Condition 'a<=b' is always true [knownConditionTrueFalse]
    if ( a <= b ) {} else { Assert(0, "a <= b"); }
           ^
test/suites/sccz80/compare.c:120:28: note: Assignment 'a=10', assigned value is 10
    unsigned long long a = 10;
                           ^
test/suites/sccz80/compare.c:126:12: note: Condition 'a<=b' is always true
    if ( a <= b ) {} else { Assert(0, "a <= b"); }
           ^
test/suites/sccz80/compare.c:128:12: style: Condition 'a!=b' is always true [knownConditionTrueFalse]
    if ( a != b ) {} else { Assert(0, "a != b"); }
           ^
test/suites/sccz80/compare.c:120:28: note: Assignment 'a=10', assigned value is 10
    unsigned long long a = 10;
                           ^
test/suites/sccz80/compare.c:128:12: note: Condition 'a!=b' is always true
    if ( a != b ) {} else { Assert(0, "a != b"); }
           ^
test/suites/sccz80/compare.c:132:12: style: Condition 'b>a' is always true [knownConditionTrueFalse]
    if ( b > a ) {} else { Assert(0, "b > a"); }
           ^
test/suites/sccz80/compare.c:121:28: note: Assignment 'b=20', assigned value is 20
    unsigned long long b = 20;
                           ^
test/suites/sccz80/compare.c:132:12: note: Condition 'b>a' is always true
    if ( b > a ) {} else { Assert(0, "b > a"); }
           ^
test/suites/sccz80/compare.c:134:12: style: Condition 'b>=a' is always true [knownConditionTrueFalse]
    if ( b >= a ) {} else { Assert(0, "b >= a"); }
           ^
test/suites/sccz80/compare.c:121:28: note: Assignment 'b=20', assigned value is 20
    unsigned long long b = 20;
                           ^
test/suites/sccz80/compare.c:134:12: note: Condition 'b>=a' is always true
    if ( b >= a ) {} else { Assert(0, "b >= a"); }
           ^
test/suites/sccz80/compare.c:17:16: style: The comparison 'a < 20000' is always false. [knownConditionTrueFalse]
    Assert( (a < 20000) == 0, "a < 20000");
               ^
test/suites/sccz80/compare.c:14:23: note: 'a' is assigned value '20000' here.
    unsigned int  a = 20000;
                      ^
test/suites/sccz80/compare.c:17:16: note: The comparison 'a < 20000' is always false.
    Assert( (a < 20000) == 0, "a < 20000");
               ^
test/suites/sccz80/compare.c:26:16: style: The comparison 'a < 20000' is always false. [knownConditionTrueFalse]
    Assert( (a < 20000) == 0, "a < 20000");
               ^
test/suites/sccz80/compare.c:23:14: note: 'a' is assigned value '20000' here.
    int  a = 20000;
             ^
test/suites/sccz80/compare.c:26:16: note: The comparison 'a < 20000' is always false.
    Assert( (a < 20000) == 0, "a < 20000");
               ^
test/suites/sccz80/compare.c:51:15: style: Same expression on both sides of '=='. [duplicateExpression]
    Assert( a == a, "a == a");
              ^
test/suites/sccz80/compare.c:52:12: style: Same expression on both sides of '=='. [duplicateExpression]
    if ( a == a ) {} else { Assert(0, "a == b"); }
           ^
test/suites/sccz80/compare.c:71:15: style: Same expression on both sides of '=='. [duplicateExpression]
    Assert( a == a, "a == a");
              ^
test/suites/sccz80/compare.c:72:12: style: Same expression on both sides of '=='. [duplicateExpression]
    if ( a == a ) {} else { Assert(0, "a == b"); }
           ^
test/suites/sccz80/compare.c:90:15: style: Same expression on both sides of '=='. [duplicateExpression]
    Assert( a == a, "a == a");
              ^
test/suites/sccz80/compare.c:91:12: style: Same expression on both sides of '=='. [duplicateExpression]
    if ( a == a ) {} else { Assert(0, "a == b"); }
           ^
test/suites/sccz80/compare.c:110:15: style: Same expression on both sides of '=='. [duplicateExpression]
    Assert( a == a, "a == a");
              ^
test/suites/sccz80/compare.c:111:12: style: Same expression on both sides of '=='. [duplicateExpression]
    if ( a == a ) {} else { Assert(0, "a == b"); }
           ^
test/suites/sccz80/compare.c:129:15: style: Same expression on both sides of '=='. [duplicateExpression]
    Assert( a == a, "a == a");
              ^
test/suites/sccz80/compare.c:130:12: style: Same expression on both sides of '=='. [duplicateExpression]
    if ( a == a ) {} else { Assert(0, "a == b"); }
           ^
test/suites/sccz80/compare0.c:11:12: style: Condition 'b==0' is always false [knownConditionTrueFalse]
    if ( b == 0 ) { Assert(0, "b -= 0"); }
           ^
test/suites/sccz80/compare0.c:8:14: note: Assignment 'b=1', assigned value is 1
    char b = 1;
             ^
test/suites/sccz80/compare0.c:11:12: note: Condition 'b==0' is always false
    if ( b == 0 ) { Assert(0, "b -= 0"); }
           ^
test/suites/sccz80/compare0.c:35:12: style: Condition 'b==0' is always false [knownConditionTrueFalse]
    if ( b == 0 ) { Assert(0, "b -= 0"); }
           ^
test/suites/sccz80/compare0.c:32:23: note: Assignment 'b=1', assigned value is 1
    unsigned char b = 1;
                      ^
test/suites/sccz80/compare0.c:35:12: note: Condition 'b==0' is always false
    if ( b == 0 ) { Assert(0, "b -= 0"); }
           ^
test/suites/sccz80/compare0.c:60:12: style: Condition 'b==0' is always false [knownConditionTrueFalse]
    if ( b == 0 ) { Assert(0, "b -= 0"); }
           ^
test/suites/sccz80/compare0.c:56:13: note: Assignment 'b=1', assigned value is 1
    int b = 1;
            ^
test/suites/sccz80/compare0.c:60:12: note: Condition 'b==0' is always false
    if ( b == 0 ) { Assert(0, "b -= 0"); }
           ^
test/suites/sccz80/compare0.c:89:12: style: Condition 'b==0' is always false [knownConditionTrueFalse]
    if ( b == 0 ) { Assert(0, "b -= 0"); }
           ^
test/suites/sccz80/compare0.c:86:22: note: Assignment 'b=1', assigned value is 1
    unsigned int b = 1;
                     ^
test/suites/sccz80/compare0.c:89:12: note: Condition 'b==0' is always false
    if ( b == 0 ) { Assert(0, "b -= 0"); }
           ^
test/suites/sccz80/compare0.c:116:12: style: Condition 'b==0' is always false [knownConditionTrueFalse]
    if ( b == 0 ) { Assert(0, "b -= 0"); }
           ^
test/suites/sccz80/compare0.c:112:14: note: Assignment 'b=1', assigned value is 1
    long b = 1;
             ^
test/suites/sccz80/compare0.c:116:12: note: Condition 'b==0' is always false
    if ( b == 0 ) { Assert(0, "b -= 0"); }
           ^
test/suites/sccz80/compare0.c:144:12: style: Condition 'b==0' is always false [knownConditionTrueFalse]
    if ( b == 0 ) { Assert(0, "b -= 0"); }
           ^
test/suites/sccz80/compare0.c:141:23: note: Assignment 'b=1', assigned value is 1
    unsigned long b = 1;
                      ^
test/suites/sccz80/compare0.c:144:12: note: Condition 'b==0' is always false
    if ( b == 0 ) { Assert(0, "b -= 0"); }
           ^
test/suites/sccz80/compare0.c:10:12: style: The comparison 'a == 0' is always true. [knownConditionTrueFalse]
    if ( a == 0 ) { } else { Assert(0, "a == 0"); }
           ^
test/suites/sccz80/compare0.c:7:14: note: 'a' is assigned value '0' here.
    char a = 0;
             ^
test/suites/sccz80/compare0.c:10:12: note: The comparison 'a == 0' is always true.
    if ( a == 0 ) { } else { Assert(0, "a == 0"); }
           ^
test/suites/sccz80/compare0.c:12:15: style: The comparison 'a == 0' is always true. [knownConditionTrueFalse]
    Assert( a == 0, "(a == 0)");
              ^
test/suites/sccz80/compare0.c:7:14: note: 'a' is assigned value '0' here.
    char a = 0;
             ^
test/suites/sccz80/compare0.c:12:15: note: The comparison 'a == 0' is always true.
    Assert( a == 0, "(a == 0)");
              ^
test/suites/sccz80/compare0.c:13:22: style: Same expression on both sides of '=='. [duplicateExpression]
    Assert( (b == 0) == 0, "(b == 0) == 0");
                     ^
test/suites/sccz80/compare0.c:15:12: style: The comparison 'a != 0' is always false. [knownConditionTrueFalse]
    if ( a != 0 ) { Assert(0, "b != 0"); }
           ^
test/suites/sccz80/compare0.c:7:14: note: 'a' is assigned value '0' here.
    char a = 0;
             ^
test/suites/sccz80/compare0.c:15:12: note: The comparison 'a != 0' is always false.
    if ( a != 0 ) { Assert(0, "b != 0"); }
           ^
test/suites/sccz80/compare0.c:18:12: style: The comparison 'a < 0' is always false. [knownConditionTrueFalse]
    if ( a < 0 ) { Assert(0, "a < 0"); }
           ^
test/suites/sccz80/compare0.c:7:14: note: 'a' is assigned value '0' here.
    char a = 0;
             ^
test/suites/sccz80/compare0.c:18:12: note: The comparison 'a < 0' is always false.
    if ( a < 0 ) { Assert(0, "a < 0"); }
           ^
test/suites/sccz80/compare0.c:20:12: style: The comparison 'a <= 0' is always true. [knownConditionTrueFalse]
    if ( a <= 0 ) {} else { Assert(0, "a <= 0"); }
           ^
test/suites/sccz80/compare0.c:7:14: note: 'a' is assigned value '0' here.
    char a = 0;
             ^
test/suites/sccz80/compare0.c:20:12: note: The comparison 'a <= 0' is always true.
    if ( a <= 0 ) {} else { Assert(0, "a <= 0"); }
           ^
test/suites/sccz80/compare0.c:23:12: style: The comparison 'a > 0' is always false. [knownConditionTrueFalse]
    if ( a > 0 ) { Assert(0, "a > 0"); }
           ^
test/suites/sccz80/compare0.c:7:14: note: 'a' is assigned value '0' here.
    char a = 0;
             ^
test/suites/sccz80/compare0.c:23:12: note: The comparison 'a > 0' is always false.
    if ( a > 0 ) { Assert(0, "a > 0"); }
           ^
test/suites/sccz80/compare0.c:25:12: style: The comparison 'a >= 0' is always true. [knownConditionTrueFalse]
    if ( a >= 0 ) {} else { Assert(0, "a >= 0"); }
           ^
test/suites/sccz80/compare0.c:7:14: note: 'a' is assigned value '0' here.
    char a = 0;
             ^
test/suites/sccz80/compare0.c:25:12: note: The comparison 'a >= 0' is always true.
    if ( a >= 0 ) {} else { Assert(0, "a >= 0"); }
           ^
test/suites/sccz80/compare0.c:34:12: style: The comparison 'a == 0' is always true. [knownConditionTrueFalse]
    if ( a == 0 ) { } else { Assert(0, "a == 0"); }
           ^
test/suites/sccz80/compare0.c:31:23: note: 'a' is assigned value '0' here.
    unsigned char a = 0;
                      ^
test/suites/sccz80/compare0.c:34:12: note: The comparison 'a == 0' is always true.
    if ( a == 0 ) { } else { Assert(0, "a == 0"); }
           ^
test/suites/sccz80/compare0.c:36:15: style: The comparison 'a == 0' is always true. [knownConditionTrueFalse]
    Assert( a == 0, "(a == 0)");
              ^
test/suites/sccz80/compare0.c:31:23: note: 'a' is assigned value '0' here.
    unsigned char a = 0;
                      ^
test/suites/sccz80/compare0.c:36:15: note: The comparison 'a == 0' is always true.
    Assert( a == 0, "(a == 0)");
              ^
test/suites/sccz80/compare0.c:37:22: style: Same expression on both sides of '=='. [duplicateExpression]
    Assert( (b == 0) == 0, "(b == 0) == 0");
                     ^
test/suites/sccz80/compare0.c:39:12: style: The comparison 'a != 0' is always false. [knownConditionTrueFalse]
    if ( a != 0 ) { Assert(0, "b != 0"); }
           ^
test/suites/sccz80/compare0.c:31:23: note: 'a' is assigned value '0' here.
    unsigned char a = 0;
                      ^
test/suites/sccz80/compare0.c:39:12: note: The comparison 'a != 0' is always false.
    if ( a != 0 ) { Assert(0, "b != 0"); }
           ^
test/suites/sccz80/compare0.c:42:12: style: The comparison 'a < 0' is always false. [knownConditionTrueFalse]
    if ( a < 0 ) { Assert(0, "a < 0"); }
           ^
test/suites/sccz80/compare0.c:31:23: note: 'a' is assigned value '0' here.
    unsigned char a = 0;
                      ^
test/suites/sccz80/compare0.c:42:12: note: The comparison 'a < 0' is always false.
    if ( a < 0 ) { Assert(0, "a < 0"); }
           ^
test/suites/sccz80/compare0.c:44:12: style: The comparison 'a <= 0' is always true. [knownConditionTrueFalse]
    if ( a <= 0 ) {} else { Assert(0, "a <= 0"); }
           ^
test/suites/sccz80/compare0.c:31:23: note: 'a' is assigned value '0' here.
    unsigned char a = 0;
                      ^
test/suites/sccz80/compare0.c:44:12: note: The comparison 'a <= 0' is always true.
    if ( a <= 0 ) {} else { Assert(0, "a <= 0"); }
           ^
test/suites/sccz80/compare0.c:47:12: style: The comparison 'a > 0' is always false. [knownConditionTrueFalse]
    if ( a > 0 ) { Assert(0, "a > 0"); }
           ^
test/suites/sccz80/compare0.c:31:23: note: 'a' is assigned value '0' here.
    unsigned char a = 0;
                      ^
test/suites/sccz80/compare0.c:47:12: note: The comparison 'a > 0' is always false.
    if ( a > 0 ) { Assert(0, "a > 0"); }
           ^
test/suites/sccz80/compare0.c:49:12: style: The comparison 'a >= 0' is always true. [knownConditionTrueFalse]
    if ( a >= 0 ) {} else { Assert(0, "a >= 0"); }
           ^
test/suites/sccz80/compare0.c:31:23: note: 'a' is assigned value '0' here.
    unsigned char a = 0;
                      ^
test/suites/sccz80/compare0.c:49:12: note: The comparison 'a >= 0' is always true.
    if ( a >= 0 ) {} else { Assert(0, "a >= 0"); }
           ^
test/suites/sccz80/compare0.c:59:12: style: The comparison 'a == 0' is always true. [knownConditionTrueFalse]
    if ( a == 0 ) { } else { Assert(0, "a == 0"); }
           ^
test/suites/sccz80/compare0.c:55:13: note: 'a' is assigned value '0' here.
    int a = 0;
            ^
test/suites/sccz80/compare0.c:59:12: note: The comparison 'a == 0' is always true.
    if ( a == 0 ) { } else { Assert(0, "a == 0"); }
           ^
test/suites/sccz80/compare0.c:61:15: style: The comparison 'a == 0' is always true. [knownConditionTrueFalse]
    Assert( a == 0, "(a == 0)");
              ^
test/suites/sccz80/compare0.c:55:13: note: 'a' is assigned value '0' here.
    int a = 0;
            ^
test/suites/sccz80/compare0.c:61:15: note: The comparison 'a == 0' is always true.
    Assert( a == 0, "(a == 0)");
              ^
test/suites/sccz80/compare0.c:62:22: style: Same expression on both sides of '=='. [duplicateExpression]
    Assert( (b == 0) == 0, "(b == 0) == 0");
                     ^
test/suites/sccz80/compare0.c:64:12: style: The comparison 'a != 0' is always false. [knownConditionTrueFalse]
    if ( a != 0 ) { Assert(0, "b != 0"); }
           ^
test/suites/sccz80/compare0.c:55:13: note: 'a' is assigned value '0' here.
    int a = 0;
            ^
test/suites/sccz80/compare0.c:64:12: note: The comparison 'a != 0' is always false.
    if ( a != 0 ) { Assert(0, "b != 0"); }
           ^
test/suites/sccz80/compare0.c:67:12: style: The comparison 'a < 0' is always false. [knownConditionTrueFalse]
    if ( a < 0 ) { Assert(0, "a < 0"); }
           ^
test/suites/sccz80/compare0.c:55:13: note: 'a' is assigned value '0' here.
    int a = 0;
            ^
test/suites/sccz80/compare0.c:67:12: note: The comparison 'a < 0' is always false.
    if ( a < 0 ) { Assert(0, "a < 0"); }
           ^
test/suites/sccz80/compare0.c:70:12: style: The comparison 'a <= 0' is always true. [knownConditionTrueFalse]
    if ( a <= 0 ) {} else { Assert(0, "a <= 0"); }
           ^
test/suites/sccz80/compare0.c:55:13: note: 'a' is assigned value '0' here.
    int a = 0;
            ^
test/suites/sccz80/compare0.c:70:12: note: The comparison 'a <= 0' is always true.
    if ( a <= 0 ) {} else { Assert(0, "a <= 0"); }
           ^
test/suites/sccz80/compare0.c:73:12: style: The comparison 'a > 0' is always false. [knownConditionTrueFalse]
    if ( a > 0 ) { Assert(0, "a > 0"); }
           ^
test/suites/sccz80/compare0.c:55:13: note: 'a' is assigned value '0' here.
    int a = 0;
            ^
test/suites/sccz80/compare0.c:73:12: note: The comparison 'a > 0' is always false.
    if ( a > 0 ) { Assert(0, "a > 0"); }
           ^
test/suites/sccz80/compare0.c:75:12: style: The comparison 'a >= 0' is always true. [knownConditionTrueFalse]
    if ( a >= 0 ) {} else { Assert(0, "a >= 0"); }
           ^
test/suites/sccz80/compare0.c:55:13: note: 'a' is assigned value '0' here.
    int a = 0;
            ^
test/suites/sccz80/compare0.c:75:12: note: The comparison 'a >= 0' is always true.
    if ( a >= 0 ) {} else { Assert(0, "a >= 0"); }
           ^
test/suites/sccz80/compare0.c:88:12: style: The comparison 'a == 0' is always true. [knownConditionTrueFalse]
    if ( a == 0 ) { } else { Assert(0, "a == 0"); }
           ^
test/suites/sccz80/compare0.c:85:22: note: 'a' is assigned value '0' here.
    unsigned int a = 0;
                     ^
test/suites/sccz80/compare0.c:88:12: note: The comparison 'a == 0' is always true.
    if ( a == 0 ) { } else { Assert(0, "a == 0"); }
           ^
test/suites/sccz80/compare0.c:90:15: style: The comparison 'a == 0' is always true. [knownConditionTrueFalse]
    Assert( a == 0, "(a == 0)");
              ^
test/suites/sccz80/compare0.c:85:22: note: 'a' is assigned value '0' here.
    unsigned int a = 0;
                     ^
test/suites/sccz80/compare0.c:90:15: note: The comparison 'a == 0' is always true.
    Assert( a == 0, "(a == 0)");
              ^
test/suites/sccz80/compare0.c:91:22: style: Same expression on both sides of '=='. [duplicateExpression]
    Assert( (b == 0) == 0, "(b == 0) == 0");
                     ^
test/suites/sccz80/compare0.c:93:12: style: The comparison 'a != 0' is always false. [knownConditionTrueFalse]
    if ( a != 0 ) { Assert(0, "b != 0"); }
           ^
test/suites/sccz80/compare0.c:85:22: note: 'a' is assigned value '0' here.
    unsigned int a = 0;
                     ^
test/suites/sccz80/compare0.c:93:12: note: The comparison 'a != 0' is always false.
    if ( a != 0 ) { Assert(0, "b != 0"); }
           ^
test/suites/sccz80/compare0.c:96:12: style: The comparison 'a < 0' is always false. [knownConditionTrueFalse]
    if ( a < 0 ) { Assert(0, "a < 0"); }
           ^
test/suites/sccz80/compare0.c:85:22: note: 'a' is assigned value '0' here.
    unsigned int a = 0;
                     ^
test/suites/sccz80/compare0.c:96:12: note: The comparison 'a < 0' is always false.
    if ( a < 0 ) { Assert(0, "a < 0"); }
           ^
test/suites/sccz80/compare0.c:98:12: style: The comparison 'a <= 0' is always true. [knownConditionTrueFalse]
    if ( a <= 0 ) {} else { Assert(0, "a <= 0"); }
           ^
test/suites/sccz80/compare0.c:85:22: note: 'a' is assigned value '0' here.
    unsigned int a = 0;
                     ^
test/suites/sccz80/compare0.c:98:12: note: The comparison 'a <= 0' is always true.
    if ( a <= 0 ) {} else { Assert(0, "a <= 0"); }
           ^
test/suites/sccz80/compare0.c:101:12: style: The comparison 'a > 0' is always false. [knownConditionTrueFalse]
    if ( a > 0 ) { Assert(0, "a > 0"); }
           ^
test/suites/sccz80/compare0.c:85:22: note: 'a' is assigned value '0' here.
    unsigned int a = 0;
                     ^
test/suites/sccz80/compare0.c:101:12: note: The comparison 'a > 0' is always false.
    if ( a > 0 ) { Assert(0, "a > 0"); }
           ^
test/suites/sccz80/compare0.c:103:12: style: The comparison 'a >= 0' is always true. [knownConditionTrueFalse]
    if ( a >= 0 ) {} else { Assert(0, "a >= 0"); }
           ^
test/suites/sccz80/compare0.c:85:22: note: 'a' is assigned value '0' here.
    unsigned int a = 0;
                     ^
test/suites/sccz80/compare0.c:103:12: note: The comparison 'a >= 0' is always true.
    if ( a >= 0 ) {} else { Assert(0, "a >= 0"); }
           ^
test/suites/sccz80/compare0.c:115:12: style: The comparison 'a == 0' is always true. [knownConditionTrueFalse]
    if ( a == 0 ) { } else { Assert(0, "a == 0"); }
           ^
test/suites/sccz80/compare0.c:111:14: note: 'a' is assigned value '0' here.
    long a = 0;
             ^
test/suites/sccz80/compare0.c:115:12: note: The comparison 'a == 0' is always true.
    if ( a == 0 ) { } else { Assert(0, "a == 0"); }
           ^
test/suites/sccz80/compare0.c:117:15: style: The comparison 'a == 0' is always true. [knownConditionTrueFalse]
    Assert( a == 0, "(a == 0)");
              ^
test/suites/sccz80/compare0.c:111:14: note: 'a' is assigned value '0' here.
    long a = 0;
             ^
test/suites/sccz80/compare0.c:117:15: note: The comparison 'a == 0' is always true.
    Assert( a == 0, "(a == 0)");
              ^
test/suites/sccz80/compare0.c:118:22: style: Same expression on both sides of '=='. [duplicateExpression]
    Assert( (b == 0) == 0, "(b == 0) == 0");
                     ^
test/suites/sccz80/compare0.c:120:12: style: The comparison 'a != 0' is always false. [knownConditionTrueFalse]
    if ( a != 0 ) { Assert(0, "b != 0"); }
           ^
test/suites/sccz80/compare0.c:111:14: note: 'a' is assigned value '0' here.
    long a = 0;
             ^
test/suites/sccz80/compare0.c:120:12: note: The comparison 'a != 0' is always false.
    if ( a != 0 ) { Assert(0, "b != 0"); }
           ^
test/suites/sccz80/compare0.c:123:12: style: The comparison 'a < 0' is always false. [knownConditionTrueFalse]
    if ( a < 0 ) { Assert(0, "a < 0"); }
           ^
test/suites/sccz80/compare0.c:111:14: note: 'a' is assigned value '0' here.
    long a = 0;
             ^
test/suites/sccz80/compare0.c:123:12: note: The comparison 'a < 0' is always false.
    if ( a < 0 ) { Assert(0, "a < 0"); }
           ^
test/suites/sccz80/compare0.c:125:12: style: The comparison 'a <= 0' is always true. [knownConditionTrueFalse]
    if ( a <= 0 ) {} else { Assert(0, "a <= 0"); }
           ^
test/suites/sccz80/compare0.c:111:14: note: 'a' is assigned value '0' here.
    long a = 0;
             ^
test/suites/sccz80/compare0.c:125:12: note: The comparison 'a <= 0' is always true.
    if ( a <= 0 ) {} else { Assert(0, "a <= 0"); }
           ^
test/suites/sccz80/compare0.c:128:12: style: The comparison 'a > 0' is always false. [knownConditionTrueFalse]
    if ( a > 0 ) { Assert(0, "a > 0"); }
           ^
test/suites/sccz80/compare0.c:111:14: note: 'a' is assigned value '0' here.
    long a = 0;
             ^
test/suites/sccz80/compare0.c:128:12: note: The comparison 'a > 0' is always false.
    if ( a > 0 ) { Assert(0, "a > 0"); }
           ^
test/suites/sccz80/compare0.c:130:12: style: The comparison 'a >= 0' is always true. [knownConditionTrueFalse]
    if ( a >= 0 ) {} else { Assert(0, "a >= 0"); }
           ^
test/suites/sccz80/compare0.c:111:14: note: 'a' is assigned value '0' here.
    long a = 0;
             ^
test/suites/sccz80/compare0.c:130:12: note: The comparison 'a >= 0' is always true.
    if ( a >= 0 ) {} else { Assert(0, "a >= 0"); }
           ^
test/suites/sccz80/compare0.c:143:12: style: The comparison 'a == 0' is always true. [knownConditionTrueFalse]
    if ( a == 0 ) { } else { Assert(0, "a == 0"); }
           ^
test/suites/sccz80/compare0.c:140:23: note: 'a' is assigned value '0' here.
    unsigned long a = 0;
                      ^
test/suites/sccz80/compare0.c:143:12: note: The comparison 'a == 0' is always true.
    if ( a == 0 ) { } else { Assert(0, "a == 0"); }
           ^
test/suites/sccz80/compare0.c:145:15: style: The comparison 'a == 0' is always true. [knownConditionTrueFalse]
    Assert( a == 0, "(a == 0)");
              ^
test/suites/sccz80/compare0.c:140:23: note: 'a' is assigned value '0' here.
    unsigned long a = 0;
                      ^
test/suites/sccz80/compare0.c:145:15: note: The comparison 'a == 0' is always true.
    Assert( a == 0, "(a == 0)");
              ^
test/suites/sccz80/compare0.c:146:22: style: Same expression on both sides of '=='. [duplicateExpression]
    Assert( (b == 0) == 0, "(b == 0) == 0");
                     ^
test/suites/sccz80/compare0.c:148:12: style: The comparison 'a != 0' is always false. [knownConditionTrueFalse]
    if ( a != 0 ) { Assert(0, "b != 0"); }
           ^
test/suites/sccz80/compare0.c:140:23: note: 'a' is assigned value '0' here.
    unsigned long a = 0;
                      ^
test/suites/sccz80/compare0.c:148:12: note: The comparison 'a != 0' is always false.
    if ( a != 0 ) { Assert(0, "b != 0"); }
           ^
test/suites/sccz80/compare0.c:151:12: style: The comparison 'a < 0' is always false. [knownConditionTrueFalse]
    if ( a < 0 ) { Assert(0, "a < 0"); }
           ^
test/suites/sccz80/compare0.c:140:23: note: 'a' is assigned value '0' here.
    unsigned long a = 0;
                      ^
test/suites/sccz80/compare0.c:151:12: note: The comparison 'a < 0' is always false.
    if ( a < 0 ) { Assert(0, "a < 0"); }
           ^
test/suites/sccz80/compare0.c:153:12: style: The comparison 'a <= 0' is always true. [knownConditionTrueFalse]
    if ( a <= 0 ) {} else { Assert(0, "a <= 0"); }
           ^
test/suites/sccz80/compare0.c:140:23: note: 'a' is assigned value '0' here.
    unsigned long a = 0;
                      ^
test/suites/sccz80/compare0.c:153:12: note: The comparison 'a <= 0' is always true.
    if ( a <= 0 ) {} else { Assert(0, "a <= 0"); }
           ^
test/suites/sccz80/compare0.c:156:12: style: The comparison 'a > 0' is always false. [knownConditionTrueFalse]
    if ( a > 0 ) { Assert(0, "a > 0"); }
           ^
test/suites/sccz80/compare0.c:140:23: note: 'a' is assigned value '0' here.
    unsigned long a = 0;
                      ^
test/suites/sccz80/compare0.c:156:12: note: The comparison 'a > 0' is always false.
    if ( a > 0 ) { Assert(0, "a > 0"); }
           ^
test/suites/sccz80/compare0.c:158:12: style: The comparison 'a >= 0' is always true. [knownConditionTrueFalse]
    if ( a >= 0 ) {} else { Assert(0, "a >= 0"); }
           ^
test/suites/sccz80/compare0.c:140:23: note: 'a' is assigned value '0' here.
    unsigned long a = 0;
                      ^
test/suites/sccz80/compare0.c:158:12: note: The comparison 'a >= 0' is always true.
    if ( a >= 0 ) {} else { Assert(0, "a >= 0"); }
           ^
test/suites/sccz80/compare0.c:42:12: style: Checking if unsigned expression 'a' is less than zero. [unsignedLessThanZero]
    if ( a < 0 ) { Assert(0, "a < 0"); }
           ^
test/suites/sccz80/compare0.c:43:12: style: Checking if unsigned expression 'b' is less than zero. [unsignedLessThanZero]
    if ( b < 0 ) { Assert(0, "b < 0"); }
           ^
test/suites/sccz80/compare0.c:44:12: style: Checking if unsigned expression 'a' is less than zero. [unsignedLessThanZero]
    if ( a <= 0 ) {} else { Assert(0, "a <= 0"); }
           ^
test/suites/sccz80/compare0.c:45:12: style: Checking if unsigned expression 'b' is less than zero. [unsignedLessThanZero]
    if ( b <= 0 ) { Assert(0, "b <= 0"); }
           ^
test/suites/sccz80/compare0.c:49:12: style: Unsigned expression 'a' can't be negative so it is unnecessary to test it. [unsignedPositive]
    if ( a >= 0 ) {} else { Assert(0, "a >= 0"); }
           ^
test/suites/sccz80/compare0.c:50:12: style: Unsigned expression 'b' can't be negative so it is unnecessary to test it. [unsignedPositive]
    if ( b >= 0 ) {} else { Assert(0, "b >= 0"); }
           ^
test/suites/sccz80/compare0.c:96:12: style: Checking if unsigned expression 'a' is less than zero. [unsignedLessThanZero]
    if ( a < 0 ) { Assert(0, "a < 0"); }
           ^
test/suites/sccz80/compare0.c:97:12: style: Checking if unsigned expression 'b' is less than zero. [unsignedLessThanZero]
    if ( b < 0 ) { Assert(0, "b < 0"); }
           ^
test/suites/sccz80/compare0.c:98:12: style: Checking if unsigned expression 'a' is less than zero. [unsignedLessThanZero]
    if ( a <= 0 ) {} else { Assert(0, "a <= 0"); }
           ^
test/suites/sccz80/compare0.c:99:12: style: Checking if unsigned expression 'b' is less than zero. [unsignedLessThanZero]
    if ( b <= 0 ) { Assert(0, "b <= 0"); }
           ^
test/suites/sccz80/compare0.c:103:12: style: Unsigned expression 'a' can't be negative so it is unnecessary to test it. [unsignedPositive]
    if ( a >= 0 ) {} else { Assert(0, "a >= 0"); }
           ^
test/suites/sccz80/compare0.c:104:12: style: Unsigned expression 'b' can't be negative so it is unnecessary to test it. [unsignedPositive]
    if ( b >= 0 ) {} else { Assert(0, "b >= 0"); }
           ^
test/suites/sccz80/compare0.c:151:12: style: Checking if unsigned expression 'a' is less than zero. [unsignedLessThanZero]
    if ( a < 0 ) { Assert(0, "a < 0"); }
           ^
test/suites/sccz80/compare0.c:152:12: style: Checking if unsigned expression 'b' is less than zero. [unsignedLessThanZero]
    if ( b < 0 ) { Assert(0, "b < 0"); }
           ^
test/suites/sccz80/compare0.c:153:12: style: Checking if unsigned expression 'a' is less than zero. [unsignedLessThanZero]
    if ( a <= 0 ) {} else { Assert(0, "a <= 0"); }
           ^
test/suites/sccz80/compare0.c:154:12: style: Checking if unsigned expression 'b' is less than zero. [unsignedLessThanZero]
    if ( b <= 0 ) { Assert(0, "b <= 0"); }
           ^
test/suites/sccz80/compare0.c:158:12: style: Unsigned expression 'a' can't be negative so it is unnecessary to test it. [unsignedPositive]
    if ( a >= 0 ) {} else { Assert(0, "a >= 0"); }
           ^
test/suites/sccz80/compare0.c:159:12: style: Unsigned expression 'b' can't be negative so it is unnecessary to test it. [unsignedPositive]
    if ( b >= 0 ) {} else { Assert(0, "b >= 0"); }
           ^
test/suites/sccz80/compare_const.c:10:12: style: Condition 'a==1' is always false [knownConditionTrueFalse]
    if ( a == 1 ) { Assert(0, "a == 1"); }
           ^
test/suites/sccz80/compare_const.c:7:14: note: Assignment 'a=0', assigned value is 0
    char a = 0;
             ^
test/suites/sccz80/compare_const.c:10:12: note: Condition 'a==1' is always false
    if ( a == 1 ) { Assert(0, "a == 1"); }
           ^
test/suites/sccz80/compare_const.c:34:12: style: Condition 'a==1' is always false [knownConditionTrueFalse]
    if ( a == 1 ) { Assert(0, "a == 1"); }
           ^
test/suites/sccz80/compare_const.c:31:23: note: Assignment 'a=0', assigned value is 0
    unsigned char a = 0;
                      ^
test/suites/sccz80/compare_const.c:34:12: note: Condition 'a==1' is always false
    if ( a == 1 ) { Assert(0, "a == 1"); }
           ^
test/suites/sccz80/compare_const.c:58:12: style: Condition 'a==1' is always false [knownConditionTrueFalse]
    if ( a == 1 ) { Assert(0, "a == 1"); }
           ^
test/suites/sccz80/compare_const.c:55:13: note: Assignment 'a=0', assigned value is 0
    int a = 0;
            ^
test/suites/sccz80/compare_const.c:58:12: note: Condition 'a==1' is always false
    if ( a == 1 ) { Assert(0, "a == 1"); }
           ^
test/suites/sccz80/compare_const.c:82:12: style: Condition 'a==1' is always false [knownConditionTrueFalse]
    if ( a == 1 ) { Assert(0, "a == 1"); }
           ^
test/suites/sccz80/compare_const.c:79:22: note: Assignment 'a=0', assigned value is 0
    unsigned int a = 0;
                     ^
test/suites/sccz80/compare_const.c:82:12: note: Condition 'a==1' is always false
    if ( a == 1 ) { Assert(0, "a == 1"); }
           ^
test/suites/sccz80/compare_const.c:107:12: style: Condition 'a==1' is always false [knownConditionTrueFalse]
    if ( a == 1 ) { Assert(0, "a == 1"); }
           ^
test/suites/sccz80/compare_const.c:103:14: note: Assignment 'a=0', assigned value is 0
    long a = 0;
             ^
test/suites/sccz80/compare_const.c:107:12: note: Condition 'a==1' is always false
    if ( a == 1 ) { Assert(0, "a == 1"); }
           ^
test/suites/sccz80/compare_const.c:135:12: style: Condition 'a==1' is always false [knownConditionTrueFalse]
    if ( a == 1 ) { Assert(0, "a == 1"); }
           ^
test/suites/sccz80/compare_const.c:132:23: note: Assignment 'a=0', assigned value is 0
    unsigned long a = 0;
                      ^
test/suites/sccz80/compare_const.c:135:12: note: Condition 'a==1' is always false
    if ( a == 1 ) { Assert(0, "a == 1"); }
           ^
test/suites/sccz80/compare_const.c:11:12: style: The comparison 'b == 1' is always true. [knownConditionTrueFalse]
    if ( b == 1 ) { } else { Assert(0, "b == 1"); }
           ^
test/suites/sccz80/compare_const.c:8:14: note: 'b' is assigned value '1' here.
    char b = 1;
             ^
test/suites/sccz80/compare_const.c:11:12: note: The comparison 'b == 1' is always true.
    if ( b == 1 ) { } else { Assert(0, "b == 1"); }
           ^
test/suites/sccz80/compare_const.c:12:15: style: The comparison 'b == 1' is always true. [knownConditionTrueFalse]
    Assert( b == 1, "(b == 1)");
              ^
test/suites/sccz80/compare_const.c:8:14: note: 'b' is assigned value '1' here.
    char b = 1;
             ^
test/suites/sccz80/compare_const.c:12:15: note: The comparison 'b == 1' is always true.
    Assert( b == 1, "(b == 1)");
              ^
test/suites/sccz80/compare_const.c:13:22: style: The comparison 'a == 0' is always true. [knownConditionTrueFalse]
    Assert( (a == 1) == 0, "(a == 1) == 0");
                     ^
test/suites/sccz80/compare_const.c:7:14: note: 'a' is assigned value '0' here.
    char a = 0;
             ^
test/suites/sccz80/compare_const.c:13:22: note: The comparison 'a == 0' is always true.
    Assert( (a == 1) == 0, "(a == 1) == 0");
                     ^
test/suites/sccz80/compare_const.c:16:12: style: The comparison 'b != 1' is always false. [knownConditionTrueFalse]
    if ( b != 1 ) { Assert(0, "b != 1"); }
           ^
test/suites/sccz80/compare_const.c:8:14: note: 'b' is assigned value '1' here.
    char b = 1;
             ^
test/suites/sccz80/compare_const.c:16:12: note: The comparison 'b != 1' is always false.
    if ( b != 1 ) { Assert(0, "b != 1"); }
           ^
test/suites/sccz80/compare_const.c:19:12: style: The comparison 'b < 1' is always false. [knownConditionTrueFalse]
    if ( b < 1 ) { Assert(0, "b < 1"); }
           ^
test/suites/sccz80/compare_const.c:8:14: note: 'b' is assigned value '1' here.
    char b = 1;
             ^
test/suites/sccz80/compare_const.c:19:12: note: The comparison 'b < 1' is always false.
    if ( b < 1 ) { Assert(0, "b < 1"); }
           ^
test/suites/sccz80/compare_const.c:21:12: style: The comparison 'b <= 1' is always true. [knownConditionTrueFalse]
    if ( b <= 1 ) {} else { Assert(0, "b <= 1"); }
           ^
test/suites/sccz80/compare_const.c:8:14: note: 'b' is assigned value '1' here.
    char b = 1;
             ^
test/suites/sccz80/compare_const.c:21:12: note: The comparison 'b <= 1' is always true.
    if ( b <= 1 ) {} else { Assert(0, "b <= 1"); }
           ^
test/suites/sccz80/compare_const.c:24:12: style: The comparison 'b > 1' is always false. [knownConditionTrueFalse]
    if ( b > 1 ) { Assert(0, "b > 1"); }
           ^
test/suites/sccz80/compare_const.c:8:14: note: 'b' is assigned value '1' here.
    char b = 1;
             ^
test/suites/sccz80/compare_const.c:24:12: note: The comparison 'b > 1' is always false.
    if ( b > 1 ) { Assert(0, "b > 1"); }
           ^
test/suites/sccz80/compare_const.c:26:12: style: The comparison 'b >= 1' is always true. [knownConditionTrueFalse]
    if ( b >= 1 ) {} else{ Assert(0, "b >= 1"); }
           ^
test/suites/sccz80/compare_const.c:8:14: note: 'b' is assigned value '1' here.
    char b = 1;
             ^
test/suites/sccz80/compare_const.c:26:12: note: The comparison 'b >= 1' is always true.
    if ( b >= 1 ) {} else{ Assert(0, "b >= 1"); }
           ^
test/suites/sccz80/compare_const.c:35:12: style: The comparison 'b == 1' is always true. [knownConditionTrueFalse]
    if ( b == 1 ) { } else { Assert(0, "b == 1"); }
           ^
test/suites/sccz80/compare_const.c:32:23: note: 'b' is assigned value '1' here.
    unsigned char b = 1;
                      ^
test/suites/sccz80/compare_const.c:35:12: note: The comparison 'b == 1' is always true.
    if ( b == 1 ) { } else { Assert(0, "b == 1"); }
           ^
test/suites/sccz80/compare_const.c:36:15: style: The comparison 'b == 1' is always true. [knownConditionTrueFalse]
    Assert( b == 1, "(b == 1)");
              ^
test/suites/sccz80/compare_const.c:32:23: note: 'b' is assigned value '1' here.
    unsigned char b = 1;
                      ^
test/suites/sccz80/compare_const.c:36:15: note: The comparison 'b == 1' is always true.
    Assert( b == 1, "(b == 1)");
              ^
test/suites/sccz80/compare_const.c:37:22: style: The comparison 'a == 0' is always true. [knownConditionTrueFalse]
    Assert( (a == 1) == 0, "(a == 1) == 0");
                     ^
test/suites/sccz80/compare_const.c:31:23: note: 'a' is assigned value '0' here.
    unsigned char a = 0;
                      ^
test/suites/sccz80/compare_const.c:37:22: note: The comparison 'a == 0' is always true.
    Assert( (a == 1) == 0, "(a == 1) == 0");
                     ^
test/suites/sccz80/compare_const.c:40:12: style: The comparison 'b != 1' is always false. [knownConditionTrueFalse]
    if ( b != 1 ) { Assert(0, "b != 1"); }
           ^
test/suites/sccz80/compare_const.c:32:23: note: 'b' is assigned value '1' here.
    unsigned char b = 1;
                      ^
test/suites/sccz80/compare_const.c:40:12: note: The comparison 'b != 1' is always false.
    if ( b != 1 ) { Assert(0, "b != 1"); }
           ^
test/suites/sccz80/compare_const.c:43:12: style: The comparison 'b < 1' is always false. [knownConditionTrueFalse]
    if ( b < 1 ) { Assert(0, "b < 1"); }
           ^
test/suites/sccz80/compare_const.c:32:23: note: 'b' is assigned value '1' here.
    unsigned char b = 1;
                      ^
test/suites/sccz80/compare_const.c:43:12: note: The comparison 'b < 1' is always false.
    if ( b < 1 ) { Assert(0, "b < 1"); }
           ^
test/suites/sccz80/compare_const.c:45:12: style: The comparison 'b <= 1' is always true. [knownConditionTrueFalse]
    if ( b <= 1 ) {} else { Assert(0, "b <= 1"); }
           ^
test/suites/sccz80/compare_const.c:32:23: note: 'b' is assigned value '1' here.
    unsigned char b = 1;
                      ^
test/suites/sccz80/compare_const.c:45:12: note: The comparison 'b <= 1' is always true.
    if ( b <= 1 ) {} else { Assert(0, "b <= 1"); }
           ^
test/suites/sccz80/compare_const.c:48:12: style: The comparison 'b > 1' is always false. [knownConditionTrueFalse]
    if ( b > 1 ) { Assert(0, "b > 1"); }
           ^
test/suites/sccz80/compare_const.c:32:23: note: 'b' is assigned value '1' here.
    unsigned char b = 1;
                      ^
test/suites/sccz80/compare_const.c:48:12: note: The comparison 'b > 1' is always false.
    if ( b > 1 ) { Assert(0, "b > 1"); }
           ^
test/suites/sccz80/compare_const.c:50:12: style: The comparison 'b >= 1' is always true. [knownConditionTrueFalse]
    if ( b >= 1 ) {} else{ Assert(0, "b >= 1"); }
           ^
test/suites/sccz80/compare_const.c:32:23: note: 'b' is assigned value '1' here.
    unsigned char b = 1;
                      ^
test/suites/sccz80/compare_const.c:50:12: note: The comparison 'b >= 1' is always true.
    if ( b >= 1 ) {} else{ Assert(0, "b >= 1"); }
           ^
test/suites/sccz80/compare_const.c:59:12: style: The comparison 'b == 1' is always true. [knownConditionTrueFalse]
    if ( b == 1 ) { } else { Assert(0, "b == 1"); }
           ^
test/suites/sccz80/compare_const.c:56:13: note: 'b' is assigned value '1' here.
    int b = 1;
            ^
test/suites/sccz80/compare_const.c:59:12: note: The comparison 'b == 1' is always true.
    if ( b == 1 ) { } else { Assert(0, "b == 1"); }
           ^
test/suites/sccz80/compare_const.c:60:15: style: The comparison 'b == 1' is always true. [knownConditionTrueFalse]
    Assert( b == 1, "(b == 1)");
              ^
test/suites/sccz80/compare_const.c:56:13: note: 'b' is assigned value '1' here.
    int b = 1;
            ^
test/suites/sccz80/compare_const.c:60:15: note: The comparison 'b == 1' is always true.
    Assert( b == 1, "(b == 1)");
              ^
test/suites/sccz80/compare_const.c:61:22: style: The comparison 'a == 0' is always true. [knownConditionTrueFalse]
    Assert( (a == 1) == 0, "(a == 1) == 0");
                     ^
test/suites/sccz80/compare_const.c:55:13: note: 'a' is assigned value '0' here.
    int a = 0;
            ^
test/suites/sccz80/compare_const.c:61:22: note: The comparison 'a == 0' is always true.
    Assert( (a == 1) == 0, "(a == 1) == 0");
                     ^
test/suites/sccz80/compare_const.c:64:12: style: The comparison 'b != 1' is always false. [knownConditionTrueFalse]
    if ( b != 1 ) { Assert(0, "b != 1"); }
           ^
test/suites/sccz80/compare_const.c:56:13: note: 'b' is assigned value '1' here.
    int b = 1;
            ^
test/suites/sccz80/compare_const.c:64:12: note: The comparison 'b != 1' is always false.
    if ( b != 1 ) { Assert(0, "b != 1"); }
           ^
test/suites/sccz80/compare_const.c:67:12: style: The comparison 'b < 1' is always false. [knownConditionTrueFalse]
    if ( b < 1 ) { Assert(0, "b < 1"); }
           ^
test/suites/sccz80/compare_const.c:56:13: note: 'b' is assigned value '1' here.
    int b = 1;
            ^
test/suites/sccz80/compare_const.c:67:12: note: The comparison 'b < 1' is always false.
    if ( b < 1 ) { Assert(0, "b < 1"); }
           ^
test/suites/sccz80/compare_const.c:69:12: style: The comparison 'b <= 1' is always true. [knownConditionTrueFalse]
    if ( b <= 1 ) {} else { Assert(0, "b <= 1"); }
           ^
test/suites/sccz80/compare_const.c:56:13: note: 'b' is assigned value '1' here.
    int b = 1;
            ^
test/suites/sccz80/compare_const.c:69:12: note: The comparison 'b <= 1' is always true.
    if ( b <= 1 ) {} else { Assert(0, "b <= 1"); }
           ^
test/suites/sccz80/compare_const.c:72:12: style: The comparison 'b > 1' is always false. [knownConditionTrueFalse]
    if ( b > 1 ) { Assert(0, "b > 1"); }
           ^
test/suites/sccz80/compare_const.c:56:13: note: 'b' is assigned value '1' here.
    int b = 1;
            ^
test/suites/sccz80/compare_const.c:72:12: note: The comparison 'b > 1' is always false.
    if ( b > 1 ) { Assert(0, "b > 1"); }
           ^
test/suites/sccz80/compare_const.c:74:12: style: The comparison 'b >= 1' is always true. [knownConditionTrueFalse]
    if ( b >= 1 ) {} else{ Assert(0, "b >= 1"); }
           ^
test/suites/sccz80/compare_const.c:56:13: note: 'b' is assigned value '1' here.
    int b = 1;
            ^
test/suites/sccz80/compare_const.c:74:12: note: The comparison 'b >= 1' is always true.
    if ( b >= 1 ) {} else{ Assert(0, "b >= 1"); }
           ^
test/suites/sccz80/compare_const.c:83:12: style: The comparison 'b == 1' is always true. [knownConditionTrueFalse]
    if ( b == 1 ) { } else { Assert(0, "b == 1"); }
           ^
test/suites/sccz80/compare_const.c:80:22: note: 'b' is assigned value '1' here.
    unsigned int b = 1;
                     ^
test/suites/sccz80/compare_const.c:83:12: note: The comparison 'b == 1' is always true.
    if ( b == 1 ) { } else { Assert(0, "b == 1"); }
           ^
test/suites/sccz80/compare_const.c:84:15: style: The comparison 'b == 1' is always true. [knownConditionTrueFalse]
    Assert( b == 1, "(b == 1)");
              ^
test/suites/sccz80/compare_const.c:80:22: note: 'b' is assigned value '1' here.
    unsigned int b = 1;
                     ^
test/suites/sccz80/compare_const.c:84:15: note: The comparison 'b == 1' is always true.
    Assert( b == 1, "(b == 1)");
              ^
test/suites/sccz80/compare_const.c:85:22: style: The comparison 'a == 0' is always true. [knownConditionTrueFalse]
    Assert( (a == 1) == 0, "(a == 1) == 0");
                     ^
test/suites/sccz80/compare_const.c:79:22: note: 'a' is assigned value '0' here.
    unsigned int a = 0;
                     ^
test/suites/sccz80/compare_const.c:85:22: note: The comparison 'a == 0' is always true.
    Assert( (a == 1) == 0, "(a == 1) == 0");
                     ^
test/suites/sccz80/compare_const.c:88:12: style: The comparison 'b != 1' is always false. [knownConditionTrueFalse]
    if ( b != 1 ) { Assert(0, "b != 1"); }
           ^
test/suites/sccz80/compare_const.c:80:22: note: 'b' is assigned value '1' here.
    unsigned int b = 1;
                     ^
test/suites/sccz80/compare_const.c:88:12: note: The comparison 'b != 1' is always false.
    if ( b != 1 ) { Assert(0, "b != 1"); }
           ^
test/suites/sccz80/compare_const.c:91:12: style: The comparison 'b < 1' is always false. [knownConditionTrueFalse]
    if ( b < 1 ) { Assert(0, "b < 1"); }
           ^
test/suites/sccz80/compare_const.c:80:22: note: 'b' is assigned value '1' here.
    unsigned int b = 1;
                     ^
test/suites/sccz80/compare_const.c:91:12: note: The comparison 'b < 1' is always false.
    if ( b < 1 ) { Assert(0, "b < 1"); }
           ^
test/suites/sccz80/compare_const.c:93:12: style: The comparison 'b <= 1' is always true. [knownConditionTrueFalse]
    if ( b <= 1 ) {} else { Assert(0, "b <= 1"); }
           ^
test/suites/sccz80/compare_const.c:80:22: note: 'b' is assigned value '1' here.
    unsigned int b = 1;
                     ^
test/suites/sccz80/compare_const.c:93:12: note: The comparison 'b <= 1' is always true.
    if ( b <= 1 ) {} else { Assert(0, "b <= 1"); }
           ^
test/suites/sccz80/compare_const.c:96:12: style: The comparison 'b > 1' is always false. [knownConditionTrueFalse]
    if ( b > 1 ) { Assert(0, "b > 1"); }
           ^
test/suites/sccz80/compare_const.c:80:22: note: 'b' is assigned value '1' here.
    unsigned int b = 1;
                     ^
test/suites/sccz80/compare_const.c:96:12: note: The comparison 'b > 1' is always false.
    if ( b > 1 ) { Assert(0, "b > 1"); }
           ^
test/suites/sccz80/compare_const.c:98:12: style: The comparison 'b >= 1' is always true. [knownConditionTrueFalse]
    if ( b >= 1 ) {} else{ Assert(0, "b >= 1"); }
           ^
test/suites/sccz80/compare_const.c:80:22: note: 'b' is assigned value '1' here.
    unsigned int b = 1;
                     ^
test/suites/sccz80/compare_const.c:98:12: note: The comparison 'b >= 1' is always true.
    if ( b >= 1 ) {} else{ Assert(0, "b >= 1"); }
           ^
test/suites/sccz80/compare_const.c:108:12: style: The comparison 'b == 1' is always true. [knownConditionTrueFalse]
    if ( b == 1 ) { } else { Assert(0, "b == 1"); }
           ^
test/suites/sccz80/compare_const.c:104:14: note: 'b' is assigned value '1' here.
    long b = 1;
             ^
test/suites/sccz80/compare_const.c:108:12: note: The comparison 'b == 1' is always true.
    if ( b == 1 ) { } else { Assert(0, "b == 1"); }
           ^
test/suites/sccz80/compare_const.c:109:15: style: The comparison 'b == 1' is always true. [knownConditionTrueFalse]
    Assert( b == 1, "(b == 1)");
              ^
test/suites/sccz80/compare_const.c:104:14: note: 'b' is assigned value '1' here.
    long b = 1;
             ^
test/suites/sccz80/compare_const.c:109:15: note: The comparison 'b == 1' is always true.
    Assert( b == 1, "(b == 1)");
              ^
test/suites/sccz80/compare_const.c:110:22: style: The comparison 'a == 0' is always true. [knownConditionTrueFalse]
    Assert( (a == 1) == 0, "(a == 1) == 0");
                     ^
test/suites/sccz80/compare_const.c:103:14: note: 'a' is assigned value '0' here.
    long a = 0;
             ^
test/suites/sccz80/compare_const.c:110:22: note: The comparison 'a == 0' is always true.
    Assert( (a == 1) == 0, "(a == 1) == 0");
                     ^
test/suites/sccz80/compare_const.c:113:12: style: The comparison 'b != 1' is always false. [knownConditionTrueFalse]
    if ( b != 1 ) { Assert(0, "b != 1"); }
           ^
test/suites/sccz80/compare_const.c:104:14: note: 'b' is assigned value '1' here.
    long b = 1;
             ^
test/suites/sccz80/compare_const.c:113:12: note: The comparison 'b != 1' is always false.
    if ( b != 1 ) { Assert(0, "b != 1"); }
           ^
test/suites/sccz80/compare_const.c:116:12: style: The comparison 'b < 1' is always false. [knownConditionTrueFalse]
    if ( b < 1 ) { Assert(0, "b < 1"); }
           ^
test/suites/sccz80/compare_const.c:104:14: note: 'b' is assigned value '1' here.
    long b = 1;
             ^
test/suites/sccz80/compare_const.c:116:12: note: The comparison 'b < 1' is always false.
    if ( b < 1 ) { Assert(0, "b < 1"); }
           ^
test/suites/sccz80/compare_const.c:118:12: style: The comparison 'b <= 1' is always true. [knownConditionTrueFalse]
    if ( b <= 1 ) {} else { Assert(0, "b <= 1"); }
           ^
test/suites/sccz80/compare_const.c:104:14: note: 'b' is assigned value '1' here.
    long b = 1;
             ^
test/suites/sccz80/compare_const.c:118:12: note: The comparison 'b <= 1' is always true.
    if ( b <= 1 ) {} else { Assert(0, "b <= 1"); }
           ^
test/suites/sccz80/compare_const.c:121:12: style: The comparison 'b > 1' is always false. [knownConditionTrueFalse]
    if ( b > 1 ) { Assert(0, "b > 1"); }
           ^
test/suites/sccz80/compare_const.c:104:14: note: 'b' is assigned value '1' here.
    long b = 1;
             ^
test/suites/sccz80/compare_const.c:121:12: note: The comparison 'b > 1' is always false.
    if ( b > 1 ) { Assert(0, "b > 1"); }
           ^
test/suites/sccz80/compare_const.c:123:12: style: The comparison 'b >= 1' is always true. [knownConditionTrueFalse]
    if ( b >= 1 ) {} else{ Assert(0, "b >= 1"); }
           ^
test/suites/sccz80/compare_const.c:104:14: note: 'b' is assigned value '1' here.
    long b = 1;
             ^
test/suites/sccz80/compare_const.c:123:12: note: The comparison 'b >= 1' is always true.
    if ( b >= 1 ) {} else{ Assert(0, "b >= 1"); }
           ^
test/suites/sccz80/compare_const.c:125:11: style: The comparison 'c < -1000' is always false. [knownConditionTrueFalse]
    if (c < -1000 ) { Assert(0,"c < -1000"); }
          ^
test/suites/sccz80/compare_const.c:105:15: note: 'c' is assigned value '-1000' here.
    long c = -1000;
              ^
test/suites/sccz80/compare_const.c:125:11: note: The comparison 'c < -1000' is always false.
    if (c < -1000 ) { Assert(0,"c < -1000"); }
          ^
test/suites/sccz80/compare_const.c:136:12: style: The comparison 'b == 1' is always true. [knownConditionTrueFalse]
    if ( b == 1 ) { } else { Assert(0, "b == 1"); }
           ^
test/suites/sccz80/compare_const.c:133:23: note: 'b' is assigned value '1' here.
    unsigned long b = 1;
                      ^
test/suites/sccz80/compare_const.c:136:12: note: The comparison 'b == 1' is always true.
    if ( b == 1 ) { } else { Assert(0, "b == 1"); }
           ^
test/suites/sccz80/compare_const.c:137:15: style: The comparison 'b == 1' is always true. [knownConditionTrueFalse]
    Assert( b == 1, "(b == 1)");
              ^
test/suites/sccz80/compare_const.c:133:23: note: 'b' is assigned value '1' here.
    unsigned long b = 1;
                      ^
test/suites/sccz80/compare_const.c:137:15: note: The comparison 'b == 1' is always true.
    Assert( b == 1, "(b == 1)");
              ^
test/suites/sccz80/compare_const.c:138:22: style: The comparison 'a == 0' is always true. [knownConditionTrueFalse]
    Assert( (a == 1) == 0, "(a == 1) == 0");
                     ^
test/suites/sccz80/compare_const.c:132:23: note: 'a' is assigned value '0' here.
    unsigned long a = 0;
                      ^
test/suites/sccz80/compare_const.c:138:22: note: The comparison 'a == 0' is always true.
    Assert( (a == 1) == 0, "(a == 1) == 0");
                     ^
test/suites/sccz80/compare_const.c:141:12: style: The comparison 'b != 1' is always false. [knownConditionTrueFalse]
    if ( b != 1 ) { Assert(0, "b != 1"); }
           ^
test/suites/sccz80/compare_const.c:133:23: note: 'b' is assigned value '1' here.
    unsigned long b = 1;
                      ^
test/suites/sccz80/compare_const.c:141:12: note: The comparison 'b != 1' is always false.
    if ( b != 1 ) { Assert(0, "b != 1"); }
           ^
test/suites/sccz80/compare_const.c:144:12: style: The comparison 'b < 1' is always false. [knownConditionTrueFalse]
    if ( b < 1 ) { Assert(0, "b < 1"); }
           ^
test/suites/sccz80/compare_const.c:133:23: note: 'b' is assigned value '1' here.
    unsigned long b = 1;
                      ^
test/suites/sccz80/compare_const.c:144:12: note: The comparison 'b < 1' is always false.
    if ( b < 1 ) { Assert(0, "b < 1"); }
           ^
test/suites/sccz80/compare_const.c:146:12: style: The comparison 'b <= 1' is always true. [knownConditionTrueFalse]
    if ( b <= 1 ) {} else { Assert(0, "b <= 1"); }
           ^
test/suites/sccz80/compare_const.c:133:23: note: 'b' is assigned value '1' here.
    unsigned long b = 1;
                      ^
test/suites/sccz80/compare_const.c:146:12: note: The comparison 'b <= 1' is always true.
    if ( b <= 1 ) {} else { Assert(0, "b <= 1"); }
           ^
test/suites/sccz80/compare_const.c:149:12: style: The comparison 'b > 1' is always false. [knownConditionTrueFalse]
    if ( b > 1 ) { Assert(0, "b > 1"); }
           ^
test/suites/sccz80/compare_const.c:133:23: note: 'b' is assigned value '1' here.
    unsigned long b = 1;
                      ^
test/suites/sccz80/compare_const.c:149:12: note: The comparison 'b > 1' is always false.
    if ( b > 1 ) { Assert(0, "b > 1"); }
           ^
test/suites/sccz80/compare_const.c:151:12: style: The comparison 'b >= 1' is always true. [knownConditionTrueFalse]
    if ( b >= 1 ) {} else{ Assert(0, "b >= 1"); }
           ^
test/suites/sccz80/compare_const.c:133:23: note: 'b' is assigned value '1' here.
    unsigned long b = 1;
                      ^
test/suites/sccz80/compare_const.c:151:12: note: The comparison 'b >= 1' is always true.
    if ( b >= 1 ) {} else{ Assert(0, "b >= 1"); }
           ^
test/suites/sccz80/compare_mconst.c:10:12: style: Condition 'a==-1' is always false [knownConditionTrueFalse]
    if ( a == -1 ) { Assert(-1, "a == -1"); }
           ^
test/suites/sccz80/compare_mconst.c:7:14: note: Assignment 'a=0', assigned value is 0
    char a = 0;
             ^
test/suites/sccz80/compare_mconst.c:10:12: note: Condition 'a==-1' is always false
    if ( a == -1 ) { Assert(-1, "a == -1"); }
           ^
test/suites/sccz80/compare_mconst.c:34:12: style: Condition 'a==-1' is always false [knownConditionTrueFalse]
    if ( a == -1 ) { Assert(-1, "a == -1"); }
           ^
test/suites/sccz80/compare_mconst.c:31:23: note: Assignment 'a=0', assigned value is 0
    unsigned char a = 0;
                      ^
test/suites/sccz80/compare_mconst.c:34:12: note: Condition 'a==-1' is always false
    if ( a == -1 ) { Assert(-1, "a == -1"); }
           ^
test/suites/sccz80/compare_mconst.c:57:12: style: Condition 'a==-1' is always false [knownConditionTrueFalse]
    if ( a == -1 ) { Assert(-1, "a == -1"); }
           ^
test/suites/sccz80/compare_mconst.c:54:13: note: Assignment 'a=0', assigned value is 0
    int a = 0;
            ^
test/suites/sccz80/compare_mconst.c:57:12: note: Condition 'a==-1' is always false
    if ( a == -1 ) { Assert(-1, "a == -1"); }
           ^
test/suites/sccz80/compare_mconst.c:81:12: style: Condition 'a==-1' is always false [knownConditionTrueFalse]
    if ( a == -1 ) { Assert(-1, "a == -1"); }
           ^
test/suites/sccz80/compare_mconst.c:78:22: note: Assignment 'a=0', assigned value is 0
    unsigned int a = 0;
                     ^
test/suites/sccz80/compare_mconst.c:81:12: note: Condition 'a==-1' is always false
    if ( a == -1 ) { Assert(-1, "a == -1"); }
           ^
test/suites/sccz80/compare_mconst.c:104:12: style: Condition 'a==-1' is always false [knownConditionTrueFalse]
    if ( a == -1 ) { Assert(-1, "a == -1"); }
           ^
test/suites/sccz80/compare_mconst.c:101:14: note: Assignment 'a=0', assigned value is 0
    long a = 0;
             ^
test/suites/sccz80/compare_mconst.c:104:12: note: Condition 'a==-1' is always false
    if ( a == -1 ) { Assert(-1, "a == -1"); }
           ^
test/suites/sccz80/compare_mconst.c:128:12: style: Condition 'a==-1' is always false [knownConditionTrueFalse]
    if ( a == -1 ) { Assert(-1, "a == -1"); }
           ^
test/suites/sccz80/compare_mconst.c:125:23: note: Assignment 'a=0', assigned value is 0
    unsigned long a = 0;
                      ^
test/suites/sccz80/compare_mconst.c:128:12: note: Condition 'a==-1' is always false
    if ( a == -1 ) { Assert(-1, "a == -1"); }
           ^
test/suites/sccz80/compare_mconst.c:11:12: style: The comparison 'b == -1' is always true. [knownConditionTrueFalse]
    if ( b == -1 ) { } else { Assert(-1, "b == -1"); }
           ^
test/suites/sccz80/compare_mconst.c:8:15: note: 'b' is assigned value '-1' here.
    char b = -1;
              ^
test/suites/sccz80/compare_mconst.c:11:12: note: The comparison 'b == -1' is always true.
    if ( b == -1 ) { } else { Assert(-1, "b == -1"); }
           ^
test/suites/sccz80/compare_mconst.c:12:15: style: The comparison 'b == -1' is always true. [knownConditionTrueFalse]
    Assert( b == -1, "(b == -1)");
              ^
test/suites/sccz80/compare_mconst.c:8:15: note: 'b' is assigned value '-1' here.
    char b = -1;
              ^
test/suites/sccz80/compare_mconst.c:12:15: note: The comparison 'b == -1' is always true.
    Assert( b == -1, "(b == -1)");
              ^
test/suites/sccz80/compare_mconst.c:13:23: style: The comparison 'a == 0' is always true. [knownConditionTrueFalse]
    Assert( (a == -1) == 0, "(a == -1) == 0");
                      ^
test/suites/sccz80/compare_mconst.c:7:14: note: 'a' is assigned value '0' here.
    char a = 0;
             ^
test/suites/sccz80/compare_mconst.c:13:23: note: The comparison 'a == 0' is always true.
    Assert( (a == -1) == 0, "(a == -1) == 0");
                      ^
test/suites/sccz80/compare_mconst.c:16:12: style: The comparison 'b != -1' is always false. [knownConditionTrueFalse]
    if ( b != -1 ) { Assert(-1, "b != -1"); }
           ^
test/suites/sccz80/compare_mconst.c:8:15: note: 'b' is assigned value '-1' here.
    char b = -1;
              ^
test/suites/sccz80/compare_mconst.c:16:12: note: The comparison 'b != -1' is always false.
    if ( b != -1 ) { Assert(-1, "b != -1"); }
           ^
test/suites/sccz80/compare_mconst.c:19:12: style: The comparison 'b < -1' is always false. [knownConditionTrueFalse]
    if ( b < -1 ) { Assert(-1, "b < -1"); }
           ^
test/suites/sccz80/compare_mconst.c:8:15: note: 'b' is assigned value '-1' here.
    char b = -1;
              ^
test/suites/sccz80/compare_mconst.c:19:12: note: The comparison 'b < -1' is always false.
    if ( b < -1 ) { Assert(-1, "b < -1"); }
           ^
test/suites/sccz80/compare_mconst.c:21:12: style: The comparison 'b <= -1' is always true. [knownConditionTrueFalse]
    if ( b <= -1 ) {} else { Assert(-1, "b <= -1"); }
           ^
test/suites/sccz80/compare_mconst.c:8:15: note: 'b' is assigned value '-1' here.
    char b = -1;
              ^
test/suites/sccz80/compare_mconst.c:21:12: note: The comparison 'b <= -1' is always true.
    if ( b <= -1 ) {} else { Assert(-1, "b <= -1"); }
           ^
test/suites/sccz80/compare_mconst.c:24:12: style: The comparison 'b > -1' is always false. [knownConditionTrueFalse]
    if ( b > -1 ) { Assert(-1, "b > -1"); }
           ^
test/suites/sccz80/compare_mconst.c:8:15: note: 'b' is assigned value '-1' here.
    char b = -1;
              ^
test/suites/sccz80/compare_mconst.c:24:12: note: The comparison 'b > -1' is always false.
    if ( b > -1 ) { Assert(-1, "b > -1"); }
           ^
test/suites/sccz80/compare_mconst.c:26:12: style: The comparison 'b >= -1' is always true. [knownConditionTrueFalse]
    if ( b >= -1 ) {} else{ Assert(-1, "b >= -1"); }
           ^
test/suites/sccz80/compare_mconst.c:8:15: note: 'b' is assigned value '-1' here.
    char b = -1;
              ^
test/suites/sccz80/compare_mconst.c:26:12: note: The comparison 'b >= -1' is always true.
    if ( b >= -1 ) {} else{ Assert(-1, "b >= -1"); }
           ^
test/suites/sccz80/compare_mconst.c:35:12: style: The comparison 'b == -1' is always true. [knownConditionTrueFalse]
    if ( b == -1 ) { } else { Assert(-1, "b == -1"); }
           ^
test/suites/sccz80/compare_mconst.c:32:24: note: 'b' is assigned value '-1' here.
    unsigned char b = -1;
                       ^
test/suites/sccz80/compare_mconst.c:35:12: note: The comparison 'b == -1' is always true.
    if ( b == -1 ) { } else { Assert(-1, "b == -1"); }
           ^
test/suites/sccz80/compare_mconst.c:36:23: style: The comparison 'a == 0' is always true. [knownConditionTrueFalse]
    Assert( (a == -1) == 0, "(a == -1) == 0");
                      ^
test/suites/sccz80/compare_mconst.c:31:23: note: 'a' is assigned value '0' here.
    unsigned char a = 0;
                      ^
test/suites/sccz80/compare_mconst.c:36:23: note: The comparison 'a == 0' is always true.
    Assert( (a == -1) == 0, "(a == -1) == 0");
                      ^
test/suites/sccz80/compare_mconst.c:39:12: style: The comparison 'b != -1' is always false. [knownConditionTrueFalse]
    if ( b != -1 ) { Assert(-1, "b != -1"); }
           ^
test/suites/sccz80/compare_mconst.c:32:24: note: 'b' is assigned value '-1' here.
    unsigned char b = -1;
                       ^
test/suites/sccz80/compare_mconst.c:39:12: note: The comparison 'b != -1' is always false.
    if ( b != -1 ) { Assert(-1, "b != -1"); }
           ^
test/suites/sccz80/compare_mconst.c:42:12: style: The comparison 'b < -1' is always false. [knownConditionTrueFalse]
    if ( b < -1 ) { Assert(-1, "b < -1"); }
           ^
test/suites/sccz80/compare_mconst.c:32:24: note: 'b' is assigned value '-1' here.
    unsigned char b = -1;
                       ^
test/suites/sccz80/compare_mconst.c:42:12: note: The comparison 'b < -1' is always false.
    if ( b < -1 ) { Assert(-1, "b < -1"); }
           ^
test/suites/sccz80/compare_mconst.c:44:12: style: The comparison 'b <= -1' is always true. [knownConditionTrueFalse]
    if ( b <= -1 ) {} else { Assert(-1, "b <= -1"); }
           ^
test/suites/sccz80/compare_mconst.c:32:24: note: 'b' is assigned value '-1' here.
    unsigned char b = -1;
                       ^
test/suites/sccz80/compare_mconst.c:44:12: note: The comparison 'b <= -1' is always true.
    if ( b <= -1 ) {} else { Assert(-1, "b <= -1"); }
           ^
test/suites/sccz80/compare_mconst.c:47:12: style: The comparison 'b > -1' is always false. [knownConditionTrueFalse]
    if ( b > -1 ) { Assert(-1, "b > -1"); }
           ^
test/suites/sccz80/compare_mconst.c:32:24: note: 'b' is assigned value '-1' here.
    unsigned char b = -1;
                       ^
test/suites/sccz80/compare_mconst.c:47:12: note: The comparison 'b > -1' is always false.
    if ( b > -1 ) { Assert(-1, "b > -1"); }
           ^
test/suites/sccz80/compare_mconst.c:49:12: style: The comparison 'b >= -1' is always true. [knownConditionTrueFalse]
    if ( b >= -1 ) {} else{ Assert(-1, "b >= -1"); }
           ^
test/suites/sccz80/compare_mconst.c:32:24: note: 'b' is assigned value '-1' here.
    unsigned char b = -1;
                       ^
test/suites/sccz80/compare_mconst.c:49:12: note: The comparison 'b >= -1' is always true.
    if ( b >= -1 ) {} else{ Assert(-1, "b >= -1"); }
           ^
test/suites/sccz80/compare_mconst.c:58:12: style: The comparison 'b == -1' is always true. [knownConditionTrueFalse]
    if ( b == -1 ) { } else { Assert(-1, "b == -1"); }
           ^
test/suites/sccz80/compare_mconst.c:55:14: note: 'b' is assigned value '-1' here.
    int b = -1;
             ^
test/suites/sccz80/compare_mconst.c:58:12: note: The comparison 'b == -1' is always true.
    if ( b == -1 ) { } else { Assert(-1, "b == -1"); }
           ^
test/suites/sccz80/compare_mconst.c:59:15: style: The comparison 'b == -1' is always true. [knownConditionTrueFalse]
    Assert( b == -1, "(b == -1)");
              ^
test/suites/sccz80/compare_mconst.c:55:14: note: 'b' is assigned value '-1' here.
    int b = -1;
             ^
test/suites/sccz80/compare_mconst.c:59:15: note: The comparison 'b == -1' is always true.
    Assert( b == -1, "(b == -1)");
              ^
test/suites/sccz80/compare_mconst.c:60:23: style: The comparison 'a == 0' is always true. [knownConditionTrueFalse]
    Assert( (a == -1) == 0, "(a == -1) == 0");
                      ^
test/suites/sccz80/compare_mconst.c:54:13: note: 'a' is assigned value '0' here.
    int a = 0;
            ^
test/suites/sccz80/compare_mconst.c:60:23: note: The comparison 'a == 0' is always true.
    Assert( (a == -1) == 0, "(a == -1) == 0");
                      ^
test/suites/sccz80/compare_mconst.c:63:12: style: The comparison 'b != -1' is always false. [knownConditionTrueFalse]
    if ( b != -1 ) { Assert(-1, "b != -1"); }
           ^
test/suites/sccz80/compare_mconst.c:55:14: note: 'b' is assigned value '-1' here.
    int b = -1;
             ^
test/suites/sccz80/compare_mconst.c:63:12: note: The comparison 'b != -1' is always false.
    if ( b != -1 ) { Assert(-1, "b != -1"); }
           ^
test/suites/sccz80/compare_mconst.c:66:12: style: The comparison 'b < -1' is always false. [knownConditionTrueFalse]
    if ( b < -1 ) { Assert(-1, "b < -1"); }
           ^
test/suites/sccz80/compare_mconst.c:55:14: note: 'b' is assigned value '-1' here.
    int b = -1;
             ^
test/suites/sccz80/compare_mconst.c:66:12: note: The comparison 'b < -1' is always false.
    if ( b < -1 ) { Assert(-1, "b < -1"); }
           ^
test/suites/sccz80/compare_mconst.c:68:12: style: The comparison 'b <= -1' is always true. [knownConditionTrueFalse]
    if ( b <= -1 ) {} else { Assert(-1, "b <= -1"); }
           ^
test/suites/sccz80/compare_mconst.c:55:14: note: 'b' is assigned value '-1' here.
    int b = -1;
             ^
test/suites/sccz80/compare_mconst.c:68:12: note: The comparison 'b <= -1' is always true.
    if ( b <= -1 ) {} else { Assert(-1, "b <= -1"); }
           ^
test/suites/sccz80/compare_mconst.c:71:12: style: The comparison 'b > -1' is always false. [knownConditionTrueFalse]
    if ( b > -1 ) { Assert(-1, "b > -1"); }
           ^
test/suites/sccz80/compare_mconst.c:55:14: note: 'b' is assigned value '-1' here.
    int b = -1;
             ^
test/suites/sccz80/compare_mconst.c:71:12: note: The comparison 'b > -1' is always false.
    if ( b > -1 ) { Assert(-1, "b > -1"); }
           ^
test/suites/sccz80/compare_mconst.c:73:12: style: The comparison 'b >= -1' is always true. [knownConditionTrueFalse]
    if ( b >= -1 ) {} else{ Assert(-1, "b >= -1"); }
           ^
test/suites/sccz80/compare_mconst.c:55:14: note: 'b' is assigned value '-1' here.
    int b = -1;
             ^
test/suites/sccz80/compare_mconst.c:73:12: note: The comparison 'b >= -1' is always true.
    if ( b >= -1 ) {} else{ Assert(-1, "b >= -1"); }
           ^
test/suites/sccz80/compare_mconst.c:82:12: style: The comparison 'b == -1' is always true. [knownConditionTrueFalse]
    if ( b == -1 ) { } else { Assert(-1, "b == -1"); }
           ^
test/suites/sccz80/compare_mconst.c:79:23: note: 'b' is assigned value '-1' here.
    unsigned int b = -1;
                      ^
test/suites/sccz80/compare_mconst.c:82:12: note: The comparison 'b == -1' is always true.
    if ( b == -1 ) { } else { Assert(-1, "b == -1"); }
           ^
test/suites/sccz80/compare_mconst.c:83:23: style: The comparison 'a == 0' is always true. [knownConditionTrueFalse]
    Assert( (a == -1) == 0, "(a == -1) == 0");
                      ^
test/suites/sccz80/compare_mconst.c:78:22: note: 'a' is assigned value '0' here.
    unsigned int a = 0;
                     ^
test/suites/sccz80/compare_mconst.c:83:23: note: The comparison 'a == 0' is always true.
    Assert( (a == -1) == 0, "(a == -1) == 0");
                      ^
test/suites/sccz80/compare_mconst.c:86:12: style: The comparison 'b != -1' is always false. [knownConditionTrueFalse]
    if ( b != -1 ) { Assert(-1, "b != -1"); }
           ^
test/suites/sccz80/compare_mconst.c:79:23: note: 'b' is assigned value '-1' here.
    unsigned int b = -1;
                      ^
test/suites/sccz80/compare_mconst.c:86:12: note: The comparison 'b != -1' is always false.
    if ( b != -1 ) { Assert(-1, "b != -1"); }
           ^
test/suites/sccz80/compare_mconst.c:89:12: style: The comparison 'b < -1' is always false. [knownConditionTrueFalse]
    if ( b < -1 ) { Assert(-1, "b < -1"); }
           ^
test/suites/sccz80/compare_mconst.c:79:23: note: 'b' is assigned value '-1' here.
    unsigned int b = -1;
                      ^
test/suites/sccz80/compare_mconst.c:89:12: note: The comparison 'b < -1' is always false.
    if ( b < -1 ) { Assert(-1, "b < -1"); }
           ^
test/suites/sccz80/compare_mconst.c:91:12: style: The comparison 'b <= -1' is always true. [knownConditionTrueFalse]
    if ( b <= -1 ) {} else { Assert(-1, "b <= -1"); }
           ^
test/suites/sccz80/compare_mconst.c:79:23: note: 'b' is assigned value '-1' here.
    unsigned int b = -1;
                      ^
test/suites/sccz80/compare_mconst.c:91:12: note: The comparison 'b <= -1' is always true.
    if ( b <= -1 ) {} else { Assert(-1, "b <= -1"); }
           ^
test/suites/sccz80/compare_mconst.c:94:12: style: The comparison 'b > -1' is always false. [knownConditionTrueFalse]
    if ( b > -1 ) { Assert(-1, "b > -1"); }
           ^
test/suites/sccz80/compare_mconst.c:79:23: note: 'b' is assigned value '-1' here.
    unsigned int b = -1;
                      ^
test/suites/sccz80/compare_mconst.c:94:12: note: The comparison 'b > -1' is always false.
    if ( b > -1 ) { Assert(-1, "b > -1"); }
           ^
test/suites/sccz80/compare_mconst.c:96:12: style: The comparison 'b >= -1' is always true. [knownConditionTrueFalse]
    if ( b >= -1 ) {} else{ Assert(-1, "b >= -1"); }
           ^
test/suites/sccz80/compare_mconst.c:79:23: note: 'b' is assigned value '-1' here.
    unsigned int b = -1;
                      ^
test/suites/sccz80/compare_mconst.c:96:12: note: The comparison 'b >= -1' is always true.
    if ( b >= -1 ) {} else{ Assert(-1, "b >= -1"); }
           ^
test/suites/sccz80/compare_mconst.c:105:12: style: The comparison 'b == -1' is always true. [knownConditionTrueFalse]
    if ( b == -1 ) { } else { Assert(-1, "b == -1"); }
           ^
test/suites/sccz80/compare_mconst.c:102:15: note: 'b' is assigned value '-1' here.
    long b = -1;
              ^
test/suites/sccz80/compare_mconst.c:105:12: note: The comparison 'b == -1' is always true.
    if ( b == -1 ) { } else { Assert(-1, "b == -1"); }
           ^
test/suites/sccz80/compare_mconst.c:106:15: style: The comparison 'b == -1' is always true. [knownConditionTrueFalse]
    Assert( b == -1, "(b == -1)");
              ^
test/suites/sccz80/compare_mconst.c:102:15: note: 'b' is assigned value '-1' here.
    long b = -1;
              ^
test/suites/sccz80/compare_mconst.c:106:15: note: The comparison 'b == -1' is always true.
    Assert( b == -1, "(b == -1)");
              ^
test/suites/sccz80/compare_mconst.c:107:23: style: The comparison 'a == 0' is always true. [knownConditionTrueFalse]
    Assert( (a == -1) == 0, "(a == -1) == 0");
                      ^
test/suites/sccz80/compare_mconst.c:101:14: note: 'a' is assigned value '0' here.
    long a = 0;
             ^
test/suites/sccz80/compare_mconst.c:107:23: note: The comparison 'a == 0' is always true.
    Assert( (a == -1) == 0, "(a == -1) == 0");
                      ^
test/suites/sccz80/compare_mconst.c:110:12: style: The comparison 'b != -1' is always false. [knownConditionTrueFalse]
    if ( b != -1 ) { Assert(-1, "b != -1"); }
           ^
test/suites/sccz80/compare_mconst.c:102:15: note: 'b' is assigned value '-1' here.
    long b = -1;
              ^
test/suites/sccz80/compare_mconst.c:110:12: note: The comparison 'b != -1' is always false.
    if ( b != -1 ) { Assert(-1, "b != -1"); }
           ^
test/suites/sccz80/compare_mconst.c:113:12: style: The comparison 'b < -1' is always false. [knownConditionTrueFalse]
    if ( b < -1 ) { Assert(-1, "b < -1"); }
           ^
test/suites/sccz80/compare_mconst.c:102:15: note: 'b' is assigned value '-1' here.
    long b = -1;
              ^
test/suites/sccz80/compare_mconst.c:113:12: note: The comparison 'b < -1' is always false.
    if ( b < -1 ) { Assert(-1, "b < -1"); }
           ^
test/suites/sccz80/compare_mconst.c:115:12: style: The comparison 'b <= -1' is always true. [knownConditionTrueFalse]
    if ( b <= -1 ) {} else { Assert(-1, "b <= -1"); }
           ^
test/suites/sccz80/compare_mconst.c:102:15: note: 'b' is assigned value '-1' here.
    long b = -1;
              ^
test/suites/sccz80/compare_mconst.c:115:12: note: The comparison 'b <= -1' is always true.
    if ( b <= -1 ) {} else { Assert(-1, "b <= -1"); }
           ^
test/suites/sccz80/compare_mconst.c:118:12: style: The comparison 'b > -1' is always false. [knownConditionTrueFalse]
    if ( b > -1 ) { Assert(-1, "b > -1"); }
           ^
test/suites/sccz80/compare_mconst.c:102:15: note: 'b' is assigned value '-1' here.
    long b = -1;
              ^
test/suites/sccz80/compare_mconst.c:118:12: note: The comparison 'b > -1' is always false.
    if ( b > -1 ) { Assert(-1, "b > -1"); }
           ^
test/suites/sccz80/compare_mconst.c:120:12: style: The comparison 'b >= -1' is always true. [knownConditionTrueFalse]
    if ( b >= -1 ) {} else{ Assert(-1, "b >= -1"); }
           ^
test/suites/sccz80/compare_mconst.c:102:15: note: 'b' is assigned value '-1' here.
    long b = -1;
              ^
test/suites/sccz80/compare_mconst.c:120:12: note: The comparison 'b >= -1' is always true.
    if ( b >= -1 ) {} else{ Assert(-1, "b >= -1"); }
           ^
test/suites/sccz80/compare_mconst.c:129:12: style: The comparison 'b == -1' is always true. [knownConditionTrueFalse]
    if ( b == -1 ) { } else { Assert(-1, "b == -1"); }
           ^
test/suites/sccz80/compare_mconst.c:126:24: note: 'b' is assigned value '-1' here.
    unsigned long b = -1;
                       ^
test/suites/sccz80/compare_mconst.c:129:12: note: The comparison 'b == -1' is always true.
    if ( b == -1 ) { } else { Assert(-1, "b == -1"); }
           ^
test/suites/sccz80/compare_mconst.c:130:15: style: The comparison 'b == -1' is always true. [knownConditionTrueFalse]
    Assert( b == -1, "(b == -1)");
              ^
test/suites/sccz80/compare_mconst.c:126:24: note: 'b' is assigned value '-1' here.
    unsigned long b = -1;
                       ^
test/suites/sccz80/compare_mconst.c:130:15: note: The comparison 'b == -1' is always true.
    Assert( b == -1, "(b == -1)");
              ^
test/suites/sccz80/compare_mconst.c:131:23: style: The comparison 'a == 0' is always true. [knownConditionTrueFalse]
    Assert( (a == -1) == 0, "(a == -1) == 0");
                      ^
test/suites/sccz80/compare_mconst.c:125:23: note: 'a' is assigned value '0' here.
    unsigned long a = 0;
                      ^
test/suites/sccz80/compare_mconst.c:131:23: note: The comparison 'a == 0' is always true.
    Assert( (a == -1) == 0, "(a == -1) == 0");
                      ^
test/suites/sccz80/compare_mconst.c:134:12: style: The comparison 'b != -1' is always false. [knownConditionTrueFalse]
    if ( b != -1 ) { Assert(-1, "b != -1"); }
           ^
test/suites/sccz80/compare_mconst.c:126:24: note: 'b' is assigned value '-1' here.
    unsigned long b = -1;
                       ^
test/suites/sccz80/compare_mconst.c:134:12: note: The comparison 'b != -1' is always false.
    if ( b != -1 ) { Assert(-1, "b != -1"); }
           ^
test/suites/sccz80/compare_mconst.c:137:12: style: The comparison 'b < -1' is always false. [knownConditionTrueFalse]
    if ( b < -1 ) { Assert(-1, "b < -1"); }
           ^
test/suites/sccz80/compare_mconst.c:126:24: note: 'b' is assigned value '-1' here.
    unsigned long b = -1;
                       ^
test/suites/sccz80/compare_mconst.c:137:12: note: The comparison 'b < -1' is always false.
    if ( b < -1 ) { Assert(-1, "b < -1"); }
           ^
test/suites/sccz80/compare_mconst.c:139:12: style: The comparison 'b <= -1' is always true. [knownConditionTrueFalse]
    if ( b <= -1 ) {} else { Assert(-1, "b <= -1"); }
           ^
test/suites/sccz80/compare_mconst.c:126:24: note: 'b' is assigned value '-1' here.
    unsigned long b = -1;
                       ^
test/suites/sccz80/compare_mconst.c:139:12: note: The comparison 'b <= -1' is always true.
    if ( b <= -1 ) {} else { Assert(-1, "b <= -1"); }
           ^
test/suites/sccz80/compare_mconst.c:142:12: style: The comparison 'b > -1' is always false. [knownConditionTrueFalse]
    if ( b > -1 ) { Assert(-1, "b > -1"); }
           ^
test/suites/sccz80/compare_mconst.c:126:24: note: 'b' is assigned value '-1' here.
    unsigned long b = -1;
                       ^
test/suites/sccz80/compare_mconst.c:142:12: note: The comparison 'b > -1' is always false.
    if ( b > -1 ) { Assert(-1, "b > -1"); }
           ^
test/suites/sccz80/compare_mconst.c:144:12: style: The comparison 'b >= -1' is always true. [knownConditionTrueFalse]
    if ( b >= -1 ) {} else{ Assert(-1, "b >= -1"); }
           ^
test/suites/sccz80/compare_mconst.c:126:24: note: 'b' is assigned value '-1' here.
    unsigned long b = -1;
                       ^
test/suites/sccz80/compare_mconst.c:144:12: note: The comparison 'b >= -1' is always true.
    if ( b >= -1 ) {} else{ Assert(-1, "b >= -1"); }
           ^
test/suites/sccz80/division.c:81:23: warning: Comparison of modulo result is predetermined, because it is always less than -4. [moduloAlwaysTrueFalse]
    Assert( val % -4  == -1, "-1 % -4");
                      ^
test/suites/sccz80/division.c:83:24: warning: Comparison of modulo result is predetermined, because it is always less than -16. [moduloAlwaysTrueFalse]
    Assert( val % -16  == -1, "-1 % -16");
                       ^
test/suites/sccz80/division.c:84:25: warning: Comparison of modulo result is predetermined, because it is always less than -32. [moduloAlwaysTrueFalse]
    Assert( -val % -32  == 1, " 1 % -32");
                        ^
test/suites/sccz80/division.c:86:26: warning: Comparison of modulo result is predetermined, because it is always less than -128. [moduloAlwaysTrueFalse]
    Assert( -val % -128  == 1, " 1 % -128");
                         ^
test/suites/sccz80/division.c:51:18: style: Same expression on both sides of '/'. [duplicateExpression]
     Assert( val / -256  == 1, "-256 / -256");
                 ^
test/suites/sccz80/division.c:43:21: note: 'val' is assigned value '-256' here.
     int32_t val = -256;
                    ^
test/suites/sccz80/division.c:51:18: note: Same expression on both sides of '/'.
     Assert( val / -256  == 1, "-256 / -256");
                 ^
test/suites/sccz80/division.c:10:15: style: Unused variable: res [unusedVariable]
     uint64_t res;
              ^
test/suites/sccz80/division.c:28:15: style: Unused variable: res [unusedVariable]
     uint32_t res;
              ^
test/suites/sccz80/fastcall.c:56:20: error: Uninitialized variable: func [uninitvar]
   long long ret = func(3,5);
                   ^
test/suites/sccz80/fastcall.c:73:20: error: Uninitialized variable: func [uninitvar]
   long long ret = func(3,5);
                   ^
test/suites/sccz80/loops.c:54:20: style: Variable '*p' is reassigned a value before the old one has been used. [redundantAssignment]
                *p = (1UL << 30);
                   ^
test/suites/sccz80/loops.c:52:20: note: *p is assigned
                *p = 18;
                   ^
test/suites/sccz80/loops.c:54:20: note: *p is overwritten
                *p = (1UL << 30);
                   ^
test/suites/sccz80/loops.c:155:25: style: Local variable 'i' shadows outer variable [shadowVariable]
                for(int i = 0; i < 2; i++)
                        ^
test/suites/sccz80/loops.c:153:21: note: Shadowed declaration
                int i = 23;
                    ^
test/suites/sccz80/loops.c:155:25: note: Shadow variable
                for(int i = 0; i < 2; i++)
                        ^
test/suites/sccz80/loops.c:157:29: style: Local variable 'i' shadows outer variable [shadowVariable]
                        int i = 42;
                            ^
test/suites/sccz80/loops.c:153:21: note: Shadowed declaration
                int i = 23;
                    ^
test/suites/sccz80/loops.c:157:29: note: Shadow variable
                        int i = 42;
                            ^
test/suites/sccz80/lshift.c:356:37: style:inconclusive: Boolean expression 'val<<15==(1<<15)' is used in bitwise operation. Did you mean '&&'? [bitwiseOnBoolean]
     Assert( val << 15 == (1 << 15) & 0xffff, "<<15");
                                    ^
test/suites/sccz80/lshift.c:356:37: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
     Assert( val << 15 == (1 << 15) & 0xffff, "<<15");
                                    ^
test/suites/sccz80/lshift.c:11:23: style: The comparison 'val<<v == 1<<0' is always true because 'val<<v' and '1<<0' represent the same value. [knownConditionTrueFalse]
     Assert( val << v == 1  << 0, "<<0");
                      ^
test/suites/sccz80/lshift.c:7:16: note: 'val' is assigned value '1' here.
     int val = 1;
               ^
test/suites/sccz80/lshift.c:8:15: note: 'v' is assigned value '0' here.
     int  v = 0;
              ^
test/suites/sccz80/lshift.c:11:23: note: The comparison 'val<<v == 1<<0' is always true because 'val<<v' and '1<<0' represent the same value.
     Assert( val << v == 1  << 0, "<<0");
                      ^
test/suites/sccz80/lshift.c:341:23: style: The comparison 'val<<0 == 1<<0' is always true because 'val<<0' and '1<<0' represent the same value. [knownConditionTrueFalse]
     Assert( val << 0 == 1 << 0, "<<0");
                      ^
test/suites/sccz80/lshift.c:338:16: note: 'val' is assigned value '1' here.
     int val = 1;
               ^
test/suites/sccz80/lshift.c:341:23: note: The comparison 'val<<0 == 1<<0' is always true because 'val<<0' and '1<<0' represent the same value.
     Assert( val << 0 == 1 << 0, "<<0");
                      ^
test/suites/sccz80/lshift.c:342:23: style: The comparison 'val<<1 == 1<<1' is always true because 'val<<1' and '1<<1' represent the same value. [knownConditionTrueFalse]
     Assert( val << 1 == 1 << 1, "<<1");
                      ^
test/suites/sccz80/lshift.c:338:16: note: 'val' is assigned value '1' here.
     int val = 1;
               ^
test/suites/sccz80/lshift.c:342:23: note: The comparison 'val<<1 == 1<<1' is always true because 'val<<1' and '1<<1' represent the same value.
     Assert( val << 1 == 1 << 1, "<<1");
                      ^
test/suites/sccz80/lshift.c:343:23: style: The comparison 'val<<2 == 1<<2' is always true because 'val<<2' and '1<<2' represent the same value. [knownConditionTrueFalse]
     Assert( val << 2 == 1 << 2, "<<2");
                      ^
test/suites/sccz80/lshift.c:338:16: note: 'val' is assigned value '1' here.
     int val = 1;
               ^
test/suites/sccz80/lshift.c:343:23: note: The comparison 'val<<2 == 1<<2' is always true because 'val<<2' and '1<<2' represent the same value.
     Assert( val << 2 == 1 << 2, "<<2");
                      ^
test/suites/sccz80/lshift.c:344:23: style: The comparison 'val<<3 == 1<<3' is always true because 'val<<3' and '1<<3' represent the same value. [knownConditionTrueFalse]
     Assert( val << 3 == 1 << 3, "<<3");
                      ^
test/suites/sccz80/lshift.c:338:16: note: 'val' is assigned value '1' here.
     int val = 1;
               ^
test/suites/sccz80/lshift.c:344:23: note: The comparison 'val<<3 == 1<<3' is always true because 'val<<3' and '1<<3' represent the same value.
     Assert( val << 3 == 1 << 3, "<<3");
                      ^
test/suites/sccz80/lshift.c:345:23: style: The comparison 'val<<4 == 1<<4' is always true because 'val<<4' and '1<<4' represent the same value. [knownConditionTrueFalse]
     Assert( val << 4 == 1 << 4, "<<4");
                      ^
test/suites/sccz80/lshift.c:338:16: note: 'val' is assigned value '1' here.
     int val = 1;
               ^
test/suites/sccz80/lshift.c:345:23: note: The comparison 'val<<4 == 1<<4' is always true because 'val<<4' and '1<<4' represent the same value.
     Assert( val << 4 == 1 << 4, "<<4");
                      ^
test/suites/sccz80/lshift.c:346:23: style: The comparison 'val<<5 == 1<<5' is always true because 'val<<5' and '1<<5' represent the same value. [knownConditionTrueFalse]
     Assert( val << 5 == 1 << 5, "<<5");
                      ^
test/suites/sccz80/lshift.c:338:16: note: 'val' is assigned value '1' here.
     int val = 1;
               ^
test/suites/sccz80/lshift.c:346:23: note: The comparison 'val<<5 == 1<<5' is always true because 'val<<5' and '1<<5' represent the same value.
     Assert( val << 5 == 1 << 5, "<<5");
                      ^
test/suites/sccz80/lshift.c:347:23: style: The comparison 'val<<6 == 1<<6' is always true because 'val<<6' and '1<<6' represent the same value. [knownConditionTrueFalse]
     Assert( val << 6 == 1 << 6, "<<6");
                      ^
test/suites/sccz80/lshift.c:338:16: note: 'val' is assigned value '1' here.
     int val = 1;
               ^
test/suites/sccz80/lshift.c:347:23: note: The comparison 'val<<6 == 1<<6' is always true because 'val<<6' and '1<<6' represent the same value.
     Assert( val << 6 == 1 << 6, "<<6");
                      ^
test/suites/sccz80/lshift.c:348:23: style: The comparison 'val<<7 == 1<<7' is always true because 'val<<7' and '1<<7' represent the same value. [knownConditionTrueFalse]
     Assert( val << 7 == 1 << 7, "<<7");
                      ^
test/suites/sccz80/lshift.c:338:16: note: 'val' is assigned value '1' here.
     int val = 1;
               ^
test/suites/sccz80/lshift.c:348:23: note: The comparison 'val<<7 == 1<<7' is always true because 'val<<7' and '1<<7' represent the same value.
     Assert( val << 7 == 1 << 7, "<<7");
                      ^
test/suites/sccz80/lshift.c:349:23: style: The comparison 'val<<8 == 1<<8' is always true because 'val<<8' and '1<<8' represent the same value. [knownConditionTrueFalse]
     Assert( val << 8 == 1 << 8, "<<8");
                      ^
test/suites/sccz80/lshift.c:338:16: note: 'val' is assigned value '1' here.
     int val = 1;
               ^
test/suites/sccz80/lshift.c:349:23: note: The comparison 'val<<8 == 1<<8' is always true because 'val<<8' and '1<<8' represent the same value.
     Assert( val << 8 == 1 << 8, "<<8");
                      ^
test/suites/sccz80/lshift.c:350:23: style: The comparison 'val<<9 == 1<<9' is always true because 'val<<9' and '1<<9' represent the same value. [knownConditionTrueFalse]
     Assert( val << 9 == 1 << 9, "<<9");
                      ^
test/suites/sccz80/lshift.c:338:16: note: 'val' is assigned value '1' here.
     int val = 1;
               ^
test/suites/sccz80/lshift.c:350:23: note: The comparison 'val<<9 == 1<<9' is always true because 'val<<9' and '1<<9' represent the same value.
     Assert( val << 9 == 1 << 9, "<<9");
                      ^
test/suites/sccz80/lshift.c:351:24: style: The comparison 'val<<10 == 1<<10' is always true because 'val<<10' and '1<<10' represent the same value. [knownConditionTrueFalse]
     Assert( val << 10 == 1 << 10, "<<10");
                       ^
test/suites/sccz80/lshift.c:338:16: note: 'val' is assigned value '1' here.
     int val = 1;
               ^
test/suites/sccz80/lshift.c:351:24: note: The comparison 'val<<10 == 1<<10' is always true because 'val<<10' and '1<<10' represent the same value.
     Assert( val << 10 == 1 << 10, "<<10");
                       ^
test/suites/sccz80/lshift.c:352:24: style: The comparison 'val<<11 == 1<<11' is always true because 'val<<11' and '1<<11' represent the same value. [knownConditionTrueFalse]
     Assert( val << 11 == 1 << 11, "<<11");
                       ^
test/suites/sccz80/lshift.c:338:16: note: 'val' is assigned value '1' here.
     int val = 1;
               ^
test/suites/sccz80/lshift.c:352:24: note: The comparison 'val<<11 == 1<<11' is always true because 'val<<11' and '1<<11' represent the same value.
     Assert( val << 11 == 1 << 11, "<<11");
                       ^
test/suites/sccz80/lshift.c:353:24: style: The comparison 'val<<12 == 1<<12' is always true because 'val<<12' and '1<<12' represent the same value. [knownConditionTrueFalse]
     Assert( val << 12 == 1 << 12, "<<12");
                       ^
test/suites/sccz80/lshift.c:338:16: note: 'val' is assigned value '1' here.
     int val = 1;
               ^
test/suites/sccz80/lshift.c:353:24: note: The comparison 'val<<12 == 1<<12' is always true because 'val<<12' and '1<<12' represent the same value.
     Assert( val << 12 == 1 << 12, "<<12");
                       ^
test/suites/sccz80/lshift.c:354:24: style: The comparison 'val<<13 == 1<<13' is always true because 'val<<13' and '1<<13' represent the same value. [knownConditionTrueFalse]
     Assert( val << 13 == 1 << 13, "<<13");
                       ^
test/suites/sccz80/lshift.c:338:16: note: 'val' is assigned value '1' here.
     int val = 1;
               ^
test/suites/sccz80/lshift.c:354:24: note: The comparison 'val<<13 == 1<<13' is always true because 'val<<13' and '1<<13' represent the same value.
     Assert( val << 13 == 1 << 13, "<<13");
                       ^
test/suites/sccz80/lshift.c:355:24: style: The comparison 'val<<14 == 1<<14' is always true because 'val<<14' and '1<<14' represent the same value. [knownConditionTrueFalse]
     Assert( val << 14 == 1 << 14, "<<14");
                       ^
test/suites/sccz80/lshift.c:338:16: note: 'val' is assigned value '1' here.
     int val = 1;
               ^
test/suites/sccz80/lshift.c:355:24: note: The comparison 'val<<14 == 1<<14' is always true because 'val<<14' and '1<<14' represent the same value.
     Assert( val << 14 == 1 << 14, "<<14");
                       ^
test/suites/sccz80/lshift.c:356:24: style: The comparison 'val<<15 == 1<<15' is always true because 'val<<15' and '1<<15' represent the same value. [knownConditionTrueFalse]
     Assert( val << 15 == (1 << 15) & 0xffff, "<<15");
                       ^
test/suites/sccz80/lshift.c:338:16: note: 'val' is assigned value '1' here.
     int val = 1;
               ^
test/suites/sccz80/lshift.c:356:24: note: The comparison 'val<<15 == 1<<15' is always true because 'val<<15' and '1<<15' represent the same value.
     Assert( val << 15 == (1 << 15) & 0xffff, "<<15");
                       ^
test/suites/sccz80/lshift.c:258:18: portability: Shifting signed 64-bit value by 63 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
     Assert( val << v == 1LL << 63, "<<63");
                 ^
test/suites/sccz80/lshift.c:129:15: note: Assignment 'v=0', assigned value is 0
     int  v = 0;
              ^
test/suites/sccz80/lshift.c:133:8: note: v is incremented', new value is 1
     ++v;
       ^
test/suites/sccz80/lshift.c:135:8: note: v is incremented', new value is 2
     ++v;
       ^
test/suites/sccz80/lshift.c:137:8: note: v is incremented', new value is 3
     ++v;
       ^
test/suites/sccz80/lshift.c:139:8: note: v is incremented', new value is 4
     ++v;
       ^
test/suites/sccz80/lshift.c:141:8: note: v is incremented', new value is 5
     ++v;
       ^
test/suites/sccz80/lshift.c:143:8: note: v is incremented', new value is 6
     ++v;
       ^
test/suites/sccz80/lshift.c:145:8: note: v is incremented', new value is 7
     ++v;
       ^
test/suites/sccz80/lshift.c:147:8: note: v is incremented', new value is 8
     ++v;
       ^
test/suites/sccz80/lshift.c:149:8: note: v is incremented', new value is 9
     ++v;
       ^
test/suites/sccz80/lshift.c:151:8: note: v is incremented', new value is 10
     ++v;
       ^
test/suites/sccz80/lshift.c:153:8: note: v is incremented', new value is 11
     ++v;
       ^
test/suites/sccz80/lshift.c:155:8: note: v is incremented', new value is 12
     ++v;
       ^
test/suites/sccz80/lshift.c:157:8: note: v is incremented', new value is 13
     ++v;
       ^
test/suites/sccz80/lshift.c:159:8: note: v is incremented', new value is 14
     ++v;
       ^
test/suites/sccz80/lshift.c:161:8: note: v is incremented', new value is 15
     ++v;
       ^
test/suites/sccz80/lshift.c:163:8: note: v is incremented', new value is 16
     ++v;
       ^
test/suites/sccz80/lshift.c:165:8: note: v is incremented', new value is 17
     ++v;
       ^
test/suites/sccz80/lshift.c:167:8: note: v is incremented', new value is 18
     ++v;
       ^
test/suites/sccz80/lshift.c:169:8: note: v is incremented', new value is 19
     ++v;
       ^
test/suites/sccz80/lshift.c:171:8: note: v is incremented', new value is 20
     ++v;
       ^
test/suites/sccz80/lshift.c:173:8: note: v is incremented', new value is 21
     ++v;
       ^
test/suites/sccz80/lshift.c:175:8: note: v is incremented', new value is 22
     ++v;
       ^
test/suites/sccz80/lshift.c:177:8: note: v is incremented', new value is 23
     ++v;
       ^
test/suites/sccz80/lshift.c:179:8: note: v is incremented', new value is 24
     ++v;
       ^
test/suites/sccz80/lshift.c:181:8: note: v is incremented', new value is 25
     ++v;
       ^
test/suites/sccz80/lshift.c:183:8: note: v is incremented', new value is 26
     ++v;
       ^
test/suites/sccz80/lshift.c:185:8: note: v is incremented', new value is 27
     ++v;
       ^
test/suites/sccz80/lshift.c:187:8: note: v is incremented', new value is 28
     ++v;
       ^
test/suites/sccz80/lshift.c:189:8: note: v is incremented', new value is 29
     ++v;
       ^
test/suites/sccz80/lshift.c:191:8: note: v is incremented', new value is 30
     ++v;
       ^
test/suites/sccz80/lshift.c:193:8: note: v is incremented', new value is 31
     ++v;
       ^
test/suites/sccz80/lshift.c:195:8: note: v is incremented', new value is 32
     ++v;
       ^
test/suites/sccz80/lshift.c:197:8: note: v is incremented', new value is 33
     ++v;
       ^
test/suites/sccz80/lshift.c:199:8: note: v is incremented', new value is 34
     ++v;
       ^
test/suites/sccz80/lshift.c:201:8: note: v is incremented', new value is 35
     ++v;
       ^
test/suites/sccz80/lshift.c:203:8: note: v is incremented', new value is 36
     ++v;
       ^
test/suites/sccz80/lshift.c:205:8: note: v is incremented', new value is 37
     ++v;
       ^
test/suites/sccz80/lshift.c:207:8: note: v is incremented', new value is 38
     ++v;
       ^
test/suites/sccz80/lshift.c:209:8: note: v is incremented', new value is 39
     ++v;
       ^
test/suites/sccz80/lshift.c:211:8: note: v is incremented', new value is 40
     ++v;
       ^
test/suites/sccz80/lshift.c:213:8: note: v is incremented', new value is 41
     ++v;
       ^
test/suites/sccz80/lshift.c:215:8: note: v is incremented', new value is 42
     ++v;
       ^
test/suites/sccz80/lshift.c:217:8: note: v is incremented', new value is 43
     ++v;
       ^
test/suites/sccz80/lshift.c:219:8: note: v is incremented', new value is 44
     ++v;
       ^
test/suites/sccz80/lshift.c:221:8: note: v is incremented', new value is 45
     ++v;
       ^
test/suites/sccz80/lshift.c:223:8: note: v is incremented', new value is 46
     ++v;
       ^
test/suites/sccz80/lshift.c:225:8: note: v is incremented', new value is 47
     ++v;
       ^
test/suites/sccz80/lshift.c:227:8: note: v is incremented', new value is 48
     ++v;
       ^
test/suites/sccz80/lshift.c:229:8: note: v is incremented', new value is 49
     ++v;
       ^
test/suites/sccz80/lshift.c:231:8: note: v is incremented', new value is 50
     ++v;
       ^
test/suites/sccz80/lshift.c:233:8: note: v is incremented', new value is 51
     ++v;
       ^
test/suites/sccz80/lshift.c:235:8: note: v is incremented', new value is 52
     ++v;
       ^
test/suites/sccz80/lshift.c:237:8: note: v is incremented', new value is 53
     ++v;
       ^
test/suites/sccz80/lshift.c:239:8: note: v is incremented', new value is 54
     ++v;
       ^
test/suites/sccz80/lshift.c:241:8: note: v is incremented', new value is 55
     ++v;
       ^
test/suites/sccz80/lshift.c:243:8: note: v is incremented', new value is 56
     ++v;
       ^
test/suites/sccz80/lshift.c:245:8: note: v is incremented', new value is 57
     ++v;
       ^
test/suites/sccz80/lshift.c:247:8: note: v is incremented', new value is 58
     ++v;
       ^
test/suites/sccz80/lshift.c:249:8: note: v is incremented', new value is 59
     ++v;
       ^
test/suites/sccz80/lshift.c:251:8: note: v is incremented', new value is 60
     ++v;
       ^
test/suites/sccz80/lshift.c:253:8: note: v is incremented', new value is 61
     ++v;
       ^
test/suites/sccz80/lshift.c:255:8: note: v is incremented', new value is 62
     ++v;
       ^
test/suites/sccz80/lshift.c:257:8: note: v is incremented', new value is 63
     ++v;
       ^
test/suites/sccz80/lshift.c:258:18: note: Shift
     Assert( val << v == 1LL << 63, "<<63");
                 ^
test/suites/sccz80/lshift.c:258:30: portability: Shifting signed 64-bit value by 63 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
     Assert( val << v == 1LL << 63, "<<63");
                             ^
test/suites/sccz80/lshift.c:330:18: portability: Shifting signed 64-bit value by 63 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
     Assert( val << 63 == 1LL << 63, "<<63");
                 ^
test/suites/sccz80/lshift.c:44:6: style: Variable 'v' is assigned a value that is never used. [unreadVariable]
     ++v;
     ^
test/suites/sccz80/lshift.c:119:6: style: Variable 'v' is assigned a value that is never used. [unreadVariable]
     ++v;
     ^
test/suites/sccz80/mult.c:12:27: style: The comparison 'val*655360 == 655360*3' is always true because 'val*655360' and '655360*3' represent the same value. [knownConditionTrueFalse]
     Assert( val * 655360 == 655360 * 3, "3 * 655360");
                          ^
test/suites/sccz80/mult.c:10:22: note: 'val' is assigned value '3' here.
     long long val = 3;
                     ^
test/suites/sccz80/mult.c:12:27: note: The comparison 'val*655360 == 655360*3' is always true because 'val*655360' and '655360*3' represent the same value.
     Assert( val * 655360 == 655360 * 3, "3 * 655360");
                          ^
test/suites/sccz80/rshift.c:12:23: style: The comparison 'val>>v == 0x8000>>0' is always true because 'val>>v' and '0x8000>>0' represent the same value. [knownConditionTrueFalse]
     Assert( val >> v == 0x8000 >> 0, ">>0");
                      ^
test/suites/sccz80/rshift.c:8:16: note: 'val' is assigned value '0x8000' here.
     int val = 0x8000;
               ^
test/suites/sccz80/rshift.c:9:15: note: 'v' is assigned value '0' here.
     int  v = 0;
              ^
test/suites/sccz80/rshift.c:12:23: note: The comparison 'val>>v == 0x8000>>0' is always true because 'val>>v' and '0x8000>>0' represent the same value.
     Assert( val >> v == 0x8000 >> 0, ">>0");
                      ^
test/suites/sccz80/rshift.c:55:23: style: The comparison 'val>>v == 0x80000000L>>0' is always true because 'val>>v' and '0x80000000L>>0' represent the same value. [knownConditionTrueFalse]
     Assert( val >> v == 0x80000000L >> 0, ">>0");
                      ^
test/suites/sccz80/rshift.c:51:17: note: 'val' is assigned value '0x80000000L' here.
     long val = 0x80000000L;
                ^
test/suites/sccz80/rshift.c:52:15: note: 'v' is assigned value '0' here.
     int  v = 0;
              ^
test/suites/sccz80/rshift.c:55:23: note: The comparison 'val>>v == 0x80000000L>>0' is always true because 'val>>v' and '0x80000000L>>0' represent the same value.
     Assert( val >> v == 0x80000000L >> 0, ">>0");
                      ^
test/suites/sccz80/rshift.c:129:23: style: The comparison 'val>>0 == 0x80>>0' is always true because 'val>>0' and '0x80>>0' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 0 == 0x80 >> 0, ">>0");
                      ^
test/suites/sccz80/rshift.c:126:26: note: 'val' is assigned value '0x80' here.
     unsigned char val = 0x80;
                         ^
test/suites/sccz80/rshift.c:129:23: note: The comparison 'val>>0 == 0x80>>0' is always true because 'val>>0' and '0x80>>0' represent the same value.
     Assert( val >> 0 == 0x80 >> 0, ">>0");
                      ^
test/suites/sccz80/rshift.c:130:23: style: The comparison 'val>>1 == 0x80>>1' is always true because 'val>>1' and '0x80>>1' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 1 == 0x80 >> 1, ">>1");
                      ^
test/suites/sccz80/rshift.c:126:26: note: 'val' is assigned value '0x80' here.
     unsigned char val = 0x80;
                         ^
test/suites/sccz80/rshift.c:130:23: note: The comparison 'val>>1 == 0x80>>1' is always true because 'val>>1' and '0x80>>1' represent the same value.
     Assert( val >> 1 == 0x80 >> 1, ">>1");
                      ^
test/suites/sccz80/rshift.c:131:23: style: The comparison 'val>>2 == 0x80>>2' is always true because 'val>>2' and '0x80>>2' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 2 == 0x80 >> 2, ">>2");
                      ^
test/suites/sccz80/rshift.c:126:26: note: 'val' is assigned value '0x80' here.
     unsigned char val = 0x80;
                         ^
test/suites/sccz80/rshift.c:131:23: note: The comparison 'val>>2 == 0x80>>2' is always true because 'val>>2' and '0x80>>2' represent the same value.
     Assert( val >> 2 == 0x80 >> 2, ">>2");
                      ^
test/suites/sccz80/rshift.c:132:23: style: The comparison 'val>>3 == 0x80>>3' is always true because 'val>>3' and '0x80>>3' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 3 == 0x80 >> 3, ">>3");
                      ^
test/suites/sccz80/rshift.c:126:26: note: 'val' is assigned value '0x80' here.
     unsigned char val = 0x80;
                         ^
test/suites/sccz80/rshift.c:132:23: note: The comparison 'val>>3 == 0x80>>3' is always true because 'val>>3' and '0x80>>3' represent the same value.
     Assert( val >> 3 == 0x80 >> 3, ">>3");
                      ^
test/suites/sccz80/rshift.c:133:23: style: The comparison 'val>>4 == 0x80>>4' is always true because 'val>>4' and '0x80>>4' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 4 == 0x80 >> 4, ">>4");
                      ^
test/suites/sccz80/rshift.c:126:26: note: 'val' is assigned value '0x80' here.
     unsigned char val = 0x80;
                         ^
test/suites/sccz80/rshift.c:133:23: note: The comparison 'val>>4 == 0x80>>4' is always true because 'val>>4' and '0x80>>4' represent the same value.
     Assert( val >> 4 == 0x80 >> 4, ">>4");
                      ^
test/suites/sccz80/rshift.c:134:23: style: The comparison 'val>>5 == 0x80>>5' is always true because 'val>>5' and '0x80>>5' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 5 == 0x80 >> 5, ">>5");
                      ^
test/suites/sccz80/rshift.c:126:26: note: 'val' is assigned value '0x80' here.
     unsigned char val = 0x80;
                         ^
test/suites/sccz80/rshift.c:134:23: note: The comparison 'val>>5 == 0x80>>5' is always true because 'val>>5' and '0x80>>5' represent the same value.
     Assert( val >> 5 == 0x80 >> 5, ">>5");
                      ^
test/suites/sccz80/rshift.c:135:23: style: The comparison 'val>>6 == 0x80>>6' is always true because 'val>>6' and '0x80>>6' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 6 == 0x80 >> 6, ">>6");
                      ^
test/suites/sccz80/rshift.c:126:26: note: 'val' is assigned value '0x80' here.
     unsigned char val = 0x80;
                         ^
test/suites/sccz80/rshift.c:135:23: note: The comparison 'val>>6 == 0x80>>6' is always true because 'val>>6' and '0x80>>6' represent the same value.
     Assert( val >> 6 == 0x80 >> 6, ">>6");
                      ^
test/suites/sccz80/rshift.c:136:23: style: The comparison 'val>>7 == 0x80>>7' is always true because 'val>>7' and '0x80>>7' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 7 == 0x80 >> 7, ">>7");
                      ^
test/suites/sccz80/rshift.c:126:26: note: 'val' is assigned value '0x80' here.
     unsigned char val = 0x80;
                         ^
test/suites/sccz80/rshift.c:136:23: note: The comparison 'val>>7 == 0x80>>7' is always true because 'val>>7' and '0x80>>7' represent the same value.
     Assert( val >> 7 == 0x80 >> 7, ">>7");
                      ^
test/suites/sccz80/rshift.c:137:23: style: The comparison 'val>>8 == 0x80>>8' is always true because 'val>>8' and '0x80>>8' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 8 == 0x80 >> 8, ">>8");
                      ^
test/suites/sccz80/rshift.c:126:26: note: 'val' is assigned value '0x80' here.
     unsigned char val = 0x80;
                         ^
test/suites/sccz80/rshift.c:137:23: note: The comparison 'val>>8 == 0x80>>8' is always true because 'val>>8' and '0x80>>8' represent the same value.
     Assert( val >> 8 == 0x80 >> 8, ">>8");
                      ^
test/suites/sccz80/rshift.c:145:23: style: The comparison 'val>>0 == 0x8000>>0' is always true because 'val>>0' and '0x8000>>0' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 0 == 0x8000 >> 0, ">>0");
                      ^
test/suites/sccz80/rshift.c:142:16: note: 'val' is assigned value '0x8000' here.
     int val = 0x8000;
               ^
test/suites/sccz80/rshift.c:145:23: note: The comparison 'val>>0 == 0x8000>>0' is always true because 'val>>0' and '0x8000>>0' represent the same value.
     Assert( val >> 0 == 0x8000 >> 0, ">>0");
                      ^
test/suites/sccz80/rshift.c:146:23: style: The comparison 'val>>1 == 0x8000>>1' is always true because 'val>>1' and '0x8000>>1' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 1 == 0x8000 >> 1, ">>1");
                      ^
test/suites/sccz80/rshift.c:142:16: note: 'val' is assigned value '0x8000' here.
     int val = 0x8000;
               ^
test/suites/sccz80/rshift.c:146:23: note: The comparison 'val>>1 == 0x8000>>1' is always true because 'val>>1' and '0x8000>>1' represent the same value.
     Assert( val >> 1 == 0x8000 >> 1, ">>1");
                      ^
test/suites/sccz80/rshift.c:147:23: style: The comparison 'val>>2 == 0x8000>>2' is always true because 'val>>2' and '0x8000>>2' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 2 == 0x8000 >> 2, ">>2");
                      ^
test/suites/sccz80/rshift.c:142:16: note: 'val' is assigned value '0x8000' here.
     int val = 0x8000;
               ^
test/suites/sccz80/rshift.c:147:23: note: The comparison 'val>>2 == 0x8000>>2' is always true because 'val>>2' and '0x8000>>2' represent the same value.
     Assert( val >> 2 == 0x8000 >> 2, ">>2");
                      ^
test/suites/sccz80/rshift.c:148:23: style: The comparison 'val>>3 == 0x8000>>3' is always true because 'val>>3' and '0x8000>>3' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 3 == 0x8000 >> 3, ">>3");
                      ^
test/suites/sccz80/rshift.c:142:16: note: 'val' is assigned value '0x8000' here.
     int val = 0x8000;
               ^
test/suites/sccz80/rshift.c:148:23: note: The comparison 'val>>3 == 0x8000>>3' is always true because 'val>>3' and '0x8000>>3' represent the same value.
     Assert( val >> 3 == 0x8000 >> 3, ">>3");
                      ^
test/suites/sccz80/rshift.c:149:23: style: The comparison 'val>>4 == 0x8000>>4' is always true because 'val>>4' and '0x8000>>4' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 4 == 0x8000 >> 4, ">>4");
                      ^
test/suites/sccz80/rshift.c:142:16: note: 'val' is assigned value '0x8000' here.
     int val = 0x8000;
               ^
test/suites/sccz80/rshift.c:149:23: note: The comparison 'val>>4 == 0x8000>>4' is always true because 'val>>4' and '0x8000>>4' represent the same value.
     Assert( val >> 4 == 0x8000 >> 4, ">>4");
                      ^
test/suites/sccz80/rshift.c:150:23: style: The comparison 'val>>5 == 0x8000>>5' is always true because 'val>>5' and '0x8000>>5' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 5 == 0x8000 >> 5, ">>5");
                      ^
test/suites/sccz80/rshift.c:142:16: note: 'val' is assigned value '0x8000' here.
     int val = 0x8000;
               ^
test/suites/sccz80/rshift.c:150:23: note: The comparison 'val>>5 == 0x8000>>5' is always true because 'val>>5' and '0x8000>>5' represent the same value.
     Assert( val >> 5 == 0x8000 >> 5, ">>5");
                      ^
test/suites/sccz80/rshift.c:151:23: style: The comparison 'val>>6 == 0x8000>>6' is always true because 'val>>6' and '0x8000>>6' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 6 == 0x8000 >> 6, ">>6");
                      ^
test/suites/sccz80/rshift.c:142:16: note: 'val' is assigned value '0x8000' here.
     int val = 0x8000;
               ^
test/suites/sccz80/rshift.c:151:23: note: The comparison 'val>>6 == 0x8000>>6' is always true because 'val>>6' and '0x8000>>6' represent the same value.
     Assert( val >> 6 == 0x8000 >> 6, ">>6");
                      ^
test/suites/sccz80/rshift.c:152:23: style: The comparison 'val>>7 == 0x8000>>7' is always true because 'val>>7' and '0x8000>>7' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 7 == 0x8000 >> 7, ">>7");
                      ^
test/suites/sccz80/rshift.c:142:16: note: 'val' is assigned value '0x8000' here.
     int val = 0x8000;
               ^
test/suites/sccz80/rshift.c:152:23: note: The comparison 'val>>7 == 0x8000>>7' is always true because 'val>>7' and '0x8000>>7' represent the same value.
     Assert( val >> 7 == 0x8000 >> 7, ">>7");
                      ^
test/suites/sccz80/rshift.c:153:23: style: The comparison 'val>>8 == 0x8000>>8' is always true because 'val>>8' and '0x8000>>8' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 8 == 0x8000 >> 8, ">>8");
                      ^
test/suites/sccz80/rshift.c:142:16: note: 'val' is assigned value '0x8000' here.
     int val = 0x8000;
               ^
test/suites/sccz80/rshift.c:153:23: note: The comparison 'val>>8 == 0x8000>>8' is always true because 'val>>8' and '0x8000>>8' represent the same value.
     Assert( val >> 8 == 0x8000 >> 8, ">>8");
                      ^
test/suites/sccz80/rshift.c:154:23: style: The comparison 'val>>9 == 0x8000>>9' is always true because 'val>>9' and '0x8000>>9' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 9 == 0x8000 >> 9, ">>9");
                      ^
test/suites/sccz80/rshift.c:142:16: note: 'val' is assigned value '0x8000' here.
     int val = 0x8000;
               ^
test/suites/sccz80/rshift.c:154:23: note: The comparison 'val>>9 == 0x8000>>9' is always true because 'val>>9' and '0x8000>>9' represent the same value.
     Assert( val >> 9 == 0x8000 >> 9, ">>9");
                      ^
test/suites/sccz80/rshift.c:155:24: style: The comparison 'val>>10 == 0x8000>>10' is always true because 'val>>10' and '0x8000>>10' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 10 == 0x8000 >> 10, ">>10");
                       ^
test/suites/sccz80/rshift.c:142:16: note: 'val' is assigned value '0x8000' here.
     int val = 0x8000;
               ^
test/suites/sccz80/rshift.c:155:24: note: The comparison 'val>>10 == 0x8000>>10' is always true because 'val>>10' and '0x8000>>10' represent the same value.
     Assert( val >> 10 == 0x8000 >> 10, ">>10");
                       ^
test/suites/sccz80/rshift.c:156:24: style: The comparison 'val>>11 == 0x8000>>11' is always true because 'val>>11' and '0x8000>>11' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 11 == 0x8000 >> 11, ">>11");
                       ^
test/suites/sccz80/rshift.c:142:16: note: 'val' is assigned value '0x8000' here.
     int val = 0x8000;
               ^
test/suites/sccz80/rshift.c:156:24: note: The comparison 'val>>11 == 0x8000>>11' is always true because 'val>>11' and '0x8000>>11' represent the same value.
     Assert( val >> 11 == 0x8000 >> 11, ">>11");
                       ^
test/suites/sccz80/rshift.c:157:24: style: The comparison 'val>>12 == 0x8000>>12' is always true because 'val>>12' and '0x8000>>12' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 12 == 0x8000 >> 12, ">>12");
                       ^
test/suites/sccz80/rshift.c:142:16: note: 'val' is assigned value '0x8000' here.
     int val = 0x8000;
               ^
test/suites/sccz80/rshift.c:157:24: note: The comparison 'val>>12 == 0x8000>>12' is always true because 'val>>12' and '0x8000>>12' represent the same value.
     Assert( val >> 12 == 0x8000 >> 12, ">>12");
                       ^
test/suites/sccz80/rshift.c:158:24: style: The comparison 'val>>13 == 0x8000>>13' is always true because 'val>>13' and '0x8000>>13' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 13 == 0x8000 >> 13, ">>13");
                       ^
test/suites/sccz80/rshift.c:142:16: note: 'val' is assigned value '0x8000' here.
     int val = 0x8000;
               ^
test/suites/sccz80/rshift.c:158:24: note: The comparison 'val>>13 == 0x8000>>13' is always true because 'val>>13' and '0x8000>>13' represent the same value.
     Assert( val >> 13 == 0x8000 >> 13, ">>13");
                       ^
test/suites/sccz80/rshift.c:159:24: style: The comparison 'val>>14 == 0x8000>>14' is always true because 'val>>14' and '0x8000>>14' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 14 == 0x8000 >> 14, ">>14");
                       ^
test/suites/sccz80/rshift.c:142:16: note: 'val' is assigned value '0x8000' here.
     int val = 0x8000;
               ^
test/suites/sccz80/rshift.c:159:24: note: The comparison 'val>>14 == 0x8000>>14' is always true because 'val>>14' and '0x8000>>14' represent the same value.
     Assert( val >> 14 == 0x8000 >> 14, ">>14");
                       ^
test/suites/sccz80/rshift.c:160:24: style: The comparison 'val>>15 == 0x8000>>15' is always true because 'val>>15' and '0x8000>>15' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 15 == 0x8000 >> 15, ">>15");
                       ^
test/suites/sccz80/rshift.c:142:16: note: 'val' is assigned value '0x8000' here.
     int val = 0x8000;
               ^
test/suites/sccz80/rshift.c:160:24: note: The comparison 'val>>15 == 0x8000>>15' is always true because 'val>>15' and '0x8000>>15' represent the same value.
     Assert( val >> 15 == 0x8000 >> 15, ">>15");
                       ^
test/suites/sccz80/rshift.c:256:23: style: The comparison 'val>>v == 0x8000000000000000LL>>0' is always true because 'val>>v' and '0x8000000000000000LL>>0' represent the same value. [knownConditionTrueFalse]
     Assert( val >> v ==  0x8000000000000000LL >> 0, ">>0");
                      ^
test/suites/sccz80/rshift.c:252:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:253:15: note: 'v' is assigned value '0' here.
     int  v = 0;
              ^
test/suites/sccz80/rshift.c:256:23: note: The comparison 'val>>v == 0x8000000000000000LL>>0' is always true because 'val>>v' and '0x8000000000000000LL>>0' represent the same value.
     Assert( val >> v ==  0x8000000000000000LL >> 0, ">>0");
                      ^
test/suites/sccz80/rshift.c:391:23: style: The comparison 'val>>0 == 0x8000000000000000LL>>0' is always true because 'val>>0' and '0x8000000000000000LL>>0' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 0 ==  0x8000000000000000LL >> 0, ">>0");
                      ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:391:23: note: The comparison 'val>>0 == 0x8000000000000000LL>>0' is always true because 'val>>0' and '0x8000000000000000LL>>0' represent the same value.
     Assert( val >> 0 ==  0x8000000000000000LL >> 0, ">>0");
                      ^
test/suites/sccz80/rshift.c:392:23: style: The comparison 'val>>1 == 0x8000000000000000LL>>1' is always true because 'val>>1' and '0x8000000000000000LL>>1' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 1 ==  0x8000000000000000LL >> 1, ">>1");
                      ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:392:23: note: The comparison 'val>>1 == 0x8000000000000000LL>>1' is always true because 'val>>1' and '0x8000000000000000LL>>1' represent the same value.
     Assert( val >> 1 ==  0x8000000000000000LL >> 1, ">>1");
                      ^
test/suites/sccz80/rshift.c:393:23: style: The comparison 'val>>2 == 0x8000000000000000LL>>2' is always true because 'val>>2' and '0x8000000000000000LL>>2' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 2 ==  0x8000000000000000LL >> 2, ">>2");
                      ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:393:23: note: The comparison 'val>>2 == 0x8000000000000000LL>>2' is always true because 'val>>2' and '0x8000000000000000LL>>2' represent the same value.
     Assert( val >> 2 ==  0x8000000000000000LL >> 2, ">>2");
                      ^
test/suites/sccz80/rshift.c:394:23: style: The comparison 'val>>3 == 0x8000000000000000LL>>3' is always true because 'val>>3' and '0x8000000000000000LL>>3' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 3 ==  0x8000000000000000LL >> 3, ">>3");
                      ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:394:23: note: The comparison 'val>>3 == 0x8000000000000000LL>>3' is always true because 'val>>3' and '0x8000000000000000LL>>3' represent the same value.
     Assert( val >> 3 ==  0x8000000000000000LL >> 3, ">>3");
                      ^
test/suites/sccz80/rshift.c:395:23: style: The comparison 'val>>4 == 0x8000000000000000LL>>4' is always true because 'val>>4' and '0x8000000000000000LL>>4' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 4 ==  0x8000000000000000LL >> 4, ">>4");
                      ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:395:23: note: The comparison 'val>>4 == 0x8000000000000000LL>>4' is always true because 'val>>4' and '0x8000000000000000LL>>4' represent the same value.
     Assert( val >> 4 ==  0x8000000000000000LL >> 4, ">>4");
                      ^
test/suites/sccz80/rshift.c:396:23: style: The comparison 'val>>5 == 0x8000000000000000LL>>5' is always true because 'val>>5' and '0x8000000000000000LL>>5' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 5 ==  0x8000000000000000LL >> 5, ">>5");
                      ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:396:23: note: The comparison 'val>>5 == 0x8000000000000000LL>>5' is always true because 'val>>5' and '0x8000000000000000LL>>5' represent the same value.
     Assert( val >> 5 ==  0x8000000000000000LL >> 5, ">>5");
                      ^
test/suites/sccz80/rshift.c:397:23: style: The comparison 'val>>6 == 0x8000000000000000LL>>6' is always true because 'val>>6' and '0x8000000000000000LL>>6' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 6 ==  0x8000000000000000LL >> 6, ">>6");
                      ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:397:23: note: The comparison 'val>>6 == 0x8000000000000000LL>>6' is always true because 'val>>6' and '0x8000000000000000LL>>6' represent the same value.
     Assert( val >> 6 ==  0x8000000000000000LL >> 6, ">>6");
                      ^
test/suites/sccz80/rshift.c:398:23: style: The comparison 'val>>7 == 0x8000000000000000LL>>7' is always true because 'val>>7' and '0x8000000000000000LL>>7' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 7 ==  0x8000000000000000LL >> 7, ">>7");
                      ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:398:23: note: The comparison 'val>>7 == 0x8000000000000000LL>>7' is always true because 'val>>7' and '0x8000000000000000LL>>7' represent the same value.
     Assert( val >> 7 ==  0x8000000000000000LL >> 7, ">>7");
                      ^
test/suites/sccz80/rshift.c:399:23: style: The comparison 'val>>8 == 0x8000000000000000LL>>8' is always true because 'val>>8' and '0x8000000000000000LL>>8' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 8 ==  0x8000000000000000LL >> 8, ">>8");
                      ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:399:23: note: The comparison 'val>>8 == 0x8000000000000000LL>>8' is always true because 'val>>8' and '0x8000000000000000LL>>8' represent the same value.
     Assert( val >> 8 ==  0x8000000000000000LL >> 8, ">>8");
                      ^
test/suites/sccz80/rshift.c:400:23: style: The comparison 'val>>9 == 0x8000000000000000LL>>9' is always true because 'val>>9' and '0x8000000000000000LL>>9' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 9 ==  0x8000000000000000LL >> 9, ">>9");
                      ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:400:23: note: The comparison 'val>>9 == 0x8000000000000000LL>>9' is always true because 'val>>9' and '0x8000000000000000LL>>9' represent the same value.
     Assert( val >> 9 ==  0x8000000000000000LL >> 9, ">>9");
                      ^
test/suites/sccz80/rshift.c:401:24: style: The comparison 'val>>10 == 0x8000000000000000LL>>10' is always true because 'val>>10' and '0x8000000000000000LL>>10' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 10 ==  0x8000000000000000LL >> 10, ">>10");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:401:24: note: The comparison 'val>>10 == 0x8000000000000000LL>>10' is always true because 'val>>10' and '0x8000000000000000LL>>10' represent the same value.
     Assert( val >> 10 ==  0x8000000000000000LL >> 10, ">>10");
                       ^
test/suites/sccz80/rshift.c:402:24: style: The comparison 'val>>11 == 0x8000000000000000LL>>11' is always true because 'val>>11' and '0x8000000000000000LL>>11' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 11 ==  0x8000000000000000LL >> 11, ">>11");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:402:24: note: The comparison 'val>>11 == 0x8000000000000000LL>>11' is always true because 'val>>11' and '0x8000000000000000LL>>11' represent the same value.
     Assert( val >> 11 ==  0x8000000000000000LL >> 11, ">>11");
                       ^
test/suites/sccz80/rshift.c:403:24: style: The comparison 'val>>12 == 0x8000000000000000LL>>12' is always true because 'val>>12' and '0x8000000000000000LL>>12' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 12 ==  0x8000000000000000LL >> 12, ">>12");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:403:24: note: The comparison 'val>>12 == 0x8000000000000000LL>>12' is always true because 'val>>12' and '0x8000000000000000LL>>12' represent the same value.
     Assert( val >> 12 ==  0x8000000000000000LL >> 12, ">>12");
                       ^
test/suites/sccz80/rshift.c:404:24: style: The comparison 'val>>13 == 0x8000000000000000LL>>13' is always true because 'val>>13' and '0x8000000000000000LL>>13' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 13 ==  0x8000000000000000LL >> 13, ">>13");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:404:24: note: The comparison 'val>>13 == 0x8000000000000000LL>>13' is always true because 'val>>13' and '0x8000000000000000LL>>13' represent the same value.
     Assert( val >> 13 ==  0x8000000000000000LL >> 13, ">>13");
                       ^
test/suites/sccz80/rshift.c:405:24: style: The comparison 'val>>14 == 0x8000000000000000LL>>14' is always true because 'val>>14' and '0x8000000000000000LL>>14' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 14 ==  0x8000000000000000LL >> 14, ">>14");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:405:24: note: The comparison 'val>>14 == 0x8000000000000000LL>>14' is always true because 'val>>14' and '0x8000000000000000LL>>14' represent the same value.
     Assert( val >> 14 ==  0x8000000000000000LL >> 14, ">>14");
                       ^
test/suites/sccz80/rshift.c:406:24: style: The comparison 'val>>15 == 0x8000000000000000LL>>15' is always true because 'val>>15' and '0x8000000000000000LL>>15' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 15 ==  0x8000000000000000LL >> 15, ">>15");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:406:24: note: The comparison 'val>>15 == 0x8000000000000000LL>>15' is always true because 'val>>15' and '0x8000000000000000LL>>15' represent the same value.
     Assert( val >> 15 ==  0x8000000000000000LL >> 15, ">>15");
                       ^
test/suites/sccz80/rshift.c:407:24: style: The comparison 'val>>16 == 0x8000000000000000LL>>16' is always true because 'val>>16' and '0x8000000000000000LL>>16' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 16 ==  0x8000000000000000LL >> 16, ">>16");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:407:24: note: The comparison 'val>>16 == 0x8000000000000000LL>>16' is always true because 'val>>16' and '0x8000000000000000LL>>16' represent the same value.
     Assert( val >> 16 ==  0x8000000000000000LL >> 16, ">>16");
                       ^
test/suites/sccz80/rshift.c:408:24: style: The comparison 'val>>17 == 0x8000000000000000LL>>17' is always true because 'val>>17' and '0x8000000000000000LL>>17' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 17 ==  0x8000000000000000LL >> 17, ">>17");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:408:24: note: The comparison 'val>>17 == 0x8000000000000000LL>>17' is always true because 'val>>17' and '0x8000000000000000LL>>17' represent the same value.
     Assert( val >> 17 ==  0x8000000000000000LL >> 17, ">>17");
                       ^
test/suites/sccz80/rshift.c:409:24: style: The comparison 'val>>18 == 0x8000000000000000LL>>18' is always true because 'val>>18' and '0x8000000000000000LL>>18' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 18 ==  0x8000000000000000LL >> 18, ">>18");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:409:24: note: The comparison 'val>>18 == 0x8000000000000000LL>>18' is always true because 'val>>18' and '0x8000000000000000LL>>18' represent the same value.
     Assert( val >> 18 ==  0x8000000000000000LL >> 18, ">>18");
                       ^
test/suites/sccz80/rshift.c:410:24: style: The comparison 'val>>19 == 0x8000000000000000LL>>19' is always true because 'val>>19' and '0x8000000000000000LL>>19' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 19 ==  0x8000000000000000LL >> 19, ">>19");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:410:24: note: The comparison 'val>>19 == 0x8000000000000000LL>>19' is always true because 'val>>19' and '0x8000000000000000LL>>19' represent the same value.
     Assert( val >> 19 ==  0x8000000000000000LL >> 19, ">>19");
                       ^
test/suites/sccz80/rshift.c:411:24: style: The comparison 'val>>20 == 0x8000000000000000LL>>20' is always true because 'val>>20' and '0x8000000000000000LL>>20' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 20 ==  0x8000000000000000LL >> 20, ">>20");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:411:24: note: The comparison 'val>>20 == 0x8000000000000000LL>>20' is always true because 'val>>20' and '0x8000000000000000LL>>20' represent the same value.
     Assert( val >> 20 ==  0x8000000000000000LL >> 20, ">>20");
                       ^
test/suites/sccz80/rshift.c:412:24: style: The comparison 'val>>21 == 0x8000000000000000LL>>21' is always true because 'val>>21' and '0x8000000000000000LL>>21' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 21 ==  0x8000000000000000LL >> 21, ">>21");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:412:24: note: The comparison 'val>>21 == 0x8000000000000000LL>>21' is always true because 'val>>21' and '0x8000000000000000LL>>21' represent the same value.
     Assert( val >> 21 ==  0x8000000000000000LL >> 21, ">>21");
                       ^
test/suites/sccz80/rshift.c:413:24: style: The comparison 'val>>22 == 0x8000000000000000LL>>22' is always true because 'val>>22' and '0x8000000000000000LL>>22' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 22 ==  0x8000000000000000LL >> 22, ">>22");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:413:24: note: The comparison 'val>>22 == 0x8000000000000000LL>>22' is always true because 'val>>22' and '0x8000000000000000LL>>22' represent the same value.
     Assert( val >> 22 ==  0x8000000000000000LL >> 22, ">>22");
                       ^
test/suites/sccz80/rshift.c:414:24: style: The comparison 'val>>23 == 0x8000000000000000LL>>23' is always true because 'val>>23' and '0x8000000000000000LL>>23' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 23 ==  0x8000000000000000LL >> 23, ">>23");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:414:24: note: The comparison 'val>>23 == 0x8000000000000000LL>>23' is always true because 'val>>23' and '0x8000000000000000LL>>23' represent the same value.
     Assert( val >> 23 ==  0x8000000000000000LL >> 23, ">>23");
                       ^
test/suites/sccz80/rshift.c:415:24: style: The comparison 'val>>24 == 0x8000000000000000LL>>24' is always true because 'val>>24' and '0x8000000000000000LL>>24' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 24 ==  0x8000000000000000LL >> 24, ">>24");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:415:24: note: The comparison 'val>>24 == 0x8000000000000000LL>>24' is always true because 'val>>24' and '0x8000000000000000LL>>24' represent the same value.
     Assert( val >> 24 ==  0x8000000000000000LL >> 24, ">>24");
                       ^
test/suites/sccz80/rshift.c:416:24: style: The comparison 'val>>25 == 0x8000000000000000LL>>25' is always true because 'val>>25' and '0x8000000000000000LL>>25' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 25 ==  0x8000000000000000LL >> 25, ">>25");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:416:24: note: The comparison 'val>>25 == 0x8000000000000000LL>>25' is always true because 'val>>25' and '0x8000000000000000LL>>25' represent the same value.
     Assert( val >> 25 ==  0x8000000000000000LL >> 25, ">>25");
                       ^
test/suites/sccz80/rshift.c:417:24: style: The comparison 'val>>26 == 0x8000000000000000LL>>26' is always true because 'val>>26' and '0x8000000000000000LL>>26' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 26 ==  0x8000000000000000LL >> 26, ">>26");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:417:24: note: The comparison 'val>>26 == 0x8000000000000000LL>>26' is always true because 'val>>26' and '0x8000000000000000LL>>26' represent the same value.
     Assert( val >> 26 ==  0x8000000000000000LL >> 26, ">>26");
                       ^
test/suites/sccz80/rshift.c:418:24: style: The comparison 'val>>27 == 0x8000000000000000LL>>27' is always true because 'val>>27' and '0x8000000000000000LL>>27' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 27 ==  0x8000000000000000LL >> 27, ">>27");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:418:24: note: The comparison 'val>>27 == 0x8000000000000000LL>>27' is always true because 'val>>27' and '0x8000000000000000LL>>27' represent the same value.
     Assert( val >> 27 ==  0x8000000000000000LL >> 27, ">>27");
                       ^
test/suites/sccz80/rshift.c:419:24: style: The comparison 'val>>28 == 0x8000000000000000LL>>28' is always true because 'val>>28' and '0x8000000000000000LL>>28' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 28 ==  0x8000000000000000LL >> 28, ">>28");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:419:24: note: The comparison 'val>>28 == 0x8000000000000000LL>>28' is always true because 'val>>28' and '0x8000000000000000LL>>28' represent the same value.
     Assert( val >> 28 ==  0x8000000000000000LL >> 28, ">>28");
                       ^
test/suites/sccz80/rshift.c:420:24: style: The comparison 'val>>29 == 0x8000000000000000LL>>29' is always true because 'val>>29' and '0x8000000000000000LL>>29' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 29 ==  0x8000000000000000LL >> 29, ">>29");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:420:24: note: The comparison 'val>>29 == 0x8000000000000000LL>>29' is always true because 'val>>29' and '0x8000000000000000LL>>29' represent the same value.
     Assert( val >> 29 ==  0x8000000000000000LL >> 29, ">>29");
                       ^
test/suites/sccz80/rshift.c:421:24: style: The comparison 'val>>30 == 0x8000000000000000LL>>30' is always true because 'val>>30' and '0x8000000000000000LL>>30' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 30 ==  0x8000000000000000LL >> 30, ">>30");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:421:24: note: The comparison 'val>>30 == 0x8000000000000000LL>>30' is always true because 'val>>30' and '0x8000000000000000LL>>30' represent the same value.
     Assert( val >> 30 ==  0x8000000000000000LL >> 30, ">>30");
                       ^
test/suites/sccz80/rshift.c:422:24: style: The comparison 'val>>31 == 0x8000000000000000LL>>31' is always true because 'val>>31' and '0x8000000000000000LL>>31' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 31 ==  0x8000000000000000LL >> 31, ">>31");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:422:24: note: The comparison 'val>>31 == 0x8000000000000000LL>>31' is always true because 'val>>31' and '0x8000000000000000LL>>31' represent the same value.
     Assert( val >> 31 ==  0x8000000000000000LL >> 31, ">>31");
                       ^
test/suites/sccz80/rshift.c:423:24: style: The comparison 'val>>32 == 0x8000000000000000LL>>32' is always true because 'val>>32' and '0x8000000000000000LL>>32' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 32 ==  0x8000000000000000LL >> 32, ">>32");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:423:24: note: The comparison 'val>>32 == 0x8000000000000000LL>>32' is always true because 'val>>32' and '0x8000000000000000LL>>32' represent the same value.
     Assert( val >> 32 ==  0x8000000000000000LL >> 32, ">>32");
                       ^
test/suites/sccz80/rshift.c:424:24: style: The comparison 'val>>33 == 0x8000000000000000LL>>33' is always true because 'val>>33' and '0x8000000000000000LL>>33' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 33 ==  0x8000000000000000LL >> 33, ">>33");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:424:24: note: The comparison 'val>>33 == 0x8000000000000000LL>>33' is always true because 'val>>33' and '0x8000000000000000LL>>33' represent the same value.
     Assert( val >> 33 ==  0x8000000000000000LL >> 33, ">>33");
                       ^
test/suites/sccz80/rshift.c:425:24: style: The comparison 'val>>34 == 0x8000000000000000LL>>34' is always true because 'val>>34' and '0x8000000000000000LL>>34' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 34 ==  0x8000000000000000LL >> 34, ">>34");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:425:24: note: The comparison 'val>>34 == 0x8000000000000000LL>>34' is always true because 'val>>34' and '0x8000000000000000LL>>34' represent the same value.
     Assert( val >> 34 ==  0x8000000000000000LL >> 34, ">>34");
                       ^
test/suites/sccz80/rshift.c:426:24: style: The comparison 'val>>35 == 0x8000000000000000LL>>35' is always true because 'val>>35' and '0x8000000000000000LL>>35' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 35 ==  0x8000000000000000LL >> 35, ">>35");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:426:24: note: The comparison 'val>>35 == 0x8000000000000000LL>>35' is always true because 'val>>35' and '0x8000000000000000LL>>35' represent the same value.
     Assert( val >> 35 ==  0x8000000000000000LL >> 35, ">>35");
                       ^
test/suites/sccz80/rshift.c:427:24: style: The comparison 'val>>36 == 0x8000000000000000LL>>36' is always true because 'val>>36' and '0x8000000000000000LL>>36' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 36 ==  0x8000000000000000LL >> 36, ">>36");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:427:24: note: The comparison 'val>>36 == 0x8000000000000000LL>>36' is always true because 'val>>36' and '0x8000000000000000LL>>36' represent the same value.
     Assert( val >> 36 ==  0x8000000000000000LL >> 36, ">>36");
                       ^
test/suites/sccz80/rshift.c:428:24: style: The comparison 'val>>37 == 0x8000000000000000LL>>37' is always true because 'val>>37' and '0x8000000000000000LL>>37' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 37 ==  0x8000000000000000LL >> 37, ">>37");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:428:24: note: The comparison 'val>>37 == 0x8000000000000000LL>>37' is always true because 'val>>37' and '0x8000000000000000LL>>37' represent the same value.
     Assert( val >> 37 ==  0x8000000000000000LL >> 37, ">>37");
                       ^
test/suites/sccz80/rshift.c:429:24: style: The comparison 'val>>38 == 0x8000000000000000LL>>38' is always true because 'val>>38' and '0x8000000000000000LL>>38' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 38 ==  0x8000000000000000LL >> 38, ">>38");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:429:24: note: The comparison 'val>>38 == 0x8000000000000000LL>>38' is always true because 'val>>38' and '0x8000000000000000LL>>38' represent the same value.
     Assert( val >> 38 ==  0x8000000000000000LL >> 38, ">>38");
                       ^
test/suites/sccz80/rshift.c:430:24: style: The comparison 'val>>39 == 0x8000000000000000LL>>39' is always true because 'val>>39' and '0x8000000000000000LL>>39' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 39 ==  0x8000000000000000LL >> 39, ">>39");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:430:24: note: The comparison 'val>>39 == 0x8000000000000000LL>>39' is always true because 'val>>39' and '0x8000000000000000LL>>39' represent the same value.
     Assert( val >> 39 ==  0x8000000000000000LL >> 39, ">>39");
                       ^
test/suites/sccz80/rshift.c:431:24: style: The comparison 'val>>40 == 0x8000000000000000LL>>40' is always true because 'val>>40' and '0x8000000000000000LL>>40' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 40 ==  0x8000000000000000LL >> 40, ">>40");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:431:24: note: The comparison 'val>>40 == 0x8000000000000000LL>>40' is always true because 'val>>40' and '0x8000000000000000LL>>40' represent the same value.
     Assert( val >> 40 ==  0x8000000000000000LL >> 40, ">>40");
                       ^
test/suites/sccz80/rshift.c:432:24: style: The comparison 'val>>41 == 0x8000000000000000LL>>41' is always true because 'val>>41' and '0x8000000000000000LL>>41' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 41 ==  0x8000000000000000LL >> 41, ">>41");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:432:24: note: The comparison 'val>>41 == 0x8000000000000000LL>>41' is always true because 'val>>41' and '0x8000000000000000LL>>41' represent the same value.
     Assert( val >> 41 ==  0x8000000000000000LL >> 41, ">>41");
                       ^
test/suites/sccz80/rshift.c:433:24: style: The comparison 'val>>42 == 0x8000000000000000LL>>42' is always true because 'val>>42' and '0x8000000000000000LL>>42' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 42 ==  0x8000000000000000LL >> 42, ">>42");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:433:24: note: The comparison 'val>>42 == 0x8000000000000000LL>>42' is always true because 'val>>42' and '0x8000000000000000LL>>42' represent the same value.
     Assert( val >> 42 ==  0x8000000000000000LL >> 42, ">>42");
                       ^
test/suites/sccz80/rshift.c:434:24: style: The comparison 'val>>43 == 0x8000000000000000LL>>43' is always true because 'val>>43' and '0x8000000000000000LL>>43' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 43 ==  0x8000000000000000LL >> 43, ">>43");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:434:24: note: The comparison 'val>>43 == 0x8000000000000000LL>>43' is always true because 'val>>43' and '0x8000000000000000LL>>43' represent the same value.
     Assert( val >> 43 ==  0x8000000000000000LL >> 43, ">>43");
                       ^
test/suites/sccz80/rshift.c:435:24: style: The comparison 'val>>44 == 0x8000000000000000LL>>44' is always true because 'val>>44' and '0x8000000000000000LL>>44' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 44 ==  0x8000000000000000LL >> 44, ">>44");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:435:24: note: The comparison 'val>>44 == 0x8000000000000000LL>>44' is always true because 'val>>44' and '0x8000000000000000LL>>44' represent the same value.
     Assert( val >> 44 ==  0x8000000000000000LL >> 44, ">>44");
                       ^
test/suites/sccz80/rshift.c:436:24: style: The comparison 'val>>45 == 0x8000000000000000LL>>45' is always true because 'val>>45' and '0x8000000000000000LL>>45' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 45 ==  0x8000000000000000LL >> 45, ">>45");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:436:24: note: The comparison 'val>>45 == 0x8000000000000000LL>>45' is always true because 'val>>45' and '0x8000000000000000LL>>45' represent the same value.
     Assert( val >> 45 ==  0x8000000000000000LL >> 45, ">>45");
                       ^
test/suites/sccz80/rshift.c:437:24: style: The comparison 'val>>46 == 0x8000000000000000LL>>46' is always true because 'val>>46' and '0x8000000000000000LL>>46' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 46 ==  0x8000000000000000LL >> 46, ">>46");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:437:24: note: The comparison 'val>>46 == 0x8000000000000000LL>>46' is always true because 'val>>46' and '0x8000000000000000LL>>46' represent the same value.
     Assert( val >> 46 ==  0x8000000000000000LL >> 46, ">>46");
                       ^
test/suites/sccz80/rshift.c:438:24: style: The comparison 'val>>47 == 0x8000000000000000LL>>47' is always true because 'val>>47' and '0x8000000000000000LL>>47' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 47 ==  0x8000000000000000LL >> 47, ">>47");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:438:24: note: The comparison 'val>>47 == 0x8000000000000000LL>>47' is always true because 'val>>47' and '0x8000000000000000LL>>47' represent the same value.
     Assert( val >> 47 ==  0x8000000000000000LL >> 47, ">>47");
                       ^
test/suites/sccz80/rshift.c:439:24: style: The comparison 'val>>48 == 0x8000000000000000LL>>48' is always true because 'val>>48' and '0x8000000000000000LL>>48' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 48 ==  0x8000000000000000LL >> 48, ">>48");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:439:24: note: The comparison 'val>>48 == 0x8000000000000000LL>>48' is always true because 'val>>48' and '0x8000000000000000LL>>48' represent the same value.
     Assert( val >> 48 ==  0x8000000000000000LL >> 48, ">>48");
                       ^
test/suites/sccz80/rshift.c:440:24: style: The comparison 'val>>49 == 0x8000000000000000LL>>49' is always true because 'val>>49' and '0x8000000000000000LL>>49' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 49 ==  0x8000000000000000LL >> 49, ">>49");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:440:24: note: The comparison 'val>>49 == 0x8000000000000000LL>>49' is always true because 'val>>49' and '0x8000000000000000LL>>49' represent the same value.
     Assert( val >> 49 ==  0x8000000000000000LL >> 49, ">>49");
                       ^
test/suites/sccz80/rshift.c:441:24: style: The comparison 'val>>50 == 0x8000000000000000LL>>50' is always true because 'val>>50' and '0x8000000000000000LL>>50' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 50 ==  0x8000000000000000LL >> 50, ">>50");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:441:24: note: The comparison 'val>>50 == 0x8000000000000000LL>>50' is always true because 'val>>50' and '0x8000000000000000LL>>50' represent the same value.
     Assert( val >> 50 ==  0x8000000000000000LL >> 50, ">>50");
                       ^
test/suites/sccz80/rshift.c:442:24: style: The comparison 'val>>51 == 0x8000000000000000LL>>51' is always true because 'val>>51' and '0x8000000000000000LL>>51' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 51 ==  0x8000000000000000LL >> 51, ">>51");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:442:24: note: The comparison 'val>>51 == 0x8000000000000000LL>>51' is always true because 'val>>51' and '0x8000000000000000LL>>51' represent the same value.
     Assert( val >> 51 ==  0x8000000000000000LL >> 51, ">>51");
                       ^
test/suites/sccz80/rshift.c:443:24: style: The comparison 'val>>52 == 0x8000000000000000LL>>52' is always true because 'val>>52' and '0x8000000000000000LL>>52' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 52 ==  0x8000000000000000LL >> 52, ">>52");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:443:24: note: The comparison 'val>>52 == 0x8000000000000000LL>>52' is always true because 'val>>52' and '0x8000000000000000LL>>52' represent the same value.
     Assert( val >> 52 ==  0x8000000000000000LL >> 52, ">>52");
                       ^
test/suites/sccz80/rshift.c:444:24: style: The comparison 'val>>53 == 0x8000000000000000LL>>53' is always true because 'val>>53' and '0x8000000000000000LL>>53' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 53 ==  0x8000000000000000LL >> 53, ">>53");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:444:24: note: The comparison 'val>>53 == 0x8000000000000000LL>>53' is always true because 'val>>53' and '0x8000000000000000LL>>53' represent the same value.
     Assert( val >> 53 ==  0x8000000000000000LL >> 53, ">>53");
                       ^
test/suites/sccz80/rshift.c:445:24: style: The comparison 'val>>54 == 0x8000000000000000LL>>54' is always true because 'val>>54' and '0x8000000000000000LL>>54' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 54 ==  0x8000000000000000LL >> 54, ">>54");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:445:24: note: The comparison 'val>>54 == 0x8000000000000000LL>>54' is always true because 'val>>54' and '0x8000000000000000LL>>54' represent the same value.
     Assert( val >> 54 ==  0x8000000000000000LL >> 54, ">>54");
                       ^
test/suites/sccz80/rshift.c:446:24: style: The comparison 'val>>55 == 0x8000000000000000LL>>55' is always true because 'val>>55' and '0x8000000000000000LL>>55' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 55 ==  0x8000000000000000LL >> 55, ">>55");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:446:24: note: The comparison 'val>>55 == 0x8000000000000000LL>>55' is always true because 'val>>55' and '0x8000000000000000LL>>55' represent the same value.
     Assert( val >> 55 ==  0x8000000000000000LL >> 55, ">>55");
                       ^
test/suites/sccz80/rshift.c:447:24: style: The comparison 'val>>56 == 0x8000000000000000LL>>56' is always true because 'val>>56' and '0x8000000000000000LL>>56' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 56 ==  0x8000000000000000LL >> 56, ">>56");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:447:24: note: The comparison 'val>>56 == 0x8000000000000000LL>>56' is always true because 'val>>56' and '0x8000000000000000LL>>56' represent the same value.
     Assert( val >> 56 ==  0x8000000000000000LL >> 56, ">>56");
                       ^
test/suites/sccz80/rshift.c:448:24: style: The comparison 'val>>57 == 0x8000000000000000LL>>57' is always true because 'val>>57' and '0x8000000000000000LL>>57' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 57 ==  0x8000000000000000LL >> 57, ">>57");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:448:24: note: The comparison 'val>>57 == 0x8000000000000000LL>>57' is always true because 'val>>57' and '0x8000000000000000LL>>57' represent the same value.
     Assert( val >> 57 ==  0x8000000000000000LL >> 57, ">>57");
                       ^
test/suites/sccz80/rshift.c:449:24: style: The comparison 'val>>58 == 0x8000000000000000LL>>58' is always true because 'val>>58' and '0x8000000000000000LL>>58' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 58 ==  0x8000000000000000LL >> 58, ">>58");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:449:24: note: The comparison 'val>>58 == 0x8000000000000000LL>>58' is always true because 'val>>58' and '0x8000000000000000LL>>58' represent the same value.
     Assert( val >> 58 ==  0x8000000000000000LL >> 58, ">>58");
                       ^
test/suites/sccz80/rshift.c:450:24: style: The comparison 'val>>59 == 0x8000000000000000LL>>59' is always true because 'val>>59' and '0x8000000000000000LL>>59' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 59 ==  0x8000000000000000LL >> 59, ">>59");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:450:24: note: The comparison 'val>>59 == 0x8000000000000000LL>>59' is always true because 'val>>59' and '0x8000000000000000LL>>59' represent the same value.
     Assert( val >> 59 ==  0x8000000000000000LL >> 59, ">>59");
                       ^
test/suites/sccz80/rshift.c:451:24: style: The comparison 'val>>60 == 0x8000000000000000LL>>60' is always true because 'val>>60' and '0x8000000000000000LL>>60' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 60 ==  0x8000000000000000LL >> 60, ">>60");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:451:24: note: The comparison 'val>>60 == 0x8000000000000000LL>>60' is always true because 'val>>60' and '0x8000000000000000LL>>60' represent the same value.
     Assert( val >> 60 ==  0x8000000000000000LL >> 60, ">>60");
                       ^
test/suites/sccz80/rshift.c:452:24: style: The comparison 'val>>61 == 0x8000000000000000LL>>61' is always true because 'val>>61' and '0x8000000000000000LL>>61' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 61 ==  0x8000000000000000LL >> 61, ">>61");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:452:24: note: The comparison 'val>>61 == 0x8000000000000000LL>>61' is always true because 'val>>61' and '0x8000000000000000LL>>61' represent the same value.
     Assert( val >> 61 ==  0x8000000000000000LL >> 61, ">>61");
                       ^
test/suites/sccz80/rshift.c:453:24: style: The comparison 'val>>62 == 0x8000000000000000LL>>62' is always true because 'val>>62' and '0x8000000000000000LL>>62' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 62 ==  0x8000000000000000LL >> 62, ">>62");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:453:24: note: The comparison 'val>>62 == 0x8000000000000000LL>>62' is always true because 'val>>62' and '0x8000000000000000LL>>62' represent the same value.
     Assert( val >> 62 ==  0x8000000000000000LL >> 62, ">>62");
                       ^
test/suites/sccz80/rshift.c:454:24: style: The comparison 'val>>63 == 0x8000000000000000LL>>63' is always true because 'val>>63' and '0x8000000000000000LL>>63' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 63 ==  0x8000000000000000LL >> 63, ">>63");
                       ^
test/suites/sccz80/rshift.c:388:22: note: 'val' is assigned value '0x8000000000000000LL' here.
     long long val = 0x8000000000000000LL;
                     ^
test/suites/sccz80/rshift.c:454:24: note: The comparison 'val>>63 == 0x8000000000000000LL>>63' is always true because 'val>>63' and '0x8000000000000000LL>>63' represent the same value.
     Assert( val >> 63 ==  0x8000000000000000LL >> 63, ">>63");
                       ^
test/suites/sccz80/rshift.c:462:23: style: The comparison 'val>>0 == 0x8000000000000000ULL>>0' is always true because 'val>>0' and '0x8000000000000000ULL>>0' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 0 ==  0x8000000000000000ULL >> 0, ">>0");
                      ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:462:23: note: The comparison 'val>>0 == 0x8000000000000000ULL>>0' is always true because 'val>>0' and '0x8000000000000000ULL>>0' represent the same value.
     Assert( val >> 0 ==  0x8000000000000000ULL >> 0, ">>0");
                      ^
test/suites/sccz80/rshift.c:463:23: style: The comparison 'val>>1 == 0x8000000000000000ULL>>1' is always true because 'val>>1' and '0x8000000000000000ULL>>1' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 1 ==  0x8000000000000000ULL >> 1, ">>1");
                      ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:463:23: note: The comparison 'val>>1 == 0x8000000000000000ULL>>1' is always true because 'val>>1' and '0x8000000000000000ULL>>1' represent the same value.
     Assert( val >> 1 ==  0x8000000000000000ULL >> 1, ">>1");
                      ^
test/suites/sccz80/rshift.c:464:23: style: The comparison 'val>>2 == 0x8000000000000000ULL>>2' is always true because 'val>>2' and '0x8000000000000000ULL>>2' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 2 ==  0x8000000000000000ULL >> 2, ">>2");
                      ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:464:23: note: The comparison 'val>>2 == 0x8000000000000000ULL>>2' is always true because 'val>>2' and '0x8000000000000000ULL>>2' represent the same value.
     Assert( val >> 2 ==  0x8000000000000000ULL >> 2, ">>2");
                      ^
test/suites/sccz80/rshift.c:465:23: style: The comparison 'val>>3 == 0x8000000000000000ULL>>3' is always true because 'val>>3' and '0x8000000000000000ULL>>3' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 3 ==  0x8000000000000000ULL >> 3, ">>3");
                      ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:465:23: note: The comparison 'val>>3 == 0x8000000000000000ULL>>3' is always true because 'val>>3' and '0x8000000000000000ULL>>3' represent the same value.
     Assert( val >> 3 ==  0x8000000000000000ULL >> 3, ">>3");
                      ^
test/suites/sccz80/rshift.c:466:23: style: The comparison 'val>>4 == 0x8000000000000000ULL>>4' is always true because 'val>>4' and '0x8000000000000000ULL>>4' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 4 ==  0x8000000000000000ULL >> 4, ">>4");
                      ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:466:23: note: The comparison 'val>>4 == 0x8000000000000000ULL>>4' is always true because 'val>>4' and '0x8000000000000000ULL>>4' represent the same value.
     Assert( val >> 4 ==  0x8000000000000000ULL >> 4, ">>4");
                      ^
test/suites/sccz80/rshift.c:467:23: style: The comparison 'val>>5 == 0x8000000000000000ULL>>5' is always true because 'val>>5' and '0x8000000000000000ULL>>5' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 5 ==  0x8000000000000000ULL >> 5, ">>5");
                      ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:467:23: note: The comparison 'val>>5 == 0x8000000000000000ULL>>5' is always true because 'val>>5' and '0x8000000000000000ULL>>5' represent the same value.
     Assert( val >> 5 ==  0x8000000000000000ULL >> 5, ">>5");
                      ^
test/suites/sccz80/rshift.c:468:23: style: The comparison 'val>>6 == 0x8000000000000000ULL>>6' is always true because 'val>>6' and '0x8000000000000000ULL>>6' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 6 ==  0x8000000000000000ULL >> 6, ">>6");
                      ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:468:23: note: The comparison 'val>>6 == 0x8000000000000000ULL>>6' is always true because 'val>>6' and '0x8000000000000000ULL>>6' represent the same value.
     Assert( val >> 6 ==  0x8000000000000000ULL >> 6, ">>6");
                      ^
test/suites/sccz80/rshift.c:469:23: style: The comparison 'val>>7 == 0x8000000000000000ULL>>7' is always true because 'val>>7' and '0x8000000000000000ULL>>7' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 7 ==  0x8000000000000000ULL >> 7, ">>7");
                      ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:469:23: note: The comparison 'val>>7 == 0x8000000000000000ULL>>7' is always true because 'val>>7' and '0x8000000000000000ULL>>7' represent the same value.
     Assert( val >> 7 ==  0x8000000000000000ULL >> 7, ">>7");
                      ^
test/suites/sccz80/rshift.c:470:23: style: The comparison 'val>>8 == 0x8000000000000000ULL>>8' is always true because 'val>>8' and '0x8000000000000000ULL>>8' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 8 ==  0x8000000000000000ULL >> 8, ">>8");
                      ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:470:23: note: The comparison 'val>>8 == 0x8000000000000000ULL>>8' is always true because 'val>>8' and '0x8000000000000000ULL>>8' represent the same value.
     Assert( val >> 8 ==  0x8000000000000000ULL >> 8, ">>8");
                      ^
test/suites/sccz80/rshift.c:471:23: style: The comparison 'val>>9 == 0x8000000000000000ULL>>9' is always true because 'val>>9' and '0x8000000000000000ULL>>9' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 9 ==  0x8000000000000000ULL >> 9, ">>9");
                      ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:471:23: note: The comparison 'val>>9 == 0x8000000000000000ULL>>9' is always true because 'val>>9' and '0x8000000000000000ULL>>9' represent the same value.
     Assert( val >> 9 ==  0x8000000000000000ULL >> 9, ">>9");
                      ^
test/suites/sccz80/rshift.c:472:24: style: The comparison 'val>>10 == 0x8000000000000000ULL>>10' is always true because 'val>>10' and '0x8000000000000000ULL>>10' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 10 ==  0x8000000000000000ULL >> 10, ">>10");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:472:24: note: The comparison 'val>>10 == 0x8000000000000000ULL>>10' is always true because 'val>>10' and '0x8000000000000000ULL>>10' represent the same value.
     Assert( val >> 10 ==  0x8000000000000000ULL >> 10, ">>10");
                       ^
test/suites/sccz80/rshift.c:473:24: style: The comparison 'val>>11 == 0x8000000000000000ULL>>11' is always true because 'val>>11' and '0x8000000000000000ULL>>11' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 11 ==  0x8000000000000000ULL >> 11, ">>11");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:473:24: note: The comparison 'val>>11 == 0x8000000000000000ULL>>11' is always true because 'val>>11' and '0x8000000000000000ULL>>11' represent the same value.
     Assert( val >> 11 ==  0x8000000000000000ULL >> 11, ">>11");
                       ^
test/suites/sccz80/rshift.c:474:24: style: The comparison 'val>>12 == 0x8000000000000000ULL>>12' is always true because 'val>>12' and '0x8000000000000000ULL>>12' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 12 ==  0x8000000000000000ULL >> 12, ">>12");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:474:24: note: The comparison 'val>>12 == 0x8000000000000000ULL>>12' is always true because 'val>>12' and '0x8000000000000000ULL>>12' represent the same value.
     Assert( val >> 12 ==  0x8000000000000000ULL >> 12, ">>12");
                       ^
test/suites/sccz80/rshift.c:475:24: style: The comparison 'val>>13 == 0x8000000000000000ULL>>13' is always true because 'val>>13' and '0x8000000000000000ULL>>13' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 13 ==  0x8000000000000000ULL >> 13, ">>13");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:475:24: note: The comparison 'val>>13 == 0x8000000000000000ULL>>13' is always true because 'val>>13' and '0x8000000000000000ULL>>13' represent the same value.
     Assert( val >> 13 ==  0x8000000000000000ULL >> 13, ">>13");
                       ^
test/suites/sccz80/rshift.c:476:24: style: The comparison 'val>>14 == 0x8000000000000000ULL>>14' is always true because 'val>>14' and '0x8000000000000000ULL>>14' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 14 ==  0x8000000000000000ULL >> 14, ">>14");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:476:24: note: The comparison 'val>>14 == 0x8000000000000000ULL>>14' is always true because 'val>>14' and '0x8000000000000000ULL>>14' represent the same value.
     Assert( val >> 14 ==  0x8000000000000000ULL >> 14, ">>14");
                       ^
test/suites/sccz80/rshift.c:477:24: style: The comparison 'val>>15 == 0x8000000000000000ULL>>15' is always true because 'val>>15' and '0x8000000000000000ULL>>15' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 15 ==  0x8000000000000000ULL >> 15, ">>15");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:477:24: note: The comparison 'val>>15 == 0x8000000000000000ULL>>15' is always true because 'val>>15' and '0x8000000000000000ULL>>15' represent the same value.
     Assert( val >> 15 ==  0x8000000000000000ULL >> 15, ">>15");
                       ^
test/suites/sccz80/rshift.c:478:24: style: The comparison 'val>>16 == 0x8000000000000000ULL>>16' is always true because 'val>>16' and '0x8000000000000000ULL>>16' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 16 ==  0x8000000000000000ULL >> 16, ">>16");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:478:24: note: The comparison 'val>>16 == 0x8000000000000000ULL>>16' is always true because 'val>>16' and '0x8000000000000000ULL>>16' represent the same value.
     Assert( val >> 16 ==  0x8000000000000000ULL >> 16, ">>16");
                       ^
test/suites/sccz80/rshift.c:479:24: style: The comparison 'val>>17 == 0x8000000000000000ULL>>17' is always true because 'val>>17' and '0x8000000000000000ULL>>17' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 17 ==  0x8000000000000000ULL >> 17, ">>17");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:479:24: note: The comparison 'val>>17 == 0x8000000000000000ULL>>17' is always true because 'val>>17' and '0x8000000000000000ULL>>17' represent the same value.
     Assert( val >> 17 ==  0x8000000000000000ULL >> 17, ">>17");
                       ^
test/suites/sccz80/rshift.c:480:24: style: The comparison 'val>>18 == 0x8000000000000000ULL>>18' is always true because 'val>>18' and '0x8000000000000000ULL>>18' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 18 ==  0x8000000000000000ULL >> 18, ">>18");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:480:24: note: The comparison 'val>>18 == 0x8000000000000000ULL>>18' is always true because 'val>>18' and '0x8000000000000000ULL>>18' represent the same value.
     Assert( val >> 18 ==  0x8000000000000000ULL >> 18, ">>18");
                       ^
test/suites/sccz80/rshift.c:481:24: style: The comparison 'val>>19 == 0x8000000000000000ULL>>19' is always true because 'val>>19' and '0x8000000000000000ULL>>19' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 19 ==  0x8000000000000000ULL >> 19, ">>19");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:481:24: note: The comparison 'val>>19 == 0x8000000000000000ULL>>19' is always true because 'val>>19' and '0x8000000000000000ULL>>19' represent the same value.
     Assert( val >> 19 ==  0x8000000000000000ULL >> 19, ">>19");
                       ^
test/suites/sccz80/rshift.c:482:24: style: The comparison 'val>>20 == 0x8000000000000000ULL>>20' is always true because 'val>>20' and '0x8000000000000000ULL>>20' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 20 ==  0x8000000000000000ULL >> 20, ">>20");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:482:24: note: The comparison 'val>>20 == 0x8000000000000000ULL>>20' is always true because 'val>>20' and '0x8000000000000000ULL>>20' represent the same value.
     Assert( val >> 20 ==  0x8000000000000000ULL >> 20, ">>20");
                       ^
test/suites/sccz80/rshift.c:483:24: style: The comparison 'val>>21 == 0x8000000000000000ULL>>21' is always true because 'val>>21' and '0x8000000000000000ULL>>21' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 21 ==  0x8000000000000000ULL >> 21, ">>21");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:483:24: note: The comparison 'val>>21 == 0x8000000000000000ULL>>21' is always true because 'val>>21' and '0x8000000000000000ULL>>21' represent the same value.
     Assert( val >> 21 ==  0x8000000000000000ULL >> 21, ">>21");
                       ^
test/suites/sccz80/rshift.c:484:24: style: The comparison 'val>>22 == 0x8000000000000000ULL>>22' is always true because 'val>>22' and '0x8000000000000000ULL>>22' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 22 ==  0x8000000000000000ULL >> 22, ">>22");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:484:24: note: The comparison 'val>>22 == 0x8000000000000000ULL>>22' is always true because 'val>>22' and '0x8000000000000000ULL>>22' represent the same value.
     Assert( val >> 22 ==  0x8000000000000000ULL >> 22, ">>22");
                       ^
test/suites/sccz80/rshift.c:485:24: style: The comparison 'val>>23 == 0x8000000000000000ULL>>23' is always true because 'val>>23' and '0x8000000000000000ULL>>23' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 23 ==  0x8000000000000000ULL >> 23, ">>23");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:485:24: note: The comparison 'val>>23 == 0x8000000000000000ULL>>23' is always true because 'val>>23' and '0x8000000000000000ULL>>23' represent the same value.
     Assert( val >> 23 ==  0x8000000000000000ULL >> 23, ">>23");
                       ^
test/suites/sccz80/rshift.c:486:24: style: The comparison 'val>>24 == 0x8000000000000000ULL>>24' is always true because 'val>>24' and '0x8000000000000000ULL>>24' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 24 ==  0x8000000000000000ULL >> 24, ">>24");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:486:24: note: The comparison 'val>>24 == 0x8000000000000000ULL>>24' is always true because 'val>>24' and '0x8000000000000000ULL>>24' represent the same value.
     Assert( val >> 24 ==  0x8000000000000000ULL >> 24, ">>24");
                       ^
test/suites/sccz80/rshift.c:487:24: style: The comparison 'val>>25 == 0x8000000000000000ULL>>25' is always true because 'val>>25' and '0x8000000000000000ULL>>25' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 25 ==  0x8000000000000000ULL >> 25, ">>25");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:487:24: note: The comparison 'val>>25 == 0x8000000000000000ULL>>25' is always true because 'val>>25' and '0x8000000000000000ULL>>25' represent the same value.
     Assert( val >> 25 ==  0x8000000000000000ULL >> 25, ">>25");
                       ^
test/suites/sccz80/rshift.c:488:24: style: The comparison 'val>>26 == 0x8000000000000000ULL>>26' is always true because 'val>>26' and '0x8000000000000000ULL>>26' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 26 ==  0x8000000000000000ULL >> 26, ">>26");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:488:24: note: The comparison 'val>>26 == 0x8000000000000000ULL>>26' is always true because 'val>>26' and '0x8000000000000000ULL>>26' represent the same value.
     Assert( val >> 26 ==  0x8000000000000000ULL >> 26, ">>26");
                       ^
test/suites/sccz80/rshift.c:489:24: style: The comparison 'val>>27 == 0x8000000000000000ULL>>27' is always true because 'val>>27' and '0x8000000000000000ULL>>27' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 27 ==  0x8000000000000000ULL >> 27, ">>27");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:489:24: note: The comparison 'val>>27 == 0x8000000000000000ULL>>27' is always true because 'val>>27' and '0x8000000000000000ULL>>27' represent the same value.
     Assert( val >> 27 ==  0x8000000000000000ULL >> 27, ">>27");
                       ^
test/suites/sccz80/rshift.c:490:24: style: The comparison 'val>>28 == 0x8000000000000000ULL>>28' is always true because 'val>>28' and '0x8000000000000000ULL>>28' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 28 ==  0x8000000000000000ULL >> 28, ">>28");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:490:24: note: The comparison 'val>>28 == 0x8000000000000000ULL>>28' is always true because 'val>>28' and '0x8000000000000000ULL>>28' represent the same value.
     Assert( val >> 28 ==  0x8000000000000000ULL >> 28, ">>28");
                       ^
test/suites/sccz80/rshift.c:491:24: style: The comparison 'val>>29 == 0x8000000000000000ULL>>29' is always true because 'val>>29' and '0x8000000000000000ULL>>29' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 29 ==  0x8000000000000000ULL >> 29, ">>29");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:491:24: note: The comparison 'val>>29 == 0x8000000000000000ULL>>29' is always true because 'val>>29' and '0x8000000000000000ULL>>29' represent the same value.
     Assert( val >> 29 ==  0x8000000000000000ULL >> 29, ">>29");
                       ^
test/suites/sccz80/rshift.c:492:24: style: The comparison 'val>>30 == 0x8000000000000000ULL>>30' is always true because 'val>>30' and '0x8000000000000000ULL>>30' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 30 ==  0x8000000000000000ULL >> 30, ">>30");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:492:24: note: The comparison 'val>>30 == 0x8000000000000000ULL>>30' is always true because 'val>>30' and '0x8000000000000000ULL>>30' represent the same value.
     Assert( val >> 30 ==  0x8000000000000000ULL >> 30, ">>30");
                       ^
test/suites/sccz80/rshift.c:493:24: style: The comparison 'val>>31 == 0x8000000000000000ULL>>31' is always true because 'val>>31' and '0x8000000000000000ULL>>31' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 31 ==  0x8000000000000000ULL >> 31, ">>31");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:493:24: note: The comparison 'val>>31 == 0x8000000000000000ULL>>31' is always true because 'val>>31' and '0x8000000000000000ULL>>31' represent the same value.
     Assert( val >> 31 ==  0x8000000000000000ULL >> 31, ">>31");
                       ^
test/suites/sccz80/rshift.c:494:24: style: The comparison 'val>>32 == 0x8000000000000000ULL>>32' is always true because 'val>>32' and '0x8000000000000000ULL>>32' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 32 ==  0x8000000000000000ULL >> 32, ">>32");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:494:24: note: The comparison 'val>>32 == 0x8000000000000000ULL>>32' is always true because 'val>>32' and '0x8000000000000000ULL>>32' represent the same value.
     Assert( val >> 32 ==  0x8000000000000000ULL >> 32, ">>32");
                       ^
test/suites/sccz80/rshift.c:495:24: style: The comparison 'val>>33 == 0x8000000000000000ULL>>33' is always true because 'val>>33' and '0x8000000000000000ULL>>33' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 33 ==  0x8000000000000000ULL >> 33, ">>33");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:495:24: note: The comparison 'val>>33 == 0x8000000000000000ULL>>33' is always true because 'val>>33' and '0x8000000000000000ULL>>33' represent the same value.
     Assert( val >> 33 ==  0x8000000000000000ULL >> 33, ">>33");
                       ^
test/suites/sccz80/rshift.c:496:24: style: The comparison 'val>>34 == 0x8000000000000000ULL>>34' is always true because 'val>>34' and '0x8000000000000000ULL>>34' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 34 ==  0x8000000000000000ULL >> 34, ">>34");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:496:24: note: The comparison 'val>>34 == 0x8000000000000000ULL>>34' is always true because 'val>>34' and '0x8000000000000000ULL>>34' represent the same value.
     Assert( val >> 34 ==  0x8000000000000000ULL >> 34, ">>34");
                       ^
test/suites/sccz80/rshift.c:497:24: style: The comparison 'val>>35 == 0x8000000000000000ULL>>35' is always true because 'val>>35' and '0x8000000000000000ULL>>35' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 35 ==  0x8000000000000000ULL >> 35, ">>35");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:497:24: note: The comparison 'val>>35 == 0x8000000000000000ULL>>35' is always true because 'val>>35' and '0x8000000000000000ULL>>35' represent the same value.
     Assert( val >> 35 ==  0x8000000000000000ULL >> 35, ">>35");
                       ^
test/suites/sccz80/rshift.c:498:24: style: The comparison 'val>>36 == 0x8000000000000000ULL>>36' is always true because 'val>>36' and '0x8000000000000000ULL>>36' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 36 ==  0x8000000000000000ULL >> 36, ">>36");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:498:24: note: The comparison 'val>>36 == 0x8000000000000000ULL>>36' is always true because 'val>>36' and '0x8000000000000000ULL>>36' represent the same value.
     Assert( val >> 36 ==  0x8000000000000000ULL >> 36, ">>36");
                       ^
test/suites/sccz80/rshift.c:499:24: style: The comparison 'val>>37 == 0x8000000000000000ULL>>37' is always true because 'val>>37' and '0x8000000000000000ULL>>37' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 37 ==  0x8000000000000000ULL >> 37, ">>37");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:499:24: note: The comparison 'val>>37 == 0x8000000000000000ULL>>37' is always true because 'val>>37' and '0x8000000000000000ULL>>37' represent the same value.
     Assert( val >> 37 ==  0x8000000000000000ULL >> 37, ">>37");
                       ^
test/suites/sccz80/rshift.c:500:24: style: The comparison 'val>>38 == 0x8000000000000000ULL>>38' is always true because 'val>>38' and '0x8000000000000000ULL>>38' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 38 ==  0x8000000000000000ULL >> 38, ">>38");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:500:24: note: The comparison 'val>>38 == 0x8000000000000000ULL>>38' is always true because 'val>>38' and '0x8000000000000000ULL>>38' represent the same value.
     Assert( val >> 38 ==  0x8000000000000000ULL >> 38, ">>38");
                       ^
test/suites/sccz80/rshift.c:501:24: style: The comparison 'val>>39 == 0x8000000000000000ULL>>39' is always true because 'val>>39' and '0x8000000000000000ULL>>39' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 39 ==  0x8000000000000000ULL >> 39, ">>39");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:501:24: note: The comparison 'val>>39 == 0x8000000000000000ULL>>39' is always true because 'val>>39' and '0x8000000000000000ULL>>39' represent the same value.
     Assert( val >> 39 ==  0x8000000000000000ULL >> 39, ">>39");
                       ^
test/suites/sccz80/rshift.c:502:24: style: The comparison 'val>>40 == 0x8000000000000000ULL>>40' is always true because 'val>>40' and '0x8000000000000000ULL>>40' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 40 ==  0x8000000000000000ULL >> 40, ">>40");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:502:24: note: The comparison 'val>>40 == 0x8000000000000000ULL>>40' is always true because 'val>>40' and '0x8000000000000000ULL>>40' represent the same value.
     Assert( val >> 40 ==  0x8000000000000000ULL >> 40, ">>40");
                       ^
test/suites/sccz80/rshift.c:503:24: style: The comparison 'val>>41 == 0x8000000000000000ULL>>41' is always true because 'val>>41' and '0x8000000000000000ULL>>41' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 41 ==  0x8000000000000000ULL >> 41, ">>41");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:503:24: note: The comparison 'val>>41 == 0x8000000000000000ULL>>41' is always true because 'val>>41' and '0x8000000000000000ULL>>41' represent the same value.
     Assert( val >> 41 ==  0x8000000000000000ULL >> 41, ">>41");
                       ^
test/suites/sccz80/rshift.c:504:24: style: The comparison 'val>>42 == 0x8000000000000000ULL>>42' is always true because 'val>>42' and '0x8000000000000000ULL>>42' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 42 ==  0x8000000000000000ULL >> 42, ">>42");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:504:24: note: The comparison 'val>>42 == 0x8000000000000000ULL>>42' is always true because 'val>>42' and '0x8000000000000000ULL>>42' represent the same value.
     Assert( val >> 42 ==  0x8000000000000000ULL >> 42, ">>42");
                       ^
test/suites/sccz80/rshift.c:505:24: style: The comparison 'val>>43 == 0x8000000000000000ULL>>43' is always true because 'val>>43' and '0x8000000000000000ULL>>43' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 43 ==  0x8000000000000000ULL >> 43, ">>43");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:505:24: note: The comparison 'val>>43 == 0x8000000000000000ULL>>43' is always true because 'val>>43' and '0x8000000000000000ULL>>43' represent the same value.
     Assert( val >> 43 ==  0x8000000000000000ULL >> 43, ">>43");
                       ^
test/suites/sccz80/rshift.c:506:24: style: The comparison 'val>>44 == 0x8000000000000000ULL>>44' is always true because 'val>>44' and '0x8000000000000000ULL>>44' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 44 ==  0x8000000000000000ULL >> 44, ">>44");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:506:24: note: The comparison 'val>>44 == 0x8000000000000000ULL>>44' is always true because 'val>>44' and '0x8000000000000000ULL>>44' represent the same value.
     Assert( val >> 44 ==  0x8000000000000000ULL >> 44, ">>44");
                       ^
test/suites/sccz80/rshift.c:507:24: style: The comparison 'val>>45 == 0x8000000000000000ULL>>45' is always true because 'val>>45' and '0x8000000000000000ULL>>45' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 45 ==  0x8000000000000000ULL >> 45, ">>45");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:507:24: note: The comparison 'val>>45 == 0x8000000000000000ULL>>45' is always true because 'val>>45' and '0x8000000000000000ULL>>45' represent the same value.
     Assert( val >> 45 ==  0x8000000000000000ULL >> 45, ">>45");
                       ^
test/suites/sccz80/rshift.c:508:24: style: The comparison 'val>>46 == 0x8000000000000000ULL>>46' is always true because 'val>>46' and '0x8000000000000000ULL>>46' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 46 ==  0x8000000000000000ULL >> 46, ">>46");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:508:24: note: The comparison 'val>>46 == 0x8000000000000000ULL>>46' is always true because 'val>>46' and '0x8000000000000000ULL>>46' represent the same value.
     Assert( val >> 46 ==  0x8000000000000000ULL >> 46, ">>46");
                       ^
test/suites/sccz80/rshift.c:509:24: style: The comparison 'val>>47 == 0x8000000000000000ULL>>47' is always true because 'val>>47' and '0x8000000000000000ULL>>47' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 47 ==  0x8000000000000000ULL >> 47, ">>47");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:509:24: note: The comparison 'val>>47 == 0x8000000000000000ULL>>47' is always true because 'val>>47' and '0x8000000000000000ULL>>47' represent the same value.
     Assert( val >> 47 ==  0x8000000000000000ULL >> 47, ">>47");
                       ^
test/suites/sccz80/rshift.c:510:24: style: The comparison 'val>>48 == 0x8000000000000000ULL>>48' is always true because 'val>>48' and '0x8000000000000000ULL>>48' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 48 ==  0x8000000000000000ULL >> 48, ">>48");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:510:24: note: The comparison 'val>>48 == 0x8000000000000000ULL>>48' is always true because 'val>>48' and '0x8000000000000000ULL>>48' represent the same value.
     Assert( val >> 48 ==  0x8000000000000000ULL >> 48, ">>48");
                       ^
test/suites/sccz80/rshift.c:511:24: style: The comparison 'val>>49 == 0x8000000000000000ULL>>49' is always true because 'val>>49' and '0x8000000000000000ULL>>49' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 49 ==  0x8000000000000000ULL >> 49, ">>49");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:511:24: note: The comparison 'val>>49 == 0x8000000000000000ULL>>49' is always true because 'val>>49' and '0x8000000000000000ULL>>49' represent the same value.
     Assert( val >> 49 ==  0x8000000000000000ULL >> 49, ">>49");
                       ^
test/suites/sccz80/rshift.c:512:24: style: The comparison 'val>>50 == 0x8000000000000000ULL>>50' is always true because 'val>>50' and '0x8000000000000000ULL>>50' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 50 ==  0x8000000000000000ULL >> 50, ">>50");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:512:24: note: The comparison 'val>>50 == 0x8000000000000000ULL>>50' is always true because 'val>>50' and '0x8000000000000000ULL>>50' represent the same value.
     Assert( val >> 50 ==  0x8000000000000000ULL >> 50, ">>50");
                       ^
test/suites/sccz80/rshift.c:513:24: style: The comparison 'val>>51 == 0x8000000000000000ULL>>51' is always true because 'val>>51' and '0x8000000000000000ULL>>51' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 51 ==  0x8000000000000000ULL >> 51, ">>51");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:513:24: note: The comparison 'val>>51 == 0x8000000000000000ULL>>51' is always true because 'val>>51' and '0x8000000000000000ULL>>51' represent the same value.
     Assert( val >> 51 ==  0x8000000000000000ULL >> 51, ">>51");
                       ^
test/suites/sccz80/rshift.c:514:24: style: The comparison 'val>>52 == 0x8000000000000000ULL>>52' is always true because 'val>>52' and '0x8000000000000000ULL>>52' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 52 ==  0x8000000000000000ULL >> 52, ">>52");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:514:24: note: The comparison 'val>>52 == 0x8000000000000000ULL>>52' is always true because 'val>>52' and '0x8000000000000000ULL>>52' represent the same value.
     Assert( val >> 52 ==  0x8000000000000000ULL >> 52, ">>52");
                       ^
test/suites/sccz80/rshift.c:515:24: style: The comparison 'val>>53 == 0x8000000000000000ULL>>53' is always true because 'val>>53' and '0x8000000000000000ULL>>53' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 53 ==  0x8000000000000000ULL >> 53, ">>53");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:515:24: note: The comparison 'val>>53 == 0x8000000000000000ULL>>53' is always true because 'val>>53' and '0x8000000000000000ULL>>53' represent the same value.
     Assert( val >> 53 ==  0x8000000000000000ULL >> 53, ">>53");
                       ^
test/suites/sccz80/rshift.c:516:24: style: The comparison 'val>>54 == 0x8000000000000000ULL>>54' is always true because 'val>>54' and '0x8000000000000000ULL>>54' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 54 ==  0x8000000000000000ULL >> 54, ">>54");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:516:24: note: The comparison 'val>>54 == 0x8000000000000000ULL>>54' is always true because 'val>>54' and '0x8000000000000000ULL>>54' represent the same value.
     Assert( val >> 54 ==  0x8000000000000000ULL >> 54, ">>54");
                       ^
test/suites/sccz80/rshift.c:517:24: style: The comparison 'val>>55 == 0x8000000000000000ULL>>55' is always true because 'val>>55' and '0x8000000000000000ULL>>55' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 55 ==  0x8000000000000000ULL >> 55, ">>55");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:517:24: note: The comparison 'val>>55 == 0x8000000000000000ULL>>55' is always true because 'val>>55' and '0x8000000000000000ULL>>55' represent the same value.
     Assert( val >> 55 ==  0x8000000000000000ULL >> 55, ">>55");
                       ^
test/suites/sccz80/rshift.c:518:24: style: The comparison 'val>>56 == 0x8000000000000000ULL>>56' is always true because 'val>>56' and '0x8000000000000000ULL>>56' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 56 ==  0x8000000000000000ULL >> 56, ">>56");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:518:24: note: The comparison 'val>>56 == 0x8000000000000000ULL>>56' is always true because 'val>>56' and '0x8000000000000000ULL>>56' represent the same value.
     Assert( val >> 56 ==  0x8000000000000000ULL >> 56, ">>56");
                       ^
test/suites/sccz80/rshift.c:519:24: style: The comparison 'val>>57 == 0x8000000000000000ULL>>57' is always true because 'val>>57' and '0x8000000000000000ULL>>57' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 57 ==  0x8000000000000000ULL >> 57, ">>57");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:519:24: note: The comparison 'val>>57 == 0x8000000000000000ULL>>57' is always true because 'val>>57' and '0x8000000000000000ULL>>57' represent the same value.
     Assert( val >> 57 ==  0x8000000000000000ULL >> 57, ">>57");
                       ^
test/suites/sccz80/rshift.c:520:24: style: The comparison 'val>>58 == 0x8000000000000000ULL>>58' is always true because 'val>>58' and '0x8000000000000000ULL>>58' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 58 ==  0x8000000000000000ULL >> 58, ">>58");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:520:24: note: The comparison 'val>>58 == 0x8000000000000000ULL>>58' is always true because 'val>>58' and '0x8000000000000000ULL>>58' represent the same value.
     Assert( val >> 58 ==  0x8000000000000000ULL >> 58, ">>58");
                       ^
test/suites/sccz80/rshift.c:521:24: style: The comparison 'val>>59 == 0x8000000000000000ULL>>59' is always true because 'val>>59' and '0x8000000000000000ULL>>59' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 59 ==  0x8000000000000000ULL >> 59, ">>59");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:521:24: note: The comparison 'val>>59 == 0x8000000000000000ULL>>59' is always true because 'val>>59' and '0x8000000000000000ULL>>59' represent the same value.
     Assert( val >> 59 ==  0x8000000000000000ULL >> 59, ">>59");
                       ^
test/suites/sccz80/rshift.c:522:24: style: The comparison 'val>>60 == 0x8000000000000000ULL>>60' is always true because 'val>>60' and '0x8000000000000000ULL>>60' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 60 ==  0x8000000000000000ULL >> 60, ">>60");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:522:24: note: The comparison 'val>>60 == 0x8000000000000000ULL>>60' is always true because 'val>>60' and '0x8000000000000000ULL>>60' represent the same value.
     Assert( val >> 60 ==  0x8000000000000000ULL >> 60, ">>60");
                       ^
test/suites/sccz80/rshift.c:523:24: style: The comparison 'val>>61 == 0x8000000000000000ULL>>61' is always true because 'val>>61' and '0x8000000000000000ULL>>61' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 61 ==  0x8000000000000000ULL >> 61, ">>61");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:523:24: note: The comparison 'val>>61 == 0x8000000000000000ULL>>61' is always true because 'val>>61' and '0x8000000000000000ULL>>61' represent the same value.
     Assert( val >> 61 ==  0x8000000000000000ULL >> 61, ">>61");
                       ^
test/suites/sccz80/rshift.c:524:24: style: The comparison 'val>>62 == 0x8000000000000000ULL>>62' is always true because 'val>>62' and '0x8000000000000000ULL>>62' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 62 ==  0x8000000000000000ULL >> 62, ">>62");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:524:24: note: The comparison 'val>>62 == 0x8000000000000000ULL>>62' is always true because 'val>>62' and '0x8000000000000000ULL>>62' represent the same value.
     Assert( val >> 62 ==  0x8000000000000000ULL >> 62, ">>62");
                       ^
test/suites/sccz80/rshift.c:525:24: style: The comparison 'val>>63 == 0x8000000000000000ULL>>63' is always true because 'val>>63' and '0x8000000000000000ULL>>63' represent the same value. [knownConditionTrueFalse]
     Assert( val >> 63 ==  0x8000000000000000ULL >> 63, ">>63");
                       ^
test/suites/sccz80/rshift.c:459:31: note: 'val' is assigned value '0x8000000000000000ULL' here.
     unsigned long long val = 0x8000000000000000ULL;
                              ^
test/suites/sccz80/rshift.c:525:24: note: The comparison 'val>>63 == 0x8000000000000000ULL>>63' is always true because 'val>>63' and '0x8000000000000000ULL>>63' represent the same value.
     Assert( val >> 63 ==  0x8000000000000000ULL >> 63, ">>63");
                       ^
test/suites/sccz80/rshift.c:256:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 0, ">>0");
                 ^
test/suites/sccz80/rshift.c:258:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 1, ">>1");
                 ^
test/suites/sccz80/rshift.c:260:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 2, ">>2");
                 ^
test/suites/sccz80/rshift.c:262:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 3, ">>3");
                 ^
test/suites/sccz80/rshift.c:264:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 4, ">>4");
                 ^
test/suites/sccz80/rshift.c:266:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 5, ">>5");
                 ^
test/suites/sccz80/rshift.c:268:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 6, ">>6");
                 ^
test/suites/sccz80/rshift.c:270:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 7, ">>7");
                 ^
test/suites/sccz80/rshift.c:272:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 8, ">>8");
                 ^
test/suites/sccz80/rshift.c:274:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 9, ">>9");
                 ^
test/suites/sccz80/rshift.c:276:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 10, ">>10");
                 ^
test/suites/sccz80/rshift.c:278:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 11, ">>11");
                 ^
test/suites/sccz80/rshift.c:280:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 12, ">>12");
                 ^
test/suites/sccz80/rshift.c:282:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 13, ">>13");
                 ^
test/suites/sccz80/rshift.c:284:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 14, ">>14");
                 ^
test/suites/sccz80/rshift.c:286:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 15, ">>15");
                 ^
test/suites/sccz80/rshift.c:288:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 16, ">>16");
                 ^
test/suites/sccz80/rshift.c:290:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 17, ">>17");
                 ^
test/suites/sccz80/rshift.c:292:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 18, ">>18");
                 ^
test/suites/sccz80/rshift.c:294:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 19, ">>19");
                 ^
test/suites/sccz80/rshift.c:296:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 20, ">>20");
                 ^
test/suites/sccz80/rshift.c:298:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 21, ">>21");
                 ^
test/suites/sccz80/rshift.c:300:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 22, ">>22");
                 ^
test/suites/sccz80/rshift.c:302:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 23, ">>23");
                 ^
test/suites/sccz80/rshift.c:304:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 24, ">>24");
                 ^
test/suites/sccz80/rshift.c:306:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 25, ">>25");
                 ^
test/suites/sccz80/rshift.c:308:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 26, ">>26");
                 ^
test/suites/sccz80/rshift.c:310:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 27, ">>27");
                 ^
test/suites/sccz80/rshift.c:312:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 28, ">>28");
                 ^
test/suites/sccz80/rshift.c:314:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 29, ">>29");
                 ^
test/suites/sccz80/rshift.c:316:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 30, ">>30");
                 ^
test/suites/sccz80/rshift.c:318:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 31, ">>31");
                 ^
test/suites/sccz80/rshift.c:320:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 32, ">>32");
                 ^
test/suites/sccz80/rshift.c:322:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 33, ">>33");
                 ^
test/suites/sccz80/rshift.c:324:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 34, ">>34");
                 ^
test/suites/sccz80/rshift.c:326:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 35, ">>35");
                 ^
test/suites/sccz80/rshift.c:328:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 36, ">>36");
                 ^
test/suites/sccz80/rshift.c:330:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 37, ">>37");
                 ^
test/suites/sccz80/rshift.c:332:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 38, ">>38");
                 ^
test/suites/sccz80/rshift.c:334:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 39, ">>39");
                 ^
test/suites/sccz80/rshift.c:336:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 40, ">>40");
                 ^
test/suites/sccz80/rshift.c:338:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 41, ">>41");
                 ^
test/suites/sccz80/rshift.c:340:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 42, ">>42");
                 ^
test/suites/sccz80/rshift.c:342:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 43, ">>43");
                 ^
test/suites/sccz80/rshift.c:344:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 44, ">>44");
                 ^
test/suites/sccz80/rshift.c:346:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 45, ">>45");
                 ^
test/suites/sccz80/rshift.c:348:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 46, ">>46");
                 ^
test/suites/sccz80/rshift.c:350:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 47, ">>47");
                 ^
test/suites/sccz80/rshift.c:352:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 48, ">>48");
                 ^
test/suites/sccz80/rshift.c:354:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 49, ">>49");
                 ^
test/suites/sccz80/rshift.c:356:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 50, ">>50");
                 ^
test/suites/sccz80/rshift.c:358:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 51, ">>51");
                 ^
test/suites/sccz80/rshift.c:360:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 52, ">>52");
                 ^
test/suites/sccz80/rshift.c:362:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 53, ">>53");
                 ^
test/suites/sccz80/rshift.c:364:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 54, ">>54");
                 ^
test/suites/sccz80/rshift.c:366:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 55, ">>55");
                 ^
test/suites/sccz80/rshift.c:368:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 56, ">>56");
                 ^
test/suites/sccz80/rshift.c:370:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 57, ">>57");
                 ^
test/suites/sccz80/rshift.c:372:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 58, ">>58");
                 ^
test/suites/sccz80/rshift.c:374:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 59, ">>59");
                 ^
test/suites/sccz80/rshift.c:376:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 60, ">>60");
                 ^
test/suites/sccz80/rshift.c:378:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 61, ">>61");
                 ^
test/suites/sccz80/rshift.c:380:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 62, ">>62");
                 ^
test/suites/sccz80/rshift.c:382:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> v ==  0x8000000000000000LL >> 63, ">>63");
                 ^
test/suites/sccz80/rshift.c:391:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 0 ==  0x8000000000000000LL >> 0, ">>0");
                 ^
test/suites/sccz80/rshift.c:392:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 1 ==  0x8000000000000000LL >> 1, ">>1");
                 ^
test/suites/sccz80/rshift.c:393:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 2 ==  0x8000000000000000LL >> 2, ">>2");
                 ^
test/suites/sccz80/rshift.c:394:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 3 ==  0x8000000000000000LL >> 3, ">>3");
                 ^
test/suites/sccz80/rshift.c:395:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 4 ==  0x8000000000000000LL >> 4, ">>4");
                 ^
test/suites/sccz80/rshift.c:396:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 5 ==  0x8000000000000000LL >> 5, ">>5");
                 ^
test/suites/sccz80/rshift.c:397:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 6 ==  0x8000000000000000LL >> 6, ">>6");
                 ^
test/suites/sccz80/rshift.c:398:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 7 ==  0x8000000000000000LL >> 7, ">>7");
                 ^
test/suites/sccz80/rshift.c:399:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 8 ==  0x8000000000000000LL >> 8, ">>8");
                 ^
test/suites/sccz80/rshift.c:400:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 9 ==  0x8000000000000000LL >> 9, ">>9");
                 ^
test/suites/sccz80/rshift.c:401:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 10 ==  0x8000000000000000LL >> 10, ">>10");
                 ^
test/suites/sccz80/rshift.c:402:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 11 ==  0x8000000000000000LL >> 11, ">>11");
                 ^
test/suites/sccz80/rshift.c:403:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 12 ==  0x8000000000000000LL >> 12, ">>12");
                 ^
test/suites/sccz80/rshift.c:404:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 13 ==  0x8000000000000000LL >> 13, ">>13");
                 ^
test/suites/sccz80/rshift.c:405:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 14 ==  0x8000000000000000LL >> 14, ">>14");
                 ^
test/suites/sccz80/rshift.c:406:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 15 ==  0x8000000000000000LL >> 15, ">>15");
                 ^
test/suites/sccz80/rshift.c:407:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 16 ==  0x8000000000000000LL >> 16, ">>16");
                 ^
test/suites/sccz80/rshift.c:408:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 17 ==  0x8000000000000000LL >> 17, ">>17");
                 ^
test/suites/sccz80/rshift.c:409:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 18 ==  0x8000000000000000LL >> 18, ">>18");
                 ^
test/suites/sccz80/rshift.c:410:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 19 ==  0x8000000000000000LL >> 19, ">>19");
                 ^
test/suites/sccz80/rshift.c:411:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 20 ==  0x8000000000000000LL >> 20, ">>20");
                 ^
test/suites/sccz80/rshift.c:412:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 21 ==  0x8000000000000000LL >> 21, ">>21");
                 ^
test/suites/sccz80/rshift.c:413:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 22 ==  0x8000000000000000LL >> 22, ">>22");
                 ^
test/suites/sccz80/rshift.c:414:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 23 ==  0x8000000000000000LL >> 23, ">>23");
                 ^
test/suites/sccz80/rshift.c:415:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 24 ==  0x8000000000000000LL >> 24, ">>24");
                 ^
test/suites/sccz80/rshift.c:416:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 25 ==  0x8000000000000000LL >> 25, ">>25");
                 ^
test/suites/sccz80/rshift.c:417:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 26 ==  0x8000000000000000LL >> 26, ">>26");
                 ^
test/suites/sccz80/rshift.c:418:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 27 ==  0x8000000000000000LL >> 27, ">>27");
                 ^
test/suites/sccz80/rshift.c:419:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 28 ==  0x8000000000000000LL >> 28, ">>28");
                 ^
test/suites/sccz80/rshift.c:420:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 29 ==  0x8000000000000000LL >> 29, ">>29");
                 ^
test/suites/sccz80/rshift.c:421:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 30 ==  0x8000000000000000LL >> 30, ">>30");
                 ^
test/suites/sccz80/rshift.c:422:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 31 ==  0x8000000000000000LL >> 31, ">>31");
                 ^
test/suites/sccz80/rshift.c:423:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 32 ==  0x8000000000000000LL >> 32, ">>32");
                 ^
test/suites/sccz80/rshift.c:424:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 33 ==  0x8000000000000000LL >> 33, ">>33");
                 ^
test/suites/sccz80/rshift.c:425:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 34 ==  0x8000000000000000LL >> 34, ">>34");
                 ^
test/suites/sccz80/rshift.c:426:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 35 ==  0x8000000000000000LL >> 35, ">>35");
                 ^
test/suites/sccz80/rshift.c:427:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 36 ==  0x8000000000000000LL >> 36, ">>36");
                 ^
test/suites/sccz80/rshift.c:428:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 37 ==  0x8000000000000000LL >> 37, ">>37");
                 ^
test/suites/sccz80/rshift.c:429:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 38 ==  0x8000000000000000LL >> 38, ">>38");
                 ^
test/suites/sccz80/rshift.c:430:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 39 ==  0x8000000000000000LL >> 39, ">>39");
                 ^
test/suites/sccz80/rshift.c:431:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 40 ==  0x8000000000000000LL >> 40, ">>40");
                 ^
test/suites/sccz80/rshift.c:432:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 41 ==  0x8000000000000000LL >> 41, ">>41");
                 ^
test/suites/sccz80/rshift.c:433:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 42 ==  0x8000000000000000LL >> 42, ">>42");
                 ^
test/suites/sccz80/rshift.c:434:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 43 ==  0x8000000000000000LL >> 43, ">>43");
                 ^
test/suites/sccz80/rshift.c:435:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 44 ==  0x8000000000000000LL >> 44, ">>44");
                 ^
test/suites/sccz80/rshift.c:436:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 45 ==  0x8000000000000000LL >> 45, ">>45");
                 ^
test/suites/sccz80/rshift.c:437:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 46 ==  0x8000000000000000LL >> 46, ">>46");
                 ^
test/suites/sccz80/rshift.c:438:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 47 ==  0x8000000000000000LL >> 47, ">>47");
                 ^
test/suites/sccz80/rshift.c:439:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 48 ==  0x8000000000000000LL >> 48, ">>48");
                 ^
test/suites/sccz80/rshift.c:440:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 49 ==  0x8000000000000000LL >> 49, ">>49");
                 ^
test/suites/sccz80/rshift.c:441:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 50 ==  0x8000000000000000LL >> 50, ">>50");
                 ^
test/suites/sccz80/rshift.c:442:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 51 ==  0x8000000000000000LL >> 51, ">>51");
                 ^
test/suites/sccz80/rshift.c:443:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 52 ==  0x8000000000000000LL >> 52, ">>52");
                 ^
test/suites/sccz80/rshift.c:444:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 53 ==  0x8000000000000000LL >> 53, ">>53");
                 ^
test/suites/sccz80/rshift.c:445:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 54 ==  0x8000000000000000LL >> 54, ">>54");
                 ^
test/suites/sccz80/rshift.c:446:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 55 ==  0x8000000000000000LL >> 55, ">>55");
                 ^
test/suites/sccz80/rshift.c:447:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 56 ==  0x8000000000000000LL >> 56, ">>56");
                 ^
test/suites/sccz80/rshift.c:448:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 57 ==  0x8000000000000000LL >> 57, ">>57");
                 ^
test/suites/sccz80/rshift.c:449:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 58 ==  0x8000000000000000LL >> 58, ">>58");
                 ^
test/suites/sccz80/rshift.c:450:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 59 ==  0x8000000000000000LL >> 59, ">>59");
                 ^
test/suites/sccz80/rshift.c:451:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 60 ==  0x8000000000000000LL >> 60, ">>60");
                 ^
test/suites/sccz80/rshift.c:452:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 61 ==  0x8000000000000000LL >> 61, ">>61");
                 ^
test/suites/sccz80/rshift.c:453:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 62 ==  0x8000000000000000LL >> 62, ">>62");
                 ^
test/suites/sccz80/rshift.c:454:18: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
     Assert( val >> 63 ==  0x8000000000000000LL >> 63, ">>63");
                 ^
test/suites/sccz80/rshift.c:382:18: portability: Shifting signed 64-bit value by 63 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
     Assert( val >> v ==  0x8000000000000000LL >> 63, ">>63");
                 ^
test/suites/sccz80/rshift.c:253:15: note: Assignment 'v=0', assigned value is 0
     int  v = 0;
              ^
test/suites/sccz80/rshift.c:257:8: note: v is incremented', new value is 1
     ++v;
       ^
test/suites/sccz80/rshift.c:259:8: note: v is incremented', new value is 2
     ++v;
       ^
test/suites/sccz80/rshift.c:261:8: note: v is incremented', new value is 3
     ++v;
       ^
test/suites/sccz80/rshift.c:263:8: note: v is incremented', new value is 4
     ++v;
       ^
test/suites/sccz80/rshift.c:265:8: note: v is incremented', new value is 5
     ++v;
       ^
test/suites/sccz80/rshift.c:267:8: note: v is incremented', new value is 6
     ++v;
       ^
test/suites/sccz80/rshift.c:269:8: note: v is incremented', new value is 7
     ++v;
       ^
test/suites/sccz80/rshift.c:271:8: note: v is incremented', new value is 8
     ++v;
       ^
test/suites/sccz80/rshift.c:273:8: note: v is incremented', new value is 9
     ++v;
       ^
test/suites/sccz80/rshift.c:275:8: note: v is incremented', new value is 10
     ++v;
       ^
test/suites/sccz80/rshift.c:277:8: note: v is incremented', new value is 11
     ++v;
       ^
test/suites/sccz80/rshift.c:279:8: note: v is incremented', new value is 12
     ++v;
       ^
test/suites/sccz80/rshift.c:281:8: note: v is incremented', new value is 13
     ++v;
       ^
test/suites/sccz80/rshift.c:283:8: note: v is incremented', new value is 14
     ++v;
       ^
test/suites/sccz80/rshift.c:285:8: note: v is incremented', new value is 15
     ++v;
       ^
test/suites/sccz80/rshift.c:287:8: note: v is incremented', new value is 16
     ++v;
       ^
test/suites/sccz80/rshift.c:289:8: note: v is incremented', new value is 17
     ++v;
       ^
test/suites/sccz80/rshift.c:291:8: note: v is incremented', new value is 18
     ++v;
       ^
test/suites/sccz80/rshift.c:293:8: note: v is incremented', new value is 19
     ++v;
       ^
test/suites/sccz80/rshift.c:295:8: note: v is incremented', new value is 20
     ++v;
       ^
test/suites/sccz80/rshift.c:297:8: note: v is incremented', new value is 21
     ++v;
       ^
test/suites/sccz80/rshift.c:299:8: note: v is incremented', new value is 22
     ++v;
       ^
test/suites/sccz80/rshift.c:301:8: note: v is incremented', new value is 23
     ++v;
       ^
test/suites/sccz80/rshift.c:303:8: note: v is incremented', new value is 24
     ++v;
       ^
test/suites/sccz80/rshift.c:305:8: note: v is incremented', new value is 25
     ++v;
       ^
test/suites/sccz80/rshift.c:307:8: note: v is incremented', new value is 26
     ++v;
       ^
test/suites/sccz80/rshift.c:309:8: note: v is incremented', new value is 27
     ++v;
       ^
test/suites/sccz80/rshift.c:311:8: note: v is incremented', new value is 28
     ++v;
       ^
test/suites/sccz80/rshift.c:313:8: note: v is incremented', new value is 29
     ++v;
       ^
test/suites/sccz80/rshift.c:315:8: note: v is incremented', new value is 30
     ++v;
       ^
test/suites/sccz80/rshift.c:317:8: note: v is incremented', new value is 31
     ++v;
       ^
test/suites/sccz80/rshift.c:319:8: note: v is incremented', new value is 32
     ++v;
       ^
test/suites/sccz80/rshift.c:321:8: note: v is incremented', new value is 33
     ++v;
       ^
test/suites/sccz80/rshift.c:323:8: note: v is incremented', new value is 34
     ++v;
       ^
test/suites/sccz80/rshift.c:325:8: note: v is incremented', new value is 35
     ++v;
       ^
test/suites/sccz80/rshift.c:327:8: note: v is incremented', new value is 36
     ++v;
       ^
test/suites/sccz80/rshift.c:329:8: note: v is incremented', new value is 37
     ++v;
       ^
test/suites/sccz80/rshift.c:331:8: note: v is incremented', new value is 38
     ++v;
       ^
test/suites/sccz80/rshift.c:333:8: note: v is incremented', new value is 39
     ++v;
       ^
test/suites/sccz80/rshift.c:335:8: note: v is incremented', new value is 40
     ++v;
       ^
test/suites/sccz80/rshift.c:337:8: note: v is incremented', new value is 41
     ++v;
       ^
test/suites/sccz80/rshift.c:339:8: note: v is incremented', new value is 42
     ++v;
       ^
test/suites/sccz80/rshift.c:341:8: note: v is incremented', new value is 43
     ++v;
       ^
test/suites/sccz80/rshift.c:343:8: note: v is incremented', new value is 44
     ++v;
       ^
test/suites/sccz80/rshift.c:345:8: note: v is incremented', new value is 45
     ++v;
       ^
test/suites/sccz80/rshift.c:347:8: note: v is incremented', new value is 46
     ++v;
       ^
test/suites/sccz80/rshift.c:349:8: note: v is incremented', new value is 47
     ++v;
       ^
test/suites/sccz80/rshift.c:351:8: note: v is incremented', new value is 48
     ++v;
       ^
test/suites/sccz80/rshift.c:353:8: note: v is incremented', new value is 49
     ++v;
       ^
test/suites/sccz80/rshift.c:355:8: note: v is incremented', new value is 50
     ++v;
       ^
test/suites/sccz80/rshift.c:357:8: note: v is incremented', new value is 51
     ++v;
       ^
test/suites/sccz80/rshift.c:359:8: note: v is incremented', new value is 52
     ++v;
       ^
test/suites/sccz80/rshift.c:361:8: note: v is incremented', new value is 53
     ++v;
       ^
test/suites/sccz80/rshift.c:363:8: note: v is incremented', new value is 54
     ++v;
       ^
test/suites/sccz80/rshift.c:365:8: note: v is incremented', new value is 55
     ++v;
       ^
test/suites/sccz80/rshift.c:367:8: note: v is incremented', new value is 56
     ++v;
       ^
test/suites/sccz80/rshift.c:369:8: note: v is incremented', new value is 57
     ++v;
       ^
test/suites/sccz80/rshift.c:371:8: note: v is incremented', new value is 58
     ++v;
       ^
test/suites/sccz80/rshift.c:373:8: note: v is incremented', new value is 59
     ++v;
       ^
test/suites/sccz80/rshift.c:375:8: note: v is incremented', new value is 60
     ++v;
       ^
test/suites/sccz80/rshift.c:377:8: note: v is incremented', new value is 61
     ++v;
       ^
test/suites/sccz80/rshift.c:379:8: note: v is incremented', new value is 62
     ++v;
       ^
test/suites/sccz80/rshift.c:381:8: note: v is incremented', new value is 63
     ++v;
       ^
test/suites/sccz80/rshift.c:382:18: note: Shift
     Assert( val >> v ==  0x8000000000000000LL >> 63, ">>63");
                 ^
test/suites/sccz80/rshift.c:454:18: portability: Shifting signed 64-bit value by 63 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
     Assert( val >> 63 ==  0x8000000000000000LL >> 63, ">>63");
                 ^
test/suites/sccz80/rshift.c:45:6: style: Variable 'v' is assigned a value that is never used. [unreadVariable]
     ++v;
     ^
test/suites/sccz80/rshift.c:120:6: style: Variable 'v' is assigned a value that is never used. [unreadVariable]
     ++v;
     ^
test/suites/sccz80/structflexarray.c:33:25: error: Subtracting pointers that point to different objects [comparePointers]
   ASSERT((char *) &s12 - (char *) &s11 == 1 + 4);
                        ^
test/suites/sccz80/structflexarray.c:20:13: note: Variable declared here.
struct str1 s12 = { 4, {5, 6, 7} }; /* different size */
            ^
test/suites/sccz80/structflexarray.c:33:20: note: Address of variable taken here.
   ASSERT((char *) &s12 - (char *) &s11 == 1 + 4);
                   ^
test/suites/sccz80/structflexarray.c:19:13: note: Variable declared here.
struct str1 s11 = { 1, {2, 3} };
            ^
test/suites/sccz80/structflexarray.c:33:36: note: Address of variable taken here.
   ASSERT((char *) &s12 - (char *) &s11 == 1 + 4);
                                   ^
test/suites/sccz80/structflexarray.c:33:25: note: Subtracting pointers that point to different objects
   ASSERT((char *) &s12 - (char *) &s11 == 1 + 4);
                        ^
test/suites/sccz80/structflexarray.c:64:25: error: Subtracting pointers that point to different objects [comparePointers]
   ASSERT((char *) &s22 - (char *) &s21 == 2 + 5);
                        ^
test/suites/sccz80/structflexarray.c:51:13: note: Variable declared here.
struct str2 s22 = { 2, "sdcc is great" }; /* different size */
            ^
test/suites/sccz80/structflexarray.c:64:20: note: Address of variable taken here.
   ASSERT((char *) &s22 - (char *) &s21 == 2 + 5);
                   ^
test/suites/sccz80/structflexarray.c:50:13: note: Variable declared here.
struct str2 s21 = { 1, "sdcc" };
            ^
test/suites/sccz80/structflexarray.c:64:36: note: Address of variable taken here.
   ASSERT((char *) &s22 - (char *) &s21 == 2 + 5);
                                   ^
test/suites/sccz80/structflexarray.c:64:25: note: Subtracting pointers that point to different objects
   ASSERT((char *) &s22 - (char *) &s21 == 2 + 5);
                        ^
test/suites/stdio/scanf.c:60:2: warning:inconclusive: Width 5 given in format string (no. 1) is smaller than destination buffer 'buf[20]'. [invalidScanfFormatWidth_smaller]
 sscanf("hellothere","%5s", buf);
 ^
test/suites/stdio/scanf.c:56:2: warning: sscanf() without field width limits can crash with huge input data. [invalidscanf]
 sscanf("hellothere","%s", buf);
 ^
test/suites/stdio/scanf.c:14:31: style: Variable 'failures' is assigned a value that is never used. [unreadVariable]
    unsigned int     failures = 0;
                              ^
test/suites/stdio/scanf.c:15:30: style: Variable 'success' is assigned a value that is never used. [unreadVariable]
    unsigned int     success = 0;
                             ^
test/suites/stdlib/bsearch.c:611:7: style: The scope of the variable 'f' can be reduced. [variableScope]
  int f,g,h;
      ^
test/suites/stdlib/bsearch.c:611:9: style: The scope of the variable 'g' can be reduced. [variableScope]
  int f,g,h;
        ^
test/suites/stdlib/bsearch.c:611:11: style: The scope of the variable 'h' can be reduced. [variableScope]
  int f,g,h;
          ^
test/suites/stdlib/bsearch.c:614:7: style: Variable 'f' is assigned a value that is never used. [unreadVariable]
    f = e;
      ^
test/suites/stdlib/bsearch.c:615:7: style: Variable 'g' is assigned a value that is never used. [unreadVariable]
    g = *c;
      ^
test/suites/stdlib/bsearch.c:616:7: style: Variable 'h' is assigned a value that is never used. [unreadVariable]
    h = *d;
      ^
test/suites/stdlib/bsearch.c:636:7: style: Unused variable: found [unusedVariable]
  int found;
      ^
test/suites/stdlib/qsort_newlib.c:46:31: style: Variable '__CLIB_OPT_SORT_QSORT' is assigned a value that is never used. [unreadVariable]
   DEFC __CLIB_OPT_SORT_QSORT = 0x0c   ; middle-pivot, insertion-sort enabled, equality dispersal enabled
                              ^
test/suites/stdlib/qsort_newlib.c:48:31: style: Variable '__CLIB_OPT_SORT_QSORT' is assigned a value that is never used. [unreadVariable]
   DEFC __CLIB_OPT_SORT_QSORT = 0x04   ; middle-pivot, insertion-sort enabled, equality dispersal disabled (missing R reg)
                              ^
test/suites/stdlib/unbcd.c:24:18: style: The scope of the variable 'result' can be reduced. [variableScope]
    unsigned int result;
                 ^
test/suites/string/strcmp.c:12:12: warning: Unnecessary comparison of static strings. [staticStringCompare]
    Assert(strcmp("equal","equal") == 0, "Should be == 0");
           ^
test/suites/string/strcmp.c:17:12: warning: Unnecessary comparison of static strings. [staticStringCompare]
    Assert(strcmp("equal","notequal") < 0, "Should be < 0");
           ^
test/suites/string/strcmp.c:22:12: warning: Unnecessary comparison of static strings. [staticStringCompare]
    Assert(strcmp("equal","EQUAL") > 0, "Should be > 0");
           ^
test/suites/string/strlcat.c:22:11: style: Unused variable: ret [unusedVariable]
    int   ret;
          ^
test/suites/string/strncat.c:21:11: style: Unused variable: ret [unusedVariable]
    int   ret;
          ^
test/suites/string/strncat.c:36:12: style: Variable 'result' is assigned a value that is never used. [unreadVariable]
    result = strncat(buf, "Last", sizeof(buf));
           ^
test/suites/string/strncmp.c:9:12: warning: Unnecessary comparison of static strings. [staticStringCompare]
    Assert(strncmp("equal","equal",5) == 0, "Should be == 0");
           ^
test/suites/string/strncmp.c:14:12: warning: Unnecessary comparison of static strings. [staticStringCompare]
    Assert(strncmp("equal","equalbar",5) == 0, "Should be == 0");
           ^
test/suites/string/strncmp.c:20:12: warning: Unnecessary comparison of static strings. [staticStringCompare]
    Assert(strncmp("equal","notequal",5) < 0, "Should be < 0");
           ^
test/suites/string/strncmp.c:25:12: warning: Unnecessary comparison of static strings. [staticStringCompare]
    Assert(strncmp("equal","EQUAL",5) > 0, "Should be > 0");
           ^
test/suites/zx/tshc_py2aaddr.c:27:25: error: syntax error [syntaxError]
    push   hl    ; Save for later
                        ^
test/suites/zx/zx_py2aaddr.c:25:25: error: syntax error [syntaxError]
    push   hl    ; Save for later
                        ^
test/suites/zx/zx_py2saddr.c:24:25: error: syntax error [syntaxError]
    push   hl    ; Save for later
                        ^
test/suites/zx/zx_saddr2cy.c:24:25: error: syntax error [syntaxError]
    push   hl    ; Save for later
                        ^
test/suites/zx/zx_saddr2py.c:24:25: error: syntax error [syntaxError]
    push   hl    ; Save for later
                        ^
test/suites/zx/zx_saddrcdown.c:26:25: error: syntax error [syntaxError]
    push   hl    ; Save for later
                        ^
test/suites/zx/zx_saddrcleft.c:24:25: error: syntax error [syntaxError]
    push   hl    ; Save for later
                        ^
test/suites/zx/zx_saddrcright.c:24:25: error: syntax error [syntaxError]
    push   hl    ; Save for later
                        ^
test/suites/zx/zx_saddrcup.c:24:25: error: syntax error [syntaxError]
    push   hl    ; Save for later
                        ^
test/suites/zx/zx_saddrpdown.c:24:25: error: syntax error [syntaxError]
    push   hl    ; Save for later
                        ^
test/suites/zx/zx_saddrpleft.c:24:12: style: Variable 'ix' is not assigned a value. [unassignedVariable]
    ld     ix,2
           ^
test/suites/zx/zx_saddrpright.c:24:12: style: Variable 'ix' is not assigned a value. [unassignedVariable]
    ld     ix,2
           ^
test/suites/zx/zx_saddrpup.c:24:25: error: syntax error [syntaxError]
    push   hl    ; Save for later
                        ^
testsuite/01_cast_global_pointer.c:10:6: style: Variable 'b' is reassigned a value before the old one has been used. [redundantAssignment]
   b = ((int *)c);
     ^
testsuite/01_cast_global_pointer.c:9:6: note: b is assigned
   b = (int *)(a);
     ^
testsuite/01_cast_global_pointer.c:10:6: note: b is overwritten
   b = ((int *)c);
     ^
testsuite/01_cast_global_pointer.c:16:7: style: Local variable 'a' shadows outer variable [shadowVariable]
 int *a = (int *)v;
      ^
testsuite/01_cast_global_pointer.c:2:7: note: Shadowed declaration
char *a;
      ^
testsuite/01_cast_global_pointer.c:16:7: note: Shadow variable
 int *a = (int *)v;
      ^
testsuite/01_cast_global_pointer.c:10:6: style: Variable 'b' is assigned a value that is never used. [unreadVariable]
   b = ((int *)c);
     ^
testsuite/01_cast_global_pointer.c:16:9: style: Variable 'a' is assigned a value that is never used. [unreadVariable]
 int *a = (int *)v;
        ^
testsuite/01_cast_global_pointer.c:17:8: style: Variable 'x' is assigned a value that is never used. [unreadVariable]
 int x = 1;
       ^
testsuite/Issue_1015_break_with_loop_variable.c:6:7: style: Unused variable: l [unusedVariable]
 long l;
      ^
testsuite/Issue_1015_break_without_loop_variable.c:7:11: style: Unused variable: l [unusedVariable]
     long l;
          ^
testsuite/Issue_1016_double_const_compare.c:9:11: style: Condition '4<f' is always false [knownConditionTrueFalse]
    if (4 < f) {
          ^
testsuite/Issue_1016_double_const_compare.c:7:15: note: Assignment 'f=0', assigned value is 0
    float f = 0;
              ^
testsuite/Issue_1016_double_const_compare.c:9:11: note: Condition '4<f' is always false
    if (4 < f) {
          ^
testsuite/Issue_1016_double_const_compare.c:15:11: style: Condition 'f>4' is always false [knownConditionTrueFalse]
    if (f > 4) {
          ^
testsuite/Issue_1016_double_const_compare.c:7:15: note: Assignment 'f=0', assigned value is 0
    float f = 0;
              ^
testsuite/Issue_1016_double_const_compare.c:15:11: note: Condition 'f>4' is always false
    if (f > 4) {
          ^
testsuite/Issue_1016_long_const_compare.c:9:12: style: Condition '4L<f' is always false [knownConditionTrueFalse]
    if (4L < f) {
           ^
testsuite/Issue_1016_long_const_compare.c:7:14: note: Assignment 'f=0', assigned value is 0
    long f = 0;
             ^
testsuite/Issue_1016_long_const_compare.c:9:12: note: Condition '4L<f' is always false
    if (4L < f) {
           ^
testsuite/Issue_1016_long_const_compare.c:15:11: style: Condition 'f>4L' is always false [knownConditionTrueFalse]
    if (f > 4L) {
          ^
testsuite/Issue_1016_long_const_compare.c:7:14: note: Assignment 'f=0', assigned value is 0
    long f = 0;
             ^
testsuite/Issue_1016_long_const_compare.c:15:11: note: Condition 'f>4L' is always false
    if (f > 4L) {
          ^
testsuite/Issue_103_double_prepost.c:11:11: style: Variable 'y' is assigned a value that is never used. [unreadVariable]
        y = x++;
          ^
testsuite/Issue_103_double_prepost.c:26:11: style: Variable 'y' is assigned a value that is never used. [unreadVariable]
        y = ++x;
          ^
testsuite/Issue_103_double_prepost.c:40:11: style: Variable 'y' is assigned a value that is never used. [unreadVariable]
        y = x--;
          ^
testsuite/Issue_103_double_prepost.c:55:11: style: Variable 'y' is assigned a value that is never used. [unreadVariable]
        y = --x;
          ^
testsuite/Issue_1105_function_pointer_calls.c:18:5: error: Uninitialized variable: ptr [uninitvar]
    ptr("test2");
    ^
testsuite/Issue_1105_function_pointer_calls.c:58:5: error: Uninitialized variable: ptr [uninitvar]
    ptr(1.0);
    ^
testsuite/Issue_1105_function_pointer_calls.c:69:5: error: Uninitialized variable: ptr [uninitvar]
    ptr(10, -1);
    ^
testsuite/Issue_1105_function_pointer_calls.c:79:5: error: Uninitialized variable: ptr [uninitvar]
    ptr(1, "test1");
    ^
testsuite/Issue_1132_struct_by_value.c:33:9: error: Uninitialized variable: b [uninitvar]
    a = b;
        ^
testsuite/Issue_1132_struct_by_value.c:33:9: error: Uninitialized struct member: b.x [uninitStructMember]
    a = b;
        ^
testsuite/Issue_1132_struct_by_value.c:33:9: error: Uninitialized struct member: b.y [uninitStructMember]
    a = b;
        ^
testsuite/Issue_1132_struct_by_value.c:41:10: error: Uninitialized variable: a [uninitvar]
    *b = a;
         ^
testsuite/Issue_1132_struct_by_value.c:41:10: error: Uninitialized struct member: a.x [uninitStructMember]
    *b = a;
         ^
testsuite/Issue_1132_struct_by_value.c:41:10: error: Uninitialized struct member: a.y [uninitStructMember]
    *b = a;
         ^
testsuite/Issue_1132_struct_by_value.c:41:6: error: Uninitialized variable: b [uninitvar]
    *b = a;
     ^
testsuite/Issue_1132_struct_by_value.c:50:10: error: Uninitialized variable: b [uninitvar]
    a = *b;
         ^
testsuite/Issue_1132_struct_by_value.c:33:7: style: Variable 'a' is assigned a value that is never used. [unreadVariable]
    a = b;
      ^
testsuite/Issue_1132_struct_by_value.c:39:18: style: Variable 'b' is not assigned a value. [unassignedVariable]
    struct test *b;
                 ^
testsuite/Issue_1132_struct_by_value.c:50:7: style: Variable 'a' is assigned a value that is never used. [unreadVariable]
    a = *b;
      ^
testsuite/Issue_1132_struct_by_value.c:48:18: style: Variable 'b' is not assigned a value. [unassignedVariable]
    struct test *b;
                 ^
testsuite/Issue_1132_struct_parameter.c:29:10: error: Uninitialized variable: a [uninitvar]
    func(a, 10);
         ^
testsuite/Issue_1132_struct_parameter.c:29:10: error: Uninitialized struct member: a.x [uninitStructMember]
    func(a, 10);
         ^
testsuite/Issue_1132_struct_parameter.c:29:10: error: Uninitialized struct member: a.y [uninitStructMember]
    func(a, 10);
         ^
testsuite/Issue_1132_struct_parameter.c:5:12: style: struct member 'test::c' is never used. [unusedStructMember]
    char   c[10];
           ^
testsuite/Issue_1132_struct_parameter.c:7:12: style: struct member 'test::y' is never used. [unusedStructMember]
    int    y;
           ^
testsuite/Issue_1132_struct_parameter.c:16:9: style: Variable 'x.x' is assigned a value that is never used. [unreadVariable]
    x.x = 10;
        ^
testsuite/Issue_1132_struct_parameter.c:21:9: style: Variable 'x.x' is assigned a value that is never used. [unreadVariable]
    x.x = 10;
        ^
testsuite/Issue_1133_bitfields.c:17:11: style: Variable 'z' is reassigned a value before the old one has been used. [redundantAssignment]
        z = x.a;
          ^
testsuite/Issue_1133_bitfields.c:16:11: note: z is assigned
        z = sizeof(x);
          ^
testsuite/Issue_1133_bitfields.c:17:11: note: z is overwritten
        z = x.a;
          ^
testsuite/Issue_1133_bitfields.c:11:17: style: Local variable 'z' shadows outer variable [shadowVariable]
        int     z;
                ^
testsuite/Issue_1133_bitfields.c:38:3: note: Shadowed declaration
} z = { 32768};
  ^
testsuite/Issue_1133_bitfields.c:11:17: note: Shadow variable
        int     z;
                ^
testsuite/Issue_188_builtins.c:7:5: warning: Return value of function strchr() is not used. [ignoredReturnValue]
    strchr(ptr,c);
    ^
testsuite/Issue_188_builtins.c:12:5: warning: Return value of function strchr() is not used. [ignoredReturnValue]
    strchr(ptr,'a');
    ^
testsuite/Issue_2234_ternary.c:9:13: style: Variable 'val' is assigned a value that is never used. [unreadVariable]
    int val = testfunc() > 0 ? 2 : 1;
            ^
testsuite/Issue_2234_ternary.c:15:13: style: Variable 'val' is assigned a value that is never used. [unreadVariable]
    int val = testfunc() ? 2 : 1;
            ^
testsuite/Issue_2234_ternary.c:21:13: style: Variable 'val' is assigned a value that is never used. [unreadVariable]
    int val = 10  ? 2 : 1;
            ^
testsuite/Issue_2234_ternary.c:27:13: style: Variable 'val' is assigned a value that is never used. [unreadVariable]
    int val = 0 ? 2 : 1;
            ^
testsuite/Issue_2234_ternary.c:33:13: style: Variable 'val' is assigned a value that is never used. [unreadVariable]
    int val = 10  ? testfunc() : 1;
            ^
testsuite/Issue_2234_ternary.c:39:13: style: Variable 'val' is assigned a value that is never used. [unreadVariable]
    int val = 0 ? 2 : testfunc();;
            ^
testsuite/Issue_2234_ternary.c:58:10: style: Variable 'val' is assigned a value that is never used. [unreadVariable]
    val  = 10  ? 2 : 1;
         ^
testsuite/Issue_2234_ternary.c:66:10: style: Variable 'val' is assigned a value that is never used. [unreadVariable]
    val  = 0 ? 2 : 1;
         ^
testsuite/Issue_26_casting.c:8:11: error: Null pointer dereference: (far long*)ptr [nullPointer]
     n = *(far long *)ptr;
          ^
testsuite/Issue_26_casting.c:5:20: note: Assignment 'ptr=0', assigned value is 0
     char   *ptr = 0;
                   ^
testsuite/Issue_26_casting.c:8:11: note: Null pointer dereference
     n = *(far long *)ptr;
          ^
testsuite/Issue_26_casting.c:16:11: error: Null pointer dereference: (far int*)ptr [nullPointer]
     n = *(far int *)ptr;
          ^
testsuite/Issue_26_casting.c:13:20: note: Assignment 'ptr=0', assigned value is 0
     char   *ptr = 0;
                   ^
testsuite/Issue_26_casting.c:16:11: note: Null pointer dereference
     n = *(far int *)ptr;
          ^
testsuite/Issue_26_casting.c:24:11: error: Null pointer dereference: (long*)ptr [nullPointer]
     n = *(long *)ptr;
          ^
testsuite/Issue_26_casting.c:21:24: note: Assignment 'ptr=0', assigned value is 0
     far char   *ptr = 0;
                       ^
testsuite/Issue_26_casting.c:24:11: note: Null pointer dereference
     n = *(long *)ptr;
          ^
testsuite/Issue_26_casting.c:8:8: style: Variable 'n' is assigned a value that is never used. [unreadVariable]
     n = *(far long *)ptr;
       ^
testsuite/Issue_26_casting.c:16:8: style: Variable 'n' is assigned a value that is never used. [unreadVariable]
     n = *(far int *)ptr;
       ^
testsuite/Issue_26_casting.c:24:8: style: Variable 'n' is assigned a value that is never used. [unreadVariable]
     n = *(long *)ptr;
       ^
testsuite/Issue_452_arrays.c:13:9: error: Uninitialized variable: A [uninitvar]
 return A[i];
        ^
testsuite/Issue_452_arrays.c:26:9: error: Uninitialized variable: A [uninitvar]
 return A[2];
        ^
testsuite/Issue_452_arrays.c:33:9: error: Uninitialized variable: A [uninitvar]
 return A[1][1];
        ^
testsuite/Issue_452_arrays.c:41:9: error: Uninitialized variable: A [uninitvar]
 return A[i][j];
        ^
testsuite/Issue_452_arrays.c:11:6: style: Variable 'A' is not assigned a value. [unassignedVariable]
 int A[10];
     ^
testsuite/Issue_452_arrays.c:25:6: style: Variable 'A' is not assigned a value. [unassignedVariable]
 int A[10];
     ^
testsuite/Issue_452_far_pointers.c:34:3: error: Uninitialized variable: ptr [uninitvar]
 *ptr = val;
  ^
testsuite/Issue_452_far_pointers.c:41:8: note: Calling function 'func5', 1st argument 'ptr' value is <Uninit>
 func5(ptr,1);
       ^
testsuite/Issue_452_far_pointers.c:34:3: note: Uninitialized variable: ptr
 *ptr = val;
  ^
testsuite/Issue_452_pointers.c:11:14: error: Overflow in pointer arithmetic, NULL pointer is subtracted. [nullPointerArithmetic]
 ptr1 = ptr2 - 2;
             ^
testsuite/Issue_452_pointers.c:9:15: note: Assignment 'ptr2=0', assigned value is 0
 char *ptr2 = 0;
              ^
testsuite/Issue_452_pointers.c:11:14: note: Null pointer subtraction
 ptr1 = ptr2 - 2;
             ^
testsuite/Issue_452_pointers.c:13:14: error: Overflow in pointer arithmetic, NULL pointer is subtracted. [nullPointerArithmetic]
 return ptr2 - ptr1;
             ^
testsuite/Issue_452_pointers.c:9:15: note: Assignment 'ptr2=0', assigned value is 0
 char *ptr2 = 0;
              ^
testsuite/Issue_452_pointers.c:13:14: note: Null pointer subtraction
 return ptr2 - ptr1;
             ^
testsuite/Issue_452_pointers.c:21:14: error: Overflow in pointer arithmetic, NULL pointer is subtracted. [nullPointerArithmetic]
 ptr1 = ptr2 - 2;
             ^
testsuite/Issue_452_pointers.c:19:15: note: Assignment 'ptr2=0', assigned value is 0
 int  *ptr2 = 0;
              ^
testsuite/Issue_452_pointers.c:21:14: note: Null pointer subtraction
 ptr1 = ptr2 - 2;
             ^
testsuite/Issue_452_pointers.c:23:14: error: Overflow in pointer arithmetic, NULL pointer is subtracted. [nullPointerArithmetic]
 return ptr2 - ptr1;
             ^
testsuite/Issue_452_pointers.c:19:15: note: Assignment 'ptr2=0', assigned value is 0
 int  *ptr2 = 0;
              ^
testsuite/Issue_452_pointers.c:23:14: note: Null pointer subtraction
 return ptr2 - ptr1;
             ^
testsuite/Issue_452_pointers.c:31:14: error: Overflow in pointer arithmetic, NULL pointer is subtracted. [nullPointerArithmetic]
 ptr1 = ptr2 - 2;
             ^
testsuite/Issue_452_pointers.c:29:15: note: Assignment 'ptr2=0', assigned value is 0
 long *ptr2 = 0;
              ^
testsuite/Issue_452_pointers.c:31:14: note: Null pointer subtraction
 ptr1 = ptr2 - 2;
             ^
testsuite/Issue_452_pointers.c:33:14: error: Overflow in pointer arithmetic, NULL pointer is subtracted. [nullPointerArithmetic]
 return ptr2 - ptr1;
             ^
testsuite/Issue_452_pointers.c:29:15: note: Assignment 'ptr2=0', assigned value is 0
 long *ptr2 = 0;
              ^
testsuite/Issue_452_pointers.c:33:14: note: Null pointer subtraction
 return ptr2 - ptr1;
             ^
testsuite/Issue_452_pointers.c:41:14: error: Overflow in pointer arithmetic, NULL pointer is subtracted. [nullPointerArithmetic]
 ptr1 = ptr2 - 2;
             ^
testsuite/Issue_452_pointers.c:39:17: note: Assignment 'ptr2=0', assigned value is 0
 double *ptr2 = 0;
                ^
testsuite/Issue_452_pointers.c:41:14: note: Null pointer subtraction
 ptr1 = ptr2 - 2;
             ^
testsuite/Issue_452_pointers.c:51:14: error: Overflow in pointer arithmetic, NULL pointer is subtracted. [nullPointerArithmetic]
 ptr1 = ptr2 - 2;
             ^
testsuite/Issue_452_pointers.c:49:19: note: Assignment 'ptr2=0', assigned value is 0
 struct x *ptr2 = 0;
                  ^
testsuite/Issue_452_pointers.c:51:14: note: Null pointer subtraction
 ptr1 = ptr2 - 2;
             ^
testsuite/Issue_452_pointers.c:63:9: error: Uninitialized variable: ptr1 [uninitvar]
 return ptr1 - array;
        ^
testsuite/Issue_452_pointers.c:71:9: error: Uninitialized variable: ptr1 [uninitvar]
 return ptr1 - &array[0];
        ^
testsuite/Issue_452_pointers.c:78:9: error: Uninitialized variable: ptr1 [uninitvar]
 return ptr1 - (char *)&array[0];
        ^
testsuite/Issue_452_pointers.c:60:12: style: Variable 'ptr1' is not assigned a value. [unassignedVariable]
 struct x *ptr1;
           ^
testsuite/Issue_452_pointers.c:61:9: style: Unused variable: c [unusedVariable]
 int    c;
        ^
testsuite/Issue_452_pointers.c:68:12: style: Variable 'ptr1' is not assigned a value. [unassignedVariable]
 struct x *ptr1;
           ^
testsuite/Issue_452_pointers.c:69:9: style: Unused variable: c [unusedVariable]
 int    c;
        ^
testsuite/Issue_452_pointers.c:75:12: style: Variable 'ptr1' is not assigned a value. [unassignedVariable]
 struct x *ptr1;
           ^
testsuite/Issue_452_pointers.c:76:9: style: Unused variable: c [unusedVariable]
 int    c;
        ^
testsuite/Issue_452_struct.c:14:9: error: Null pointer dereference: ctx [nullPointer]
        ctx->i[1] = 1;
        ^
testsuite/Issue_452_struct.c:12:24: note: Assignment 'ctx=0', assigned value is 0
        MD5_CTX *ctx = 0;
                       ^
testsuite/Issue_452_struct.c:14:9: note: Null pointer dereference
        ctx->i[1] = 1;
        ^
testsuite/Issue_452_struct.c:21:9: warning: Possible null pointer dereference: ctx [nullPointer]
        ctx->i[1] = 1;
        ^
testsuite/Issue_452_struct.c:19:31: note: Assignment 'ctx=0', assigned value is 0
        static MD5_CTX *ctx = 0;
                              ^
testsuite/Issue_452_struct.c:21:9: note: Null pointer dereference
        ctx->i[1] = 1;
        ^
testsuite/Issue_452_struct.c:28:18: style: Variable 'ctx.i[1]' is assigned a value that is never used. [unreadVariable]
        ctx.i[1] = 1;
                 ^
testsuite/Issue_452_unsigned.c:8:10: style: Same expression on both sides of '/'. [duplicateExpression]
 return c/d;
         ^
testsuite/Issue_452_unsigned.c:5:11: note: 'c' is assigned value '0' here.
 char c = 0;
          ^
testsuite/Issue_452_unsigned.c:6:11: note: 'd' is assigned value '0' here.
 char d = 0;
          ^
testsuite/Issue_452_unsigned.c:8:10: note: Same expression on both sides of '/'.
 return c/d;
         ^
testsuite/Issue_452_unsigned.c:16:10: style: Same expression on both sides of '/'. [duplicateExpression]
 return c/d;
         ^
testsuite/Issue_452_unsigned.c:13:11: note: 'c' is assigned value '0' here.
 char c = 0;
          ^
testsuite/Issue_452_unsigned.c:14:20: note: 'd' is assigned value '0' here.
 unsigned char d = 0;
                   ^
testsuite/Issue_452_unsigned.c:16:10: note: Same expression on both sides of '/'.
 return c/d;
         ^
testsuite/Issue_452_unsigned.c:25:10: style: Same expression on both sides of '/'. [duplicateExpression]
 return c/d;
         ^
testsuite/Issue_452_unsigned.c:22:10: note: 'c' is assigned value '0' here.
 int c = 0;
         ^
testsuite/Issue_452_unsigned.c:23:10: note: 'd' is assigned value '0' here.
 int d = 0;
         ^
testsuite/Issue_452_unsigned.c:25:10: note: Same expression on both sides of '/'.
 return c/d;
         ^
testsuite/Issue_452_unsigned.c:33:10: style: Same expression on both sides of '/'. [duplicateExpression]
 return c/d;
         ^
testsuite/Issue_452_unsigned.c:30:10: note: 'c' is assigned value '0' here.
 int c = 0;
         ^
testsuite/Issue_452_unsigned.c:31:19: note: 'd' is assigned value '0' here.
 unsigned int d = 0;
                  ^
testsuite/Issue_452_unsigned.c:33:10: note: Same expression on both sides of '/'.
 return c/d;
         ^
testsuite/Issue_452_unsigned.c:8:10: error: Division by zero. [zerodiv]
 return c/d;
         ^
testsuite/Issue_452_unsigned.c:6:11: note: Assignment 'd=0', assigned value is 0
 char d = 0;
          ^
testsuite/Issue_452_unsigned.c:8:10: note: Division by zero
 return c/d;
         ^
testsuite/Issue_452_unsigned.c:16:10: error: Division by zero. [zerodiv]
 return c/d;
         ^
testsuite/Issue_452_unsigned.c:14:20: note: Assignment 'd=0', assigned value is 0
 unsigned char d = 0;
                   ^
testsuite/Issue_452_unsigned.c:16:10: note: Division by zero
 return c/d;
         ^
testsuite/Issue_452_unsigned.c:25:10: error: Division by zero. [zerodiv]
 return c/d;
         ^
testsuite/Issue_452_unsigned.c:23:10: note: Assignment 'd=0', assigned value is 0
 int d = 0;
         ^
testsuite/Issue_452_unsigned.c:25:10: note: Division by zero
 return c/d;
         ^
testsuite/Issue_452_unsigned.c:33:10: error: Division by zero. [zerodiv]
 return c/d;
         ^
testsuite/Issue_452_unsigned.c:31:19: note: Assignment 'd=0', assigned value is 0
 unsigned int d = 0;
                  ^
testsuite/Issue_452_unsigned.c:33:10: note: Division by zero
 return c/d;
         ^
testsuite/Issue_489_variable_defn_in_forloop.c:19:9: error: Uninitialized variable: k [uninitvar]
 return k;
        ^
testsuite/Issue_489_variable_defn_in_forloop.c:5:6: style: Unused variable: k [unusedVariable]
 int k;
     ^
testsuite/Issue_489_variable_defn_in_forloop.c:14:6: style: Variable 'k' is not assigned a value. [unassignedVariable]
 int k;
     ^
testsuite/Issue_490_ptr_arithmetic.c:7:13: error: Overflow in pointer arithmetic, NULL pointer is subtracted. [nullPointerArithmetic]
 return ptr - arr;
            ^
testsuite/Issue_490_ptr_arithmetic.c:5:14: note: Assignment 'ptr=0', assigned value is 0
 char *ptr = 0;
             ^
testsuite/Issue_490_ptr_arithmetic.c:7:13: note: Null pointer subtraction
 return ptr - arr;
            ^
testsuite/Issue_490_ptr_arithmetic.c:15:13: error: Overflow in pointer arithmetic, NULL pointer is subtracted. [nullPointerArithmetic]
 return ptr - arr;
            ^
testsuite/Issue_490_ptr_arithmetic.c:13:13: note: Assignment 'ptr=0', assigned value is 0
 int *ptr = 0;
            ^
testsuite/Issue_490_ptr_arithmetic.c:15:13: note: Null pointer subtraction
 return ptr - arr;
            ^
testsuite/Issue_490_ptr_arithmetic.c:22:13: error: Overflow in pointer arithmetic, NULL pointer is subtracted. [nullPointerArithmetic]
 return ptr - &arr[0];
            ^
testsuite/Issue_490_ptr_arithmetic.c:20:14: note: Assignment 'ptr=0', assigned value is 0
 long *ptr = 0;
             ^
testsuite/Issue_490_ptr_arithmetic.c:22:13: note: Null pointer subtraction
 return ptr - &arr[0];
            ^
testsuite/Issue_490_ptr_arithmetic.c:6:7: style: Variable 'arr' is not assigned a value. [unassignedVariable]
 char arr[5];
      ^
testsuite/Issue_490_ptr_arithmetic.c:14:6: style: Variable 'arr' is not assigned a value. [unassignedVariable]
 int arr[5];
     ^
testsuite/Issue_490_ptr_arithmetic.c:28:10: style: Variable 'arr' is not assigned a value. [unassignedVariable]
 double  arr[5];
         ^
testsuite/Issue_490_repeated_extern_decls.c:9:13: style: Local variable 'a' shadows outer variable [shadowVariable]
 extern int a;
            ^
testsuite/Issue_490_repeated_extern_decls.c:1:12: note: Shadowed declaration
extern int a;
           ^
testsuite/Issue_490_repeated_extern_decls.c:9:13: note: Shadow variable
 extern int a;
            ^
testsuite/Issue_490_repeated_extern_decls.c:16:13: style: Local variable 'a' shadows outer variable [shadowVariable]
 extern int a;
            ^
testsuite/Issue_490_repeated_extern_decls.c:1:12: note: Shadowed declaration
extern int a;
           ^
testsuite/Issue_490_repeated_extern_decls.c:16:13: note: Shadow variable
 extern int a;
            ^
testsuite/Issue_491_enums.c:44:21: style: Variable 'editDataNoteStep' is reassigned a value before the old one has been used. [redundantAssignment]
   editDataNoteStep = editedNoteStep->notestep2;
                    ^
testsuite/Issue_491_enums.c:43:21: note: editDataNoteStep is assigned
   editDataNoteStep = &editedNoteStep->notestep;
                    ^
testsuite/Issue_491_enums.c:44:21: note: editDataNoteStep is overwritten
   editDataNoteStep = editedNoteStep->notestep2;
                    ^
testsuite/Issue_491_enums.c:44:21: style: Variable 'editDataNoteStep' is assigned a value that is never used. [unreadVariable]
   editDataNoteStep = editedNoteStep->notestep2;
                    ^
testsuite/Issue_493__func__.c:4:17: style: Variable 'callee' is assigned a value that is never used. [unreadVariable]
 char   *callee = ptr;
                ^
testsuite/Issue_493__func__.c:5:13: style: Variable 'me' is assigned a value that is never used. [unreadVariable]
 char   *me = __func__;
            ^
testsuite/Issue_497_astroforce_compile.c:13:33: error: Uninitialized variable: val [uninitvar]
 (*(updateintro3objectfunctions[val]))(0);
                                ^
testsuite/Issue_497_astroforce_compile.c:11:6: style: Variable 'val' is not assigned a value. [unassignedVariable]
 int val;
     ^
testsuite/Issue_501_extern_at.c:7:14: error: syntax error [syntaxError]
extern int d @(0x8000) = 22;
             ^
testsuite/Issue_509_long_constant.c:5:10: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
 long  l = 0;
         ^
testsuite/Issue_509_long_constant.c:7:4: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
 l &= 0xff123456UL;
   ^
testsuite/Issue_510_long_and.c:5:9: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
 long l = 0;
        ^
testsuite/Issue_510_long_and.c:6:4: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
 l &= 0xFFFFFF12;
   ^
testsuite/Issue_510_long_and.c:11:9: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
 long l = 0;
        ^
testsuite/Issue_510_long_and.c:12:4: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
 l &= 0xFFFF12FF;
   ^
testsuite/Issue_510_long_and.c:16:9: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
 long l = 0;
        ^
testsuite/Issue_510_long_and.c:17:4: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
 l &= 0xFF12FFFF;
   ^
testsuite/Issue_510_long_and.c:21:9: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
 long l = 0;
        ^
testsuite/Issue_510_long_and.c:22:4: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
 l &= 0x12FFFFFF;
   ^
testsuite/Issue_510_long_and.c:26:9: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
 long l = 0;
        ^
testsuite/Issue_510_long_and.c:27:4: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
 l &= 0x12345678;
   ^
testsuite/Issue_510_long_and.c:31:9: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
 long l = 0;
        ^
testsuite/Issue_510_long_and.c:32:4: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
 l &= 0xFFFFFF12;
   ^
testsuite/Issue_510_mult_minus1.c:5:8: style: Variable 'i' is assigned a value that is never used. [unreadVariable]
 int i = 1;
       ^
testsuite/Issue_510_mult_minus1.c:7:4: style: Variable 'i' is assigned a value that is never used. [unreadVariable]
 i *= -1;
   ^
testsuite/Issue_514_flexible_member.c:16:9: error: Null pointer dereference: ptr [nullPointer]
        ptr->arr[3] = 17;
        ^
testsuite/Issue_514_flexible_member.c:14:21: note: Assignment 'ptr=0', assigned value is 0
 struct flex *ptr = 0;
                    ^
testsuite/Issue_514_flexible_member.c:16:9: note: Null pointer dereference
        ptr->arr[3] = 17;
        ^
testsuite/Issue_514_flexible_member.c:25:9: error: Null pointer dereference: ptr [nullPointer]
        ptr->arr[3] = 17;
        ^
testsuite/Issue_514_flexible_member.c:23:22: note: Assignment 'ptr=0', assigned value is 0
 struct flex2 *ptr = 0;
                     ^
testsuite/Issue_514_flexible_member.c:25:9: note: Null pointer dereference
        ptr->arr[3] = 17;
        ^
testsuite/Issue_574_fastcall_offset.c:7:1: style: Label 'WaitForBOF' is not used. [unusedLabel]
WaitForBOF:
^
testsuite/Issue_574_fastcall_offset.c:8:5: style: Variable 'bc' is not assigned a value. [unassignedVariable]
 ld bc,0x243B
    ^
testsuite/Issue_615_if.c:28:14: style: Expression is always false because 'else if' condition matches previous condition at line 26. [multiCondition]
 } else if ( 1 ) {
             ^
testsuite/Issue_615_if.c:69:7: error: Uninitialized variable: a [uninitvar]
 if ( a )  {
      ^
testsuite/Issue_615_if.c:79:7: error: Uninitialized variable: a [uninitvar]
 if ( a )  {
      ^
testsuite/Issue_615_while_loop.c:21:10: error: Uninitialized variable: a [uninitvar]
 while ( a ) {
         ^
testsuite/Issue_678_compound.c:10:9: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
        ptr = ptr & 0xFFFF;
        ^
testsuite/Issue_678_compound.c:19:9: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
        ptr = ptr & 0xFFFF;
        ^
testsuite/Issue_678_compound.c:27:9: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
        ptr = ptr & 0xFFFF;
        ^
testsuite/Issue_678_compound.c:35:9: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
        ptr = ptr & 0xFFFF;
        ^
testsuite/Issue_678_compound.c:10:13: style: Variable 'ptr' is assigned a value that is never used. [unreadVariable]
        ptr = ptr & 0xFFFF;
            ^
testsuite/Issue_678_compound.c:19:13: style: Variable 'ptr' is assigned a value that is never used. [unreadVariable]
        ptr = ptr & 0xFFFF;
            ^
testsuite/Issue_678_compound.c:27:13: style: Variable 'ptr' is assigned a value that is never used. [unreadVariable]
        ptr = ptr & 0xFFFF;
            ^
testsuite/Issue_678_compound.c:35:13: style: Variable 'ptr' is assigned a value that is never used. [unreadVariable]
        ptr = ptr & 0xFFFF;
            ^
testsuite/Issue_701_compound_scope.c:6:19: style: Local variable 'i' shadows outer variable [shadowVariable]
        for ( int i = 0; i< 10; i++ ) {
                  ^
testsuite/Issue_701_compound_scope.c:5:17: note: Shadowed declaration
        int     i;
                ^
testsuite/Issue_701_compound_scope.c:6:19: note: Shadow variable
        for ( int i = 0; i< 10; i++ ) {
                  ^
testsuite/Issue_701_compound_scope.c:7:21: style: Local variable 'i' shadows outer variable [shadowVariable]
                int i;
                    ^
testsuite/Issue_701_compound_scope.c:5:17: note: Shadowed declaration
        int     i;
                ^
testsuite/Issue_701_compound_scope.c:7:21: note: Shadow variable
                int i;
                    ^
testsuite/Issue_701_compound_scope.c:11:21: style: Local variable 'i' shadows outer variable [shadowVariable]
                int i;
                    ^
testsuite/Issue_701_compound_scope.c:5:17: note: Shadowed declaration
        int     i;
                ^
testsuite/Issue_701_compound_scope.c:11:21: note: Shadow variable
                int i;
                    ^
testsuite/Issue_701_compound_scope.c:12:22: error: Uninitialized variable: i [uninitvar]
                func(i);
                     ^
testsuite/Issue_701_compound_scope.c:5:17: style: Unused variable: i [unusedVariable]
        int     i;
                ^
testsuite/Issue_701_compound_scope.c:7:21: style: Unused variable: i [unusedVariable]
                int i;
                    ^
testsuite/Issue_896_nested_struct_initialisation.c:12:18: style: struct member 'Anonymous0::driver' is never used. [unusedStructMember]
         uint8_t driver;
                 ^
testsuite/Issue_896_nested_struct_initialisation.c:13:18: style: struct member 'Anonymous0::function' is never used. [unusedStructMember]
         uint8_t function;
                 ^
testsuite/Issue_896_nested_struct_initialisation.c:31:18: style: struct member 'Anonymous1::driver' is never used. [unusedStructMember]
         uint8_t driver;
                 ^
testsuite/Issue_896_nested_struct_initialisation.c:32:18: style: struct member 'Anonymous1::function' is never used. [unusedStructMember]
         uint8_t function;
                 ^
testsuite/initialise_to_zero.c:3:7: style: struct member 'y::l' is never used. [unusedStructMember]
 long l;
      ^
testsuite/initialise_to_zero.c:7:9: style: struct member 'x::x' is never used. [unusedStructMember]
 double x;
        ^
testsuite/initialise_to_zero.c:8:6: style: struct member 'x::a' is never used. [unusedStructMember]
 int a;
     ^
testsuite/initialise_to_zero.c:20:19: style: Variable 'un2' is assigned a value that is never used. [unreadVariable]
 struct x un2[20] = {0};
                  ^
testsuite/l_gint_const.c:28:11: style: Variable 'a' is assigned a value that is never used. [unreadVariable]
    int a = vv->a + vv->b + vv->c + vv->d + vv->e + vv->f;
          ^
testsuite/l_gint_const.c:33:11: style: Variable 'a' is assigned a value that is never used. [unreadVariable]
    int a = vv->a + vv->b + vv->c + vv->d + vv->e + vv->f;
          ^
testsuite/long_addition_opts.c:4:5: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
    l += 1;
    ^
testsuite/long_addition_opts.c:9:5: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
    l += 2;
    ^
testsuite/long_addition_opts.c:14:5: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
    l += 3;
    ^
testsuite/long_addition_opts.c:19:5: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
    l += 4;
    ^
testsuite/long_addition_opts.c:24:5: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
    l += 10;
    ^
testsuite/long_addition_opts.c:29:5: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
    l += 65536;
    ^
testsuite/long_addition_opts.c:34:5: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
    l += 65536 * 2;
    ^
testsuite/long_addition_opts.c:38:5: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
    l += 65536 * 3;
    ^
testsuite/long_addition_opts.c:42:5: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
    l += 65536 * 4;
    ^
testsuite/long_addition_opts.c:46:5: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
    l += 65536 * 10;
    ^
testsuite/long_addition_opts.c:51:5: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
    l += 65537;
    ^
testsuite/long_addition_opts.c:57:5: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
    l -= 1;
    ^
testsuite/long_addition_opts.c:62:5: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
    l -= 2;
    ^
testsuite/long_addition_opts.c:67:5: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
    l -= 3;
    ^
testsuite/long_addition_opts.c:72:5: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
    l -= 4;
    ^
testsuite/long_addition_opts.c:77:5: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
    l -= 10;
    ^
testsuite/long_addition_opts.c:81:5: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
    l -= 65536;
    ^
testsuite/long_addition_opts.c:86:5: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
    l -= 65536 * 2;
    ^
testsuite/long_addition_opts.c:90:5: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
    l -= 65536 * 3;
    ^
testsuite/long_addition_opts.c:94:5: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
    l -= 65536 * 4;
    ^
testsuite/long_addition_opts.c:98:5: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
    l -= 65536 * 10;
    ^
testsuite/long_addition_opts.c:4:7: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
    l += 1;
      ^
testsuite/long_addition_opts.c:9:7: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
    l += 2;
      ^
testsuite/long_addition_opts.c:14:7: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
    l += 3;
      ^
testsuite/long_addition_opts.c:19:7: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
    l += 4;
      ^
testsuite/long_addition_opts.c:24:7: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
    l += 10;
      ^
testsuite/long_addition_opts.c:29:7: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
    l += 65536;
      ^
testsuite/long_addition_opts.c:34:7: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
    l += 65536 * 2;
      ^
testsuite/long_addition_opts.c:38:7: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
    l += 65536 * 3;
      ^
testsuite/long_addition_opts.c:42:7: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
    l += 65536 * 4;
      ^
testsuite/long_addition_opts.c:46:7: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
    l += 65536 * 10;
      ^
testsuite/long_addition_opts.c:51:7: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
    l += 65537;
      ^
testsuite/long_addition_opts.c:57:7: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
    l -= 1;
      ^
testsuite/long_addition_opts.c:62:7: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
    l -= 2;
      ^
testsuite/long_addition_opts.c:67:7: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
    l -= 3;
      ^
testsuite/long_addition_opts.c:72:7: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
    l -= 4;
      ^
testsuite/long_addition_opts.c:77:7: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
    l -= 10;
      ^
testsuite/long_addition_opts.c:81:7: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
    l -= 65536;
      ^
testsuite/long_addition_opts.c:86:7: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
    l -= 65536 * 2;
      ^
testsuite/long_addition_opts.c:90:7: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
    l -= 65536 * 3;
      ^
testsuite/long_addition_opts.c:94:7: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
    l -= 65536 * 4;
      ^
testsuite/long_addition_opts.c:98:7: style: Variable 'l' is assigned a value that is never used. [unreadVariable]
    l -= 65536 * 10;
      ^
testsuite/offsetof.c:28:6: style: Local variable 'offs_x' shadows outer variable [shadowVariable]
long offs_x = offsetof(struct x, tablen);
     ^
testsuite/offsetof.c:15:6: note: Shadowed declaration
long offs_x = offsetof(struct x, tablen);
     ^
testsuite/offsetof.c:28:6: note: Shadow variable
long offs_x = offsetof(struct x, tablen);
     ^
testsuite/offsetof.c:29:6: style: Local variable 'offs_x2' shadows outer variable [shadowVariable]
long offs_x2 = offsetof(x, tablen);
     ^
testsuite/offsetof.c:16:6: note: Shadowed declaration
long offs_x2 = offsetof(x, tablen);
     ^
testsuite/offsetof.c:29:6: note: Shadow variable
long offs_x2 = offsetof(x, tablen);
     ^
testsuite/offsetof.c:30:5: style: Local variable 'offs_xt' shadows outer variable [shadowVariable]
int offs_xt = offsetof(xt, tablen);
    ^
testsuite/offsetof.c:19:5: note: Shadowed declaration
int offs_xt = offsetof(xt, tablen);
    ^
testsuite/offsetof.c:30:5: note: Shadow variable
int offs_xt = offsetof(xt, tablen);
    ^
testsuite/offsetof.c:31:5: style: Local variable 'offs_data' shadows outer variable [shadowVariable]
int offs_data = offsetof(data, tablen);
    ^
testsuite/offsetof.c:21:5: note: Shadowed declaration
int offs_data = offsetof(data, tablen);
    ^
testsuite/offsetof.c:31:5: note: Shadow variable
int offs_data = offsetof(data, tablen);
    ^
testsuite/offsetof.c:6:9: style: struct member 'x::table1' is never used. [unusedStructMember]
   long table1[20];
        ^
testsuite/offsetof.c:28:13: style: Variable 'offs_x' is assigned a value that is never used. [unreadVariable]
long offs_x = offsetof(struct x, tablen);
            ^
testsuite/offsetof.c:29:14: style: Variable 'offs_x2' is assigned a value that is never used. [unreadVariable]
long offs_x2 = offsetof(x, tablen);
             ^
testsuite/offsetof.c:30:13: style: Variable 'offs_xt' is assigned a value that is never used. [unreadVariable]
int offs_xt = offsetof(xt, tablen);
            ^
testsuite/offsetof.c:31:15: style: Variable 'offs_data' is assigned a value that is never used. [unreadVariable]
int offs_data = offsetof(data, tablen);
              ^
testsuite/rabbit/rabbit_optimisations.c:23:7: style: Redundant initialization for 'x'. The initialized value is overwritten before it is read. [redundantInitialization]
    x = a | 0xff;
      ^
testsuite/rabbit/rabbit_optimisations.c:22:11: note: x is initialized
    int x = a | b;
          ^
testsuite/rabbit/rabbit_optimisations.c:23:7: note: x is overwritten
    x = a | 0xff;
      ^
testsuite/rabbit/rabbit_optimisations.c:31:7: style: Redundant initialization for 'x'. The initialized value is overwritten before it is read. [redundantInitialization]
    x = a & 0xff;
      ^
testsuite/rabbit/rabbit_optimisations.c:30:11: note: x is initialized
    int x = a & b;
          ^
testsuite/rabbit/rabbit_optimisations.c:31:7: note: x is overwritten
    x = a & 0xff;
      ^
testsuite/rabbit/rabbit_optimisations.c:48:7: style: Redundant initialization for 'r'. The initialized value is overwritten before it is read. [redundantInitialization]
    r = l << 2;
      ^
testsuite/rabbit/rabbit_optimisations.c:47:12: note: r is initialized
    long r = l << 1;
           ^
testsuite/rabbit/rabbit_optimisations.c:48:7: note: r is overwritten
    r = l << 2;
      ^
testsuite/rabbit/rabbit_optimisations.c:49:7: style: Variable 'r' is reassigned a value before the old one has been used. [redundantAssignment]
    r = l << 3;
      ^
testsuite/rabbit/rabbit_optimisations.c:48:7: note: r is assigned
    r = l << 2;
      ^
testsuite/rabbit/rabbit_optimisations.c:49:7: note: r is overwritten
    r = l << 3;
      ^
testsuite/rabbit/rabbit_optimisations.c:12:10: error: Uninitialized variable: a [uninitvar]
 return  a * b;
         ^
testsuite/rabbit/rabbit_optimisations.c:12:14: error: Uninitialized variable: b [uninitvar]
 return  a * b;
             ^
testsuite/rabbit/rabbit_optimisations.c:10:6: style: Variable 'a' is not assigned a value. [unassignedVariable]
 int a,b;
     ^
testsuite/rabbit/rabbit_optimisations.c:10:8: style: Variable 'b' is not assigned a value. [unassignedVariable]
 int a,b;
       ^
testsuite/rabbit/rabbit_optimisations.c:23:7: style: Variable 'x' is assigned a value that is never used. [unreadVariable]
    x = a | 0xff;
      ^
testsuite/rabbit/rabbit_optimisations.c:31:7: style: Variable 'x' is assigned a value that is never used. [unreadVariable]
    x = a & 0xff;
      ^
testsuite/rabbit/rabbit_optimisations.c:49:7: style: Variable 'r' is assigned a value that is never used. [unreadVariable]
    r = l << 3;
      ^
testsuite/sizeof_w_str_concat.c:3:11: style: Variable 'a' is assigned a value that is never used. [unreadVariable]
    int a = sizeof("partone" "parttwo");
          ^
testsuite/sizeof_w_str_concat.c:4:11: style: Variable 'b' is assigned a value that is never used. [unreadVariable]
    int b = sizeof("partone" "a");
          ^
testsuite/sizeof_w_str_concat.c:5:11: style: Variable 'c' is assigned a value that is never used. [unreadVariable]
    int c = sizeof("partone" "");
          ^
testsuite/z180/Issue_481_multiply_char.c:9:9: error: Uninitialized variable: d [uninitvar]
 return d* c;
        ^
testsuite/z180/Issue_481_multiply_char.c:9:12: error: Uninitialized variable: c [uninitvar]
 return d* c;
           ^
testsuite/z180/Issue_481_multiply_char.c:17:12: error: Uninitialized variable: d [uninitvar]
 return c* d;
           ^
testsuite/z180/Issue_481_multiply_char.c:17:9: error: Uninitialized variable: c [uninitvar]
 return c* d;
        ^
testsuite/z180/Issue_481_multiply_char.c:26:9: error: Uninitialized variable: d [uninitvar]
 return d *c;
        ^
testsuite/z180/Issue_481_multiply_char.c:26:12: error: Uninitialized variable: c [uninitvar]
 return d *c;
           ^
testsuite/z180/Issue_481_multiply_char.c:34:12: error: Uninitialized variable: d [uninitvar]
 return c *d;
           ^
testsuite/z180/Issue_481_multiply_char.c:34:9: error: Uninitialized variable: c [uninitvar]
 return c *d;
        ^
testsuite/z180/Issue_481_multiply_char.c:6:16: style: Variable 'd' is not assigned a value. [unassignedVariable]
 unsigned char d;
               ^
testsuite/z180/Issue_481_multiply_char.c:7:7: style: Variable 'c' is not assigned a value. [unassignedVariable]
 char c;
      ^
testsuite/z180/Issue_481_multiply_char.c:14:16: style: Variable 'd' is not assigned a value. [unassignedVariable]
 unsigned char d;
               ^
testsuite/z180/Issue_481_multiply_char.c:15:7: style: Variable 'c' is not assigned a value. [unassignedVariable]
 char c;
      ^
testsuite/z180/Issue_481_multiply_char.c:23:16: style: Variable 'd' is not assigned a value. [unassignedVariable]
 unsigned char d;
               ^
testsuite/z180/Issue_481_multiply_char.c:24:6: style: Variable 'c' is not assigned a value. [unassignedVariable]
 int c;
     ^
testsuite/z180/Issue_481_multiply_char.c:31:16: style: Variable 'd' is not assigned a value. [unassignedVariable]
 unsigned char d;
               ^
testsuite/z180/Issue_481_multiply_char.c:32:6: style: Variable 'c' is not assigned a value. [unassignedVariable]
 int c;
     ^
testsuite/z80n/Issue_312_z80n_optimisations.c:8:10: error: Uninitialized variable: a [uninitvar]
 return  a * b;
         ^
testsuite/z80n/Issue_312_z80n_optimisations.c:8:14: error: Uninitialized variable: b [uninitvar]
 return  a * b;
             ^
testsuite/z80n/Issue_312_z80n_optimisations.c:6:6: style: Variable 'a' is not assigned a value. [unassignedVariable]
 int a,b;
     ^
testsuite/z80n/Issue_312_z80n_optimisations.c:6:8: style: Variable 'b' is not assigned a value. [unassignedVariable]
 int a,b;
       ^
testsuite/z80n/Issue_312_z80n_optimisations.c:42:9: style: Variable 'x' is assigned a value that is never used. [unreadVariable]
 long x = l + - 20;
        ^
testsuite/z80n/Issue_312_z80n_optimisations.c:48:9: style: Variable 'x' is assigned a value that is never used. [unreadVariable]
 long x = l - 20;
        ^
src/appmake/abc80.c:123:18: warning: Null pointer dereference: fin [ctunullpointer]
    while (!feof(fin)) {
                 ^
src/appmake/abc80.c:294:44: note: Assuming that condition '(fpin=fopen(filename,"rb"))==NULL' is not redundant

                                           ^
src/appmake/abc80.c:335:21: note: Calling function datablockout, 1st argument is null
        datablockout(fpin, fpout);
                    ^
src/appmake/abc80.c:123:18: note: Dereferencing argument fin that is null
    while (!feof(fin)) {
                 ^
src/appmake/appmake.c:653:17: warning: Null pointer dereference: fp [ctunullpointer]
        fputc(c,fp);
                ^
src/appmake/m5.c:131:41: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant

                                        ^
src/appmake/m5.c:140:16: note: Calling function writestring, 2nd argument is null
    writestring("SORDM5", fpout);
               ^
src/appmake/appmake.c:673:9: note: Calling function writebyte, 2nd argument is null
        writebyte(mystring[c],fp);
        ^
src/appmake/appmake.c:653:17: note: Dereferencing argument fp that is null
        fputc(c,fp);
                ^
src/appmake/appmake.c:658:17: warning: Null pointer dereference: fp [ctunullpointer]
    fputc(i%256,fp);
                ^
src/appmake/cpc.c:650:45: note: Assuming that condition '(fpWav=fopen(filename,"wb"))==NULL' is not redundant

                                            ^
src/appmake/cpc.c:659:19: note: Calling function 'writesize', 1st argument 'fpWav' value is 0

                  ^
src/appmake/cpc.c:166:14: note: Calling function writelong, 2nd argument is null
    writelong(size, f);
             ^
src/appmake/appmake.c:679:5: note: Calling function writeword, 2nd argument is null
    writeword(i%65536,fp);
    ^
src/appmake/appmake.c:658:17: note: Dereferencing argument fp that is null
    fputc(i%256,fp);
                ^
src/appmake/appmake.c:733:13: warning: Null pointer dereference: fp [ctunullpointer]
    fputc(c,fp);
            ^
src/appmake/ace-tap.c:107:45: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant

                                            ^
src/appmake/ace-tap.c:153:20: note: Calling function writeword_p, 2nd argument is null
        writeword_p(26, fpout, &parity); /* Header len */
                   ^
src/appmake/appmake.c:716:5: note: Calling function writebyte_p, 2nd argument is null
    writebyte_p(i%256,fp,p);
    ^
src/appmake/appmake.c:733:13: note: Dereferencing argument fp that is null
    fputc(c,fp);
            ^
src/appmake/appmake.c:741:13: warning: Null pointer dereference: fp [ctunullpointer]
    fputc(c,fp);
            ^
src/appmake/sorcerer.c:252:45: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant

                                            ^
src/appmake/sorcerer.c:346:21: note: Calling function writebyte_pk, 2nd argument is null
        writebyte_pk(1, fpout, &parity); /* byte tail */
                    ^
src/appmake/appmake.c:741:13: note: Dereferencing argument fp that is null
    fputc(c,fp);
            ^
src/appmake/appmake.c:771:13: warning: Null pointer dereference: fp [ctunullpointer]
    fputc(c,fp);
            ^
src/appmake/galaksija.c:197:45: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant

                                            ^
src/appmake/galaksija.c:232:24: note: Calling function writeword_cksum, 2nd argument is null
        writeword_cksum(0x2c36, fpout, &checksum); /* ORG address              */
                       ^
src/appmake/appmake.c:778:5: note: Calling function writebyte_cksum, 2nd argument is null
    writebyte_cksum(i%256,fp,cksum);
    ^
src/appmake/appmake.c:771:13: note: Dereferencing argument fp that is null
    fputc(c,fp);
            ^
src/appmake/appmake.c:1169:41: warning: Null pointer dereference: fmap [ctunullpointer]
    while (fgets(buffer, MBBUFFERMAX-7, fmap) != NULL)
                                        ^
src/appmake/glue.c:99:39: note: Assuming that condition '(fmap=fopen(filename,"r"))==NULL' is not redundant

                                      ^
src/appmake/glue.c:102:23: note: Calling function mb_enumerate_banks, 1st argument is null
    mb_enumerate_banks(fmap, binname, &memory, &aligned);
                      ^
src/appmake/appmake.c:1169:41: note: Dereferencing argument fmap that is null
    while (fgets(buffer, MBBUFFERMAX-7, fmap) != NULL)
                                        ^
src/appmake/appmake.c:2027:11: warning: Null pointer dereference: fp [ctunullpointer]
    fseek(fp, 0, SEEK_END);
          ^
src/appmake/mgt.c:84:62: note: Assuming that condition '(fpin=fopen_bin(c_binary_name,c_crt_filename))==NULL' is not redundant

                                                             ^
src/appmake/mgt.c:95:24: note: Calling function get_file_size, 1st argument is null
    pos = get_file_size(fpin);
                       ^
src/appmake/appmake.c:2027:11: note: Dereferencing argument fp that is null
    fseek(fp, 0, SEEK_END);
          ^
src/appmake/cpc.c:151:30: warning: Null pointer dereference: f [ctunullpointer]
    fwrite(WavHeader, 1, 44, f);
                             ^
src/appmake/cpc.c:650:45: note: Assuming that condition '(fpWav=fopen(filename,"wb"))==NULL' is not redundant

                                            ^
src/appmake/cpc.c:655:21: note: Calling function putWavHeader, 1st argument is null
        putWavHeader(fpWav, &wavSize);
                    ^
src/appmake/cpc.c:151:30: note: Dereferencing argument f that is null
    fwrite(WavHeader, 1, 44, f);
                             ^
src/appmake/cpc.c:165:11: warning: Null pointer dereference: f [ctunullpointer]
    fseek(f, 40, SEEK_SET);
          ^
src/appmake/cpc.c:650:45: note: Assuming that condition '(fpWav=fopen(filename,"wb"))==NULL' is not redundant

                                            ^
src/appmake/cpc.c:659:18: note: Calling function writesize, 1st argument is null
        writesize(fpWav, wavSize);
                 ^
src/appmake/cpc.c:165:11: note: Dereferencing argument f that is null
    fseek(f, 40, SEEK_SET);
          ^
src/appmake/cpmdisk.c:87:5: warning: Null pointer dereference: h [ctunullpointer]
    h->write_file(h, filename, data, len);
    ^
src/appmake/cpc.c:770:55: note: Assuming that condition '(h=cpm_create_with_format("cpcsystem"))==NULL' is not redundant

                                                      ^
src/appmake/cpc.c:776:24: note: Calling function disc_write_file, 1st argument is null
        disc_write_file(h, cpm_filename, outFileBuff, file_len);
                       ^
src/appmake/cpmdisk.c:87:5: note: Dereferencing argument h that is null
    h->write_file(h, filename, data, len);
    ^
src/appmake/cpmdisk.c:186:10: warning: Null pointer dereference: h [ctunullpointer]
    free(h->image);
         ^
src/appmake/cpc.c:770:55: note: Assuming that condition '(h=cpm_create_with_format("cpcsystem"))==NULL' is not redundant

                                                      ^
src/appmake/cpc.c:823:18: note: Calling function disc_free, 1st argument is null
        disc_free(h);
                 ^
src/appmake/cpmdisk.c:186:10: note: Dereferencing argument h that is null
    free(h->image);
         ^
src/appmake/cpmdisk.c:282:24: warning: Null pointer dereference: h [ctunullpointer]
    int track_length = h->spec.sector_size * h->spec.sectors_per_track;
                       ^
src/appmake/cpc.c:770:55: note: Assuming that condition '(h=cpm_create_with_format("cpcsystem"))==NULL' is not redundant

                                                      ^
src/appmake/cpc.c:818:28: note: Calling function disc_write_edsk, 1st argument is null
        if (disc_write_edsk(h, disc_image_name) < 0)
                           ^
src/appmake/cpmdisk.c:282:24: note: Dereferencing argument h that is null
    int track_length = h->spec.sector_size * h->spec.sectors_per_track;
                       ^
src/appmake/dai.c:221:16: warning: Null pointer dereference: fp [ctunullpointer]
   fputc(byte, fp);
               ^
src/appmake/dai.c:126:43: note: Assuming that condition '(fpout=fopen(filename,"wb"))==NULL' is not redundant

                                          ^
src/appmake/dai.c:161:18: note: Calling function writebyte_dai, 2nd argument is null
    writebyte_dai(0x31, fpout,fpwav,&cksum);  // File type
                 ^
src/appmake/dai.c:221:16: note: Dereferencing argument fp that is null
   fputc(byte, fp);
               ^
src/appmake/tixx.c:69:15: warning: Null pointer dereference: fp [ctunullpointer]
    p = ftell(fp);
              ^
src/appmake/tixx.c:190:9: note: Assuming that condition '!fp' is not redundant

        ^
src/appmake/tixx.c:192:14: note: Calling function fsize, 1st argument is null
    n = fsize(fp);
             ^
src/appmake/tixx.c:69:15: note: Dereferencing argument fp that is null
    p = ftell(fp);
              ^
src/appmake/tixx.c:104:41: warning: Null pointer dereference: fp [ctunullpointer]
    fwrite(comment, strlen(comment), 1, fp);
                                        ^
src/appmake/tixx.c:199:9: note: Assuming that condition '!fp' is not redundant

        ^
src/appmake/tixx.c:215:17: note: Calling function writecomment, 1st argument is null
    writecomment(fp, comment);
                ^
src/appmake/tixx.c:104:41: note: Dereferencing argument fp that is null
    fwrite(comment, strlen(comment), 1, fp);
                                        ^
src/sccz80/declparse.c:270:12: warning: Null pointer dereference: type [ctunullpointer]
    return type->kind == KIND_PTR || type->kind == KIND_CPTR;
           ^
src/sccz80/declparse.c:960:24: note: Assuming that condition 'base_type==NULL' is not redundant

                       ^
src/sccz80/declparse.c:953:19: note: Calling function ispointer, 1st argument is null
    if ( ispointer(base_type) ) {
                  ^
src/sccz80/declparse.c:270:12: note: Dereferencing argument type that is null
    return type->kind == KIND_PTR || type->kind == KIND_CPTR;
           ^
src/z80asm/src/c/array.c:15:1: error: Null pointer dereference: other [ctunullpointer]
DEF_ARRAY(Byte);
^
src/z80asm/src/c/array.c:15:1: note: Calling function ByteArray_set_size, 2nd argument is null
DEF_ARRAY(Byte);
^
src/z80asm/src/c/array.c:15:1: note: Dereferencing argument other that is null
DEF_ARRAY(Byte);
^
src/z80asm/src/c/array.c:16:1: error: Null pointer dereference: other [ctunullpointer]
DEF_ARRAY(Word);
^
src/z80asm/src/c/array.c:16:1: note: Calling function WordArray_set_size, 2nd argument is null
DEF_ARRAY(Word);
^
src/z80asm/src/c/array.c:16:1: note: Dereferencing argument other that is null
DEF_ARRAY(Word);
^
src/z80asm/src/c/array.c:17:1: error: Null pointer dereference: other [ctunullpointer]
DEF_ARRAY(int);
^
src/z80asm/src/c/array.c:17:1: note: Calling function intArray_set_size, 2nd argument is null
DEF_ARRAY(int);
^
src/z80asm/src/c/array.c:17:1: note: Dereferencing argument other that is null
DEF_ARRAY(int);
^
src/z80asm/src/c/array.c:18:1: error: Null pointer dereference: other [ctunullpointer]
DEF_ARRAY(long);
^
src/z80asm/src/c/array.c:18:1: note: Calling function longArray_set_size, 2nd argument is null
DEF_ARRAY(long);
^
src/z80asm/src/c/array.c:18:1: note: Dereferencing argument other that is null
DEF_ARRAY(long);
^
src/z80asm/src/c/expr1.c:239:1: error: Null pointer dereference: other [ctunullpointer]
DEF_ARRAY(ExprOp);
^
src/z80asm/src/c/expr1.c:239:1: note: Calling function ExprOpArray_set_size, 2nd argument is null
DEF_ARRAY(ExprOp);
^
src/z80asm/src/c/expr1.c:239:1: note: Dereferencing argument other that is null
DEF_ARRAY(ExprOp);
^
support/bin2var/bin2var.c:55:13: warning: Null pointer dereference: fp [ctunullpointer]
  p = ftell(fp);
            ^
support/bin2var/bin2var.c:136:7: note: Assuming that condition '!fp' is not redundant

      ^
support/bin2var/bin2var.c:138:12: note: Calling function fsize, 1st argument is null
  n = fsize(fp);
           ^
support/bin2var/bin2var.c:55:13: note: Dereferencing argument fp that is null
  p = ftell(fp);
            ^
support/bin2var/bin2var.c:76:39: warning: Null pointer dereference: fp [ctunullpointer]
  fwrite(comment, strlen(comment), 1, fp);
                                      ^
support/bin2var/bin2var.c:145:7: note: Assuming that condition '!fp' is not redundant

      ^
support/bin2var/bin2var.c:159:15: note: Calling function writecomment, 1st argument is null
  writecomment(fp, comment);
              ^
support/bin2var/bin2var.c:76:39: note: Dereferencing argument fp that is null
  fwrite(comment, strlen(comment), 1, fp);
                                      ^
support/bin2var/bin2var2.c:56:13: warning: Null pointer dereference: fp [ctunullpointer]
  p = ftell(fp);
            ^
support/bin2var/bin2var2.c:161:7: note: Assuming that condition '!fp' is not redundant

      ^
support/bin2var/bin2var2.c:163:12: note: Calling function fsize, 1st argument is null
  n = fsize(fp);
           ^
support/bin2var/bin2var2.c:56:13: note: Dereferencing argument fp that is null
  p = ftell(fp);
            ^
support/bin2var/bin2var2.c:101:39: warning: Null pointer dereference: fp [ctunullpointer]
  fwrite(comment, strlen(comment), 1, fp);
                                      ^
support/bin2var/bin2var2.c:170:7: note: Assuming that condition '!fp' is not redundant

      ^
support/bin2var/bin2var2.c:184:15: note: Calling function writecomment, 1st argument is null
  writecomment(fp, comment);
              ^
support/bin2var/bin2var2.c:101:39: note: Dereferencing argument fp that is null
  fwrite(comment, strlen(comment), 1, fp);
                                      ^
support/ticalc/bin2var/bin2var.c:59:13: warning: Null pointer dereference: fp [ctunullpointer]
  p = ftell(fp);
            ^
support/ticalc/bin2var/bin2var.c:140:7: note: Assuming that condition '!fp' is not redundant

      ^
support/ticalc/bin2var/bin2var.c:142:12: note: Calling function fsize, 1st argument is null
  n = fsize(fp);
           ^
support/ticalc/bin2var/bin2var.c:59:13: note: Dereferencing argument fp that is null
  p = ftell(fp);
            ^
support/ticalc/bin2var/bin2var.c:80:39: warning: Null pointer dereference: fp [ctunullpointer]
  fwrite(comment, strlen(comment), 1, fp);
                                      ^
support/ticalc/bin2var/bin2var.c:149:7: note: Assuming that condition '!fp' is not redundant

      ^
support/ticalc/bin2var/bin2var.c:163:15: note: Calling function writecomment, 1st argument is null
  writecomment(fp, comment);
              ^
support/ticalc/bin2var/bin2var.c:80:39: note: Dereferencing argument fp that is null
  fwrite(comment, strlen(comment), 1, fp);
                                      ^
support/ticalc/bin2var/bin2var2.c:60:13: warning: Null pointer dereference: fp [ctunullpointer]
  p = ftell(fp);
            ^
support/ticalc/bin2var/bin2var2.c:165:7: note: Assuming that condition '!fp' is not redundant

      ^
support/ticalc/bin2var/bin2var2.c:167:12: note: Calling function fsize, 1st argument is null
  n = fsize(fp);
           ^
support/ticalc/bin2var/bin2var2.c:60:13: note: Dereferencing argument fp that is null
  p = ftell(fp);
            ^
support/ticalc/bin2var/bin2var2.c:105:39: warning: Null pointer dereference: fp [ctunullpointer]
  fwrite(comment, strlen(comment), 1, fp);
                                      ^
support/ticalc/bin2var/bin2var2.c:174:7: note: Assuming that condition '!fp' is not redundant

      ^
support/ticalc/bin2var/bin2var2.c:188:15: note: Calling function writecomment, 1st argument is null
  writecomment(fp, comment);
              ^
support/ticalc/bin2var/bin2var2.c:105:39: note: Dereferencing argument fp that is null
  fwrite(comment, strlen(comment), 1, fp);
                                      ^
src/ucpp/arith.c:1274:0: style: The function 'ARITH_TYPENAME_s_and' is never used. [unusedFunction]

^
src/ucpp/arith.c:1116:0: style: The function 'ARITH_TYPENAME_s_fromint' is never used. [unusedFunction]

^
src/ucpp/arith.c:1117:0: style: The function 'ARITH_TYPENAME_s_fromlong' is never used. [unusedFunction]

^
src/ucpp/arith.c:1259:0: style: The function 'ARITH_TYPENAME_s_geq' is never used. [unusedFunction]

^
src/ucpp/arith.c:1254:0: style: The function 'ARITH_TYPENAME_s_gt' is never used. [unusedFunction]

^
src/ucpp/arith.c:1147:0: style: The function 'ARITH_TYPENAME_s_lnot' is never used. [unusedFunction]

^
src/ucpp/arith.c:1181:0: style: The function 'ARITH_TYPENAME_s_lsh' is never used. [unusedFunction]

^
src/ucpp/arith.c:1148:0: style: The function 'ARITH_TYPENAME_s_lval' is never used. [unusedFunction]

^
src/ucpp/arith.c:1163:0: style: The function 'ARITH_TYPENAME_s_minus' is never used. [unusedFunction]

^
src/ucpp/arith.c:1137:0: style: The function 'ARITH_TYPENAME_s_neg' is never used. [unusedFunction]

^
src/ucpp/arith.c:1269:0: style: The function 'ARITH_TYPENAME_s_neq' is never used. [unusedFunction]

^
src/ucpp/arith.c:1146:0: style: The function 'ARITH_TYPENAME_s_not' is never used. [unusedFunction]

^
src/ucpp/arith.c:1284:0: style: The function 'ARITH_TYPENAME_s_or' is never used. [unusedFunction]

^
src/ucpp/arith.c:1359:0: style: The function 'ARITH_TYPENAME_s_pct' is never used. [unusedFunction]

^
src/ucpp/arith.c:1150:0: style: The function 'ARITH_TYPENAME_s_plus' is never used. [unusedFunction]

^
src/ucpp/arith.c:1209:0: style: The function 'ARITH_TYPENAME_s_rsh' is never used. [unusedFunction]

^
src/ucpp/arith.c:1311:0: style: The function 'ARITH_TYPENAME_s_star' is never used. [unusedFunction]

^
src/ucpp/arith.c:817:0: style: The function 'ARITH_TYPENAME_s_to_u' is never used. [unusedFunction]

^
src/ucpp/arith.c:1124:0: style: The function 'ARITH_TYPENAME_s_toint' is never used. [unusedFunction]

^
src/ucpp/arith.c:1130:0: style: The function 'ARITH_TYPENAME_s_tolong' is never used. [unusedFunction]

^
src/ucpp/arith.c:1279:0: style: The function 'ARITH_TYPENAME_s_xor' is never used. [unusedFunction]

^
src/ucpp/arith.c:1390:0: style: The function 'ARITH_TYPENAME_u_decconst' is never used. [unusedFunction]

^
src/ucpp/arith.c:967:0: style: The function 'ARITH_TYPENAME_u_geq' is never used. [unusedFunction]

^
src/ucpp/arith.c:962:0: style: The function 'ARITH_TYPENAME_u_gt' is never used. [unusedFunction]

^
src/ucpp/arith.c:1434:0: style: The function 'ARITH_TYPENAME_u_hexconst' is never used. [unusedFunction]

^
src/ucpp/arith.c:977:0: style: The function 'ARITH_TYPENAME_u_neq' is never used. [unusedFunction]

^
src/ucpp/arith.c:1369:0: style: The function 'ARITH_TYPENAME_u_octconst' is never used. [unusedFunction]

^
src/ucpp/arith.c:1093:0: style: The function 'ARITH_TYPENAME_u_pct' is never used. [unusedFunction]

^
src/ucpp/arith.c:1083:0: style: The function 'ARITH_TYPENAME_u_slash' is never used. [unusedFunction]

^
src/ucpp/arith.c:1108:0: style: The function 'ARITH_TYPENAME_u_to_s' is never used. [unusedFunction]

^
test/framework/test.c:29:0: style: The function 'Assert_real' is never used. [unusedFunction]

^
libsrc/target/msx/asmlib/BiosCall.c:3:0: style: The function 'BiosCall' is never used. [unusedFunction]

^
src/z80asm/src/c/array.c:15:0: style: The function 'ByteArray_pop' is never used. [unusedFunction]

^
src/z80asm/src/c/array.c:15:0: style: The function 'ByteArray_top' is never used. [unusedFunction]

^
libsrc/target/s1mp3/usb/usb_isr.c:127:0: style: The function 'D11GetIRQ' is never used. [unusedFunction]

^
libsrc/target/z88/z88/DeRegisterInt.c:13:0: style: The function 'DeRegisterInt' is never used. [unusedFunction]

^
libsrc/target/s1mp3/flash/flash_initialise.c:226:0: style: The function 'DetermineFlashType' is never used. [unusedFunction]

^
libsrc/target/s1mp3/flash/flash_initialise.c:112:0: style: The function 'DisableNANDFlash' is never used. [unusedFunction]

^
src/sccz80/main.c:959:0: style: The function 'DispVersion' is never used. [unusedFunction]

^
libsrc/target/msx/asmlib/DosCall.c:3:0: style: The function 'DosCall' is never used. [unusedFunction]

^
libsrc/target/s1mp3/usb/usb_isr.c:595:0: style: The function 'EP0SETUPInterrupt' is never used. [unusedFunction]

^
libsrc/target/s1mp3/flash/flash_initialise.c:143:0: style: The function 'EnableNANDFlashBank' is never used. [unusedFunction]

^
src/z80asm/src/c/expr1.c:363:0: style: The function 'Expr1List_insert_after' is never used. [unusedFunction]

^
src/z80asm/src/c/expr1.c:363:0: style: The function 'Expr1List_insert_before' is never used. [unusedFunction]

^
src/z80asm/src/c/expr1.c:363:0: style: The function 'Expr1List_prev' is never used. [unusedFunction]

^
src/z80asm/src/c/expr1.c:363:0: style: The function 'Expr1List_shift' is never used. [unusedFunction]

^
src/z80asm/src/c/expr1.c:239:0: style: The function 'ExprOpArray_pop' is never used. [unusedFunction]

^
src/z80asm/src/c/expr1.c:239:0: style: The function 'ExprOpArray_top' is never used. [unusedFunction]

^
libsrc/target/s1mp3/flash/flash_initialise.c:436:0: style: The function 'FLASH_Initialise' is never used. [unusedFunction]

^
libsrc/target/s1mp3/flash/flash_pageread.c:68:0: style: The function 'FLASH_PageRead' is never used. [unusedFunction]

^
libsrc/target/s1mp3/flash/flash_pageread.c:10:0: style: The function 'FlashWrite2Bytes' is never used. [unusedFunction]

^
src/z80asm/src/c/scan.c:365:0: style: The function 'GetSymExpect' is never used. [unusedFunction]

^
src/ucpp/nhash.c:408:0: style: The function 'HTT2_del' is never used. [unusedFunction]

^
src/ucpp/nhash.c:186:0: style: The function 'HTT2_get' is never used. [unusedFunction]

^
src/ucpp/nhash.c:110:0: style: The function 'HTT2_init' is never used. [unusedFunction]

^
src/ucpp/nhash.c:477:0: style: The function 'HTT2_kill' is never used. [unusedFunction]

^
src/ucpp/nhash.c:286:0: style: The function 'HTT2_put' is never used. [unusedFunction]

^
src/ucpp/nhash.c:460:0: style: The function 'HTT2_scan' is never used. [unusedFunction]

^
libsrc/target/s1mp3/isr/isr_initialise.c:185:0: style: The function 'ISR_Initialise' is never used. [unusedFunction]

^
libsrc/target/s1mp3/isr/isr_initialise.c:208:0: style: The function 'ISR_Install' is never used. [unusedFunction]

^
libsrc/target/s1mp3/isr/isr_initialise.c:226:0: style: The function 'ISR_Remove' is never used. [unusedFunction]

^
test/machine/main.c:57:0: style: The function 'InZ80' is never used. [unusedFunction]

^
support/debugger/debugtarget_test.c:89:0: style: The function 'JumpZ80' is never used. [unusedFunction]

^
libsrc/target/s1mp3/keyboard/keyboard_getkeystate.c:25:0: style: The function 'KEYBOARD_GetKeyState' is never used. [unusedFunction]

^
libsrc/target/s1mp3/keyboard/keyboard_isr.c:7:0: style: The function 'KEYBOARD_ISR' is never used. [unusedFunction]

^
libsrc/target/s1mp3/keyboard/keyboard_initialise.c:6:0: style: The function 'KEYBOARD_Initialise' is never used. [unusedFunction]

^
libsrc/target/s1mp3/lcd_s6b0724/lcdtarget_initialise.c:118:0: style: The function 'LCDTARGET_Delay' is never used. [unusedFunction]

^
libsrc/target/s1mp3/lcd/lcd_copypicture.c:11:0: style: The function 'LCD_CopyPicture' is never used. [unusedFunction]

^
src/z80asm/src/c/list.c:20:0: style: The function 'List_clone' is never used. [unusedFunction]

^
src/z80asm/src/c/list.c:203:0: style: The function 'List_empty' is never used. [unusedFunction]

^
src/z80asm/src/c/list.c:141:0: style: The function 'List_insert_after' is never used. [unusedFunction]

^
src/z80asm/src/c/list.c:154:0: style: The function 'List_insert_before' is never used. [unusedFunction]

^
src/z80asm/src/c/list.c:133:0: style: The function 'List_prev' is never used. [unusedFunction]

^
src/z80asm/src/c/list.c:106:0: style: The function 'List_shift' is never used. [unusedFunction]

^
support/debugger/debugtarget_test.c:100:0: style: The function 'LoopZ80' is never used. [unusedFunction]

^
src/z80asm/src/c/module1.c:40:0: style: The function 'Module1List_clone' is never used. [unusedFunction]

^
src/z80asm/src/c/module1.c:40:0: style: The function 'Module1List_empty' is never used. [unusedFunction]

^
src/z80asm/src/c/module1.c:40:0: style: The function 'Module1List_insert_after' is never used. [unusedFunction]

^
src/z80asm/src/c/module1.c:40:0: style: The function 'Module1List_insert_before' is never used. [unusedFunction]

^
src/z80asm/src/c/module1.c:40:0: style: The function 'Module1List_pop' is never used. [unusedFunction]

^
src/z80asm/src/c/module1.c:40:0: style: The function 'Module1List_prev' is never used. [unusedFunction]

^
src/z80asm/src/c/module1.c:40:0: style: The function 'Module1List_shift' is never used. [unusedFunction]

^
src/z80asm/src/c/zobjfile.c:297:0: style: The function 'OFile_clone' is never used. [unusedFunction]

^
src/z80asm/src/c/zobjfile.c:410:0: style: The function 'OFile_close' is never used. [unusedFunction]

^
test/machine/main.c:53:0: style: The function 'OutZ80' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/s8/psg.c:45:0: style: The function 'PSG_setFrequency' is never used. [unusedFunction]

^
src/z80asm/src/c/z80pass.c:216:0: style: The function 'Pass2info' is never used. [unusedFunction]

^
src/sccz80/codegen.c:495:0: style: The function 'PutFrame' is never used. [unusedFunction]

^
libsrc/target/s1mp3/rs232/rs232_anychar.c:7:0: style: The function 'RS232_Anychar' is never used. [unusedFunction]

^
libsrc/target/s1mp3/rs232/rs232_getchar.c:7:0: style: The function 'RS232_Getchar' is never used. [unusedFunction]

^
libsrc/target/s1mp3/rs232/rs232_initialise.c:14:0: style: The function 'RS232_Initialise' is never used. [unusedFunction]

^
libsrc/target/s1mp3/rs232/rs232_putstring.c:5:0: style: The function 'RS232_Putstring' is never used. [unusedFunction]

^
libsrc/target/s1mp3/rs232/rs232_putstring_null.c:5:0: style: The function 'RS232_Putstring_Null' is never used. [unusedFunction]

^
libsrc/target/s1mp3/rs232/rs232_isr.c:81:0: style: The function 'RS232_isr' is never used. [unusedFunction]

^
libsrc/target/s1mp3/rtc/rtc_getstatus.c:8:0: style: The function 'RTC_GetStatus' is never used. [unusedFunction]

^
libsrc/target/s1mp3/rtc/rtc_initialise.c:4:0: style: The function 'RTC_Initialise' is never used. [unusedFunction]

^
libsrc/target/s1mp3/flash/flash_initialise.c:180:0: style: The function 'ReadFlashID' is never used. [unusedFunction]

^
libsrc/target/s1mp3/flash/flash_initialise.c:25:0: style: The function 'ReadStatusNANDFlash' is never used. [unusedFunction]

^
libsrc/target/s1mp3/flash/flash_initialise.c:83:0: style: The function 'ResetNANDFlash' is never used. [unusedFunction]

^
src/ticks/sxmlc.c:1537:0: style: The function 'SAX_Callbacks_init' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/s8/screen.c:23:0: style: The function 'SCREEN_isSCurrent' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/s8/screen.c:45:0: style: The function 'SCREEN_updateVBlank' is never used. [unusedFunction]

^
src/z80asm/src/c/codearea.c:49:0: style: The function 'Section1Hash_clone' is never used. [unusedFunction]

^
src/z80asm/src/c/codearea.c:49:0: style: The function 'Section1Hash_empty' is never used. [unusedFunction]

^
src/z80asm/src/c/codearea.c:49:0: style: The function 'Section1Hash_exists' is never used. [unusedFunction]

^
src/z80asm/src/c/codearea.c:49:0: style: The function 'Section1Hash_extract' is never used. [unusedFunction]

^
src/z80asm/src/c/codearea.c:49:0: style: The function 'Section1Hash_remove' is never used. [unusedFunction]

^
src/z80asm/src/c/codearea.c:49:0: style: The function 'Section1Hash_sort' is never used. [unusedFunction]

^
src/z80asm/src/c/strhash.c:25:0: style: The function 'StrHash_clone' is never used. [unusedFunction]

^
src/z80asm/src/c/strhash.c:191:0: style: The function 'StrHash_remove' is never used. [unusedFunction]

^
src/z80asm/src/c/str.c:239:0: style: The function 'Str_getline' is never used. [unusedFunction]

^
src/z80asm/src/c/str.c:154:0: style: The function 'Str_set_char' is never used. [unusedFunction]

^
src/z80asm/src/c/symtab1.c:40:0: style: The function 'Symbol1Hash_empty' is never used. [unusedFunction]

^
src/z80asm/src/c/symtab1.c:40:0: style: The function 'Symbol1Hash_exists' is never used. [unusedFunction]

^
src/z80asm/src/c/symtab1.c:40:0: style: The function 'Symbol1Hash_sort' is never used. [unusedFunction]

^
src/z80asm/src/c/symtab1.c:47:0: style: The function 'SymbolHash_cat' is never used. [unusedFunction]

^
libsrc/target/s1mp3/usb/usb_isr.c:294:0: style: The function 'USBConnectISR' is never used. [unusedFunction]

^
libsrc/target/s1mp3/usb/usb_isr.c:236:0: style: The function 'USBResetISR' is never used. [unusedFunction]

^
libsrc/target/s1mp3/usb/usb_isr.c:335:0: style: The function 'USB_ISR' is never used. [unusedFunction]

^
libsrc/target/s1mp3/usb/usb_isr.c:311:0: style: The function 'USB_ISREP_ControlRead' is never used. [unusedFunction]

^
libsrc/target/s1mp3/usb/usb_initialise.c:5:0: style: The function 'USB_Initialise' is never used. [unusedFunction]

^
libsrc/target/msx/asmlib/UnapiBuildCodeBlock.c:16:0: style: The function 'UnapiBuildCodeBlock' is never used. [unusedFunction]

^
libsrc/target/msx/asmlib/UnapiCall.c:3:0: style: The function 'UnapiCall' is never used. [unusedFunction]

^
libsrc/target/msx/asmlib/UnapiGetCount.c:4:0: style: The function 'UnapiGetCount' is never used. [unusedFunction]

^
libsrc/target/msx/asmlib/UnapiParseCodeBlock.c:3:0: style: The function 'UnapiParseCodeBlock' is never used. [unusedFunction]

^
libsrc/target/msx/asmlib/UnapiRead.c:3:0: style: The function 'UnapiRead' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/s8/vdp.c:4:0: style: The function 'VDP_printText' is never used. [unusedFunction]

^
libsrc/target/s1mp3/watchdog/watchdog_disable.c:6:0: style: The function 'WATCHDOG_Disable' is never used. [unusedFunction]

^
src/z80asm/src/c/array.c:16:0: style: The function 'WordArray_clone' is never used. [unusedFunction]

^
src/z80asm/src/c/array.c:16:0: style: The function 'WordArray_new' is never used. [unusedFunction]

^
src/z80asm/src/c/array.c:16:0: style: The function 'WordArray_pop' is never used. [unusedFunction]

^
src/z80asm/src/c/array.c:16:0: style: The function 'WordArray_push' is never used. [unusedFunction]

^
src/z80asm/src/c/array.c:16:0: style: The function 'WordArray_top' is never used. [unusedFunction]

^
libsrc/target/s1mp3/flash/flash_pageread.c:42:0: style: The function 'WriteColumnRowAddress_5Bytes' is never used. [unusedFunction]

^
libsrc/gfx/x11/XCheckWindowEvent.c:12:0: style: The function 'XCheckWindowEvent' is never used. [unusedFunction]

^
libsrc/gfx/x11/XClearWindow.c:12:0: style: The function 'XClearWindow' is never used. [unusedFunction]

^
libsrc/gfx/x11/XDestroyWindow.c:11:0: style: The function 'XDestroyWindow' is never used. [unusedFunction]

^
libsrc/gfx/x11/XDrawLine.c:12:0: style: The function 'XDrawLine' is never used. [unusedFunction]

^
libsrc/gfx/x11/XDrawPoint.c:12:0: style: The function 'XDrawPoint' is never used. [unusedFunction]

^
libsrc/gfx/x11/XFlush.c:11:0: style: The function 'XFlush' is never used. [unusedFunction]

^
src/ticks/sxmlc.c:910:0: style: The function 'XMLDoc_add_node' is never used. [unusedFunction]

^
src/ticks/sxmlc.c:1799:0: style: The function 'XMLDoc_parse_file_DOM_text_as_nodes' is never used. [unusedFunction]

^
src/ticks/sxmlc.c:1124:0: style: The function 'XMLDoc_print_attr_sep' is never used. [unusedFunction]

^
src/ticks/sxmlc.c:924:0: style: The function 'XMLDoc_remove_node' is never used. [unusedFunction]

^
src/ticks/sxmlc.c:900:0: style: The function 'XMLDoc_set_root' is never used. [unusedFunction]

^
src/ticks/sxmlc.c:599:0: style: The function 'XMLNode_add_child' is never used. [unusedFunction]

^
src/ticks/sxmlc.c:787:0: style: The function 'XMLNode_equal' is never used. [unusedFunction]

^
src/ticks/sxmlsearch.c:598:0: style: The function 'XMLNode_get_XPath' is never used. [unusedFunction]

^
src/ticks/sxmlc.c:497:0: style: The function 'XMLNode_get_attribute_count' is never used. [unusedFunction]

^
src/ticks/sxmlc.c:704:0: style: The function 'XMLNode_get_child' is never used. [unusedFunction]

^
src/ticks/sxmlc.c:671:0: style: The function 'XMLNode_get_children_count' is never used. [unusedFunction]

^
src/ticks/sxmlc.c:684:0: style: The function 'XMLNode_get_index' is never used. [unusedFunction]

^
src/ticks/sxmlc.c:612:0: style: The function 'XMLNode_insert_child' is never used. [unusedFunction]

^
src/ticks/sxmlc.c:643:0: style: The function 'XMLNode_move_child' is never used. [unusedFunction]

^
src/ticks/sxmlc.c:267:0: style: The function 'XMLNode_new' is never used. [unusedFunction]

^
src/ticks/sxmlc.c:1119:0: style: The function 'XMLNode_print_attr_sep' is never used. [unusedFunction]

^
src/ticks/sxmlc.c:1062:0: style: The function 'XMLNode_print_header' is never used. [unusedFunction]

^
src/ticks/sxmlc.c:721:0: style: The function 'XMLNode_remove_child' is never used. [unusedFunction]

^
src/ticks/sxmlc.c:383:0: style: The function 'XMLNode_set_active' is never used. [unusedFunction]

^
src/ticks/sxmlc.c:424:0: style: The function 'XMLNode_set_attribute' is never used. [unusedFunction]

^
src/ticks/sxmlc.c:407:0: style: The function 'XMLNode_set_type' is never used. [unusedFunction]

^
src/ticks/sxmlsearch.c:241:0: style: The function 'XMLSearch_get_XPath_string' is never used. [unusedFunction]

^
src/ticks/sxmlsearch.c:180:0: style: The function 'XMLSearch_search_get_attribute_index' is never used. [unusedFunction]

^
src/ticks/sxmlsearch.c:195:0: style: The function 'XMLSearch_search_remove_attribute' is never used. [unusedFunction]

^
src/ticks/sxmlsearch.c:227:0: style: The function 'XMLSearch_search_set_children_search' is never used. [unusedFunction]

^
src/ticks/sxmlsearch.c:44:0: style: The function 'XMLSearch_set_regexpr_compare' is never used. [unusedFunction]

^
src/ticks/sxmlc.c:187:0: style: The function 'XML_get_nb_registered_user_tags' is never used. [unusedFunction]

^
src/ticks/sxmlc.c:192:0: style: The function 'XML_get_registered_user_tag' is never used. [unusedFunction]

^
src/ticks/sxmlc.c:128:0: style: The function 'XML_register_user_tag' is never used. [unusedFunction]

^
src/ticks/sxmlc.c:160:0: style: The function 'XML_unregister_user_tag' is never used. [unusedFunction]

^
libsrc/target/s1mp3/isr/isr_initialise.c:103:0: style: The function '_ISR_Handler' is never used. [unusedFunction]

^
libsrc/video/regis/regis_position.c:17:0: style: The function '__regis_move_rel' is never used. [unusedFunction]

^
libsrc/video/regis/__regis_unplot.c:6:0: style: The function '__regis_unplot' is never used. [unusedFunction]

^
libsrc/video/tek401x/__tek_plot.c:4:0: style: The function '__tek_plot' is never used. [unusedFunction]

^
test/suites/sccz80/bitfields.c:447:0: style: The function '__test2291335' is never used. [unusedFunction]

^
testsuite/Issue_480_asmfunc.c:33:0: style: The function '_im2_isr_8080_isr1' is never used. [unusedFunction]

^
testsuite/Issue_480_asmfunc.c:38:0: style: The function '_im2_isr_isr2' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/EXAMPLES/benchmarks/n-body/sdcc/verify/printf_large.c:434:0: style: The function '_print_format' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/math16/c/acosf16.c:4:0: style: The function 'acosf16' is never used. [unusedFunction]

^
testsuite/Issue_98_check_int.c:38:0: style: The function 'add2' is never used. [unusedFunction]

^
src/ticks/syms.c:488:0: style: The function 'add_data_section' is never used. [unusedFunction]

^
libsrc/target/trs80/fcntl/addext.c:24:0: style: The function 'addext' is never used. [unusedFunction]

^
testsuite/rabbit/rabbit_optimisations.c:53:0: style: The function 'addition' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/am9511/c/am9511_acosh.c:7:0: style: The function 'am9511_acosh' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/am9511/c/am9511_asinh.c:7:0: style: The function 'am9511_asinh' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/am9511/c/am9511_atan2.c:4:0: style: The function 'am9511_atan2' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/am9511/c/am9511_atanh.c:7:0: style: The function 'am9511_atanh' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/am9511/c/am9511_cosh.c:4:0: style: The function 'am9511_cosh' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/am9511/c/am9511_exp10.c:20:0: style: The function 'am9511_exp10' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/am9511/c/am9511_exp2.c:20:0: style: The function 'am9511_exp2' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/am9511/c/am9511_fmax.c:21:0: style: The function 'am9511_fmax' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/am9511/c/am9511_fmin.c:21:0: style: The function 'am9511_fmin' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/am9511/c/am9511_fmod.c:11:0: style: The function 'am9511_fmod' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/am9511/c/am9511_log2.c:19:0: style: The function 'am9511_log2' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/am9511/c/am9511_modf.c:33:0: style: The function 'am9511_modf' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/am9511/c/am9511_round.c:15:0: style: The function 'am9511_round' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/am9511/c/am9511_sinh.c:4:0: style: The function 'am9511_sinhf' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/am9511/c/am9511_tanh.c:4:0: style: The function 'am9511_tanh' is never used. [unusedFunction]

^
testsuite/rabbit/rabbit_optimisations.c:28:0: style: The function 'and' is never used. [unusedFunction]

^
src/z80asm/src/c/codearea.c:482:0: style: The function 'append_2bytes' is never used. [unusedFunction]

^
src/z80asm/src/c/codearea.c:478:0: style: The function 'append_long' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/math16/c/asinf16.c:4:0: style: The function 'asinf16' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/math16/c/powf16.c:36:0: style: The function 'asm_f16_pow' is never used. [unusedFunction]

^
testsuite/mathops_ieee.c:6:0: style: The function 'assign2' is never used. [unusedFunction]

^
testsuite/mathops_ieee.c:7:0: style: The function 'assign_via_pointer' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/math16/c/atan2f16.c:4:0: style: The function 'atan2f16' is never used. [unusedFunction]

^
libsrc/math/math48/atof_impl.c:15:0: style: The function 'atof_impl' is never used. [unusedFunction]

^
libsrc/target/c128/c128/attrsonvdc.c:15:0: style: The function 'attrsonvdc' is never used. [unusedFunction]

^
examples/g800/turtle.c:19:0: style: The function 'backword' is never used. [unusedFunction]

^
libsrc/target/cpm/fcntl/bdosh.c:10:0: style: The function 'bdosh' is never used. [unusedFunction]

^
libsrc/target/cpm/fcntl/bdosh_callee.c:10:0: style: The function 'bdosh_callee' is never used. [unusedFunction]

^
src/sccz80/io.c:303:0: style: The function 'bell' is never used. [unusedFunction]

^
libsrc/games/bit_frequency.c:27:0: style: The function 'bit_frequency' is never used. [unusedFunction]

^
libsrc/games/bit_load_msx.c:14:0: style: The function 'bit_load_msx' is never used. [unusedFunction]

^
libsrc/games/bit_load_vg5000.c:15:0: style: The function 'bit_load_vg5000' is never used. [unusedFunction]

^
libsrc/games/bit_save_zx.c:21:0: style: The function 'bit_save_zx' is never used. [unusedFunction]

^
libsrc/gfx/portable/boxdraw.c:5:0: style: The function 'boxdraw' is never used. [unusedFunction]

^
testsuite/castup_to_long.c:16:0: style: The function 'branch' is never used. [unusedFunction]

^
src/ticks/debugger.c:1369:0: style: The function 'breakpoint_deleted' is never used. [unusedFunction]

^
libsrc/target/z88/fcntl/brotherdor.c:16:0: style: The function 'brotherdor' is never used. [unusedFunction]

^
libsrc/target/c128/c128/buftomemvdc.c:16:0: style: The function 'buftomemvdc' is never used. [unusedFunction]

^
testsuite/Issue_2234_ternary.c:49:0: style: The function 'call_const_false' is never used. [unusedFunction]

^
testsuite/Issue_2234_ternary.c:43:0: style: The function 'call_const_true' is never used. [unusedFunction]

^
testsuite/Issue_600_fastcall.c:21:0: style: The function 'callfunc1' is never used. [unusedFunction]

^
testsuite/Issue_600_fastcall.c:25:0: style: The function 'callfunc2' is never used. [unusedFunction]

^
testsuite/Issue_600_fastcall.c:29:0: style: The function 'callfunc3' is never used. [unusedFunction]

^
testsuite/Issue_600_fastcall.c:32:0: style: The function 'callfunc4' is never used. [unusedFunction]

^
testsuite/Issue_1167_choosing_which_function.c:7:0: style: The function 'callit' is never used. [unusedFunction]

^
libsrc/target/cpm/fcntl/change_volume.c:12:0: style: The function 'change_volume' is never used. [unusedFunction]

^
libsrc/target/zx-common/fcntl/esxdos/chdir.c:4:0: style: The function 'chdir' is never used. [unusedFunction]

^
testsuite/l_gint_const.c:21:0: style: The function 'check1' is never used. [unusedFunction]

^
testsuite/l_gint_const.c:26:0: style: The function 'check_gchar' is never used. [unusedFunction]

^
testsuite/l_gint_const.c:31:0: style: The function 'check_gint' is never used. [unusedFunction]

^
libsrc/gfx/portable/circledraw.c:4:0: style: The function 'circledraw' is never used. [unusedFunction]

^
libsrc/target/c128/c128/circleivdc.c:17:0: style: The function 'circleivdc' is never used. [unusedFunction]

^
test/suites/md5/md5sum.c:359:0: style: The function 'cleanup_fin' is never used. [unusedFunction]

^
libsrc/target/c128/c128/clrattrvdc.c:17:0: style: The function 'clrattrvdc' is never used. [unusedFunction]

^
libsrc/target/c128/c128/clrscrvdc.c:17:0: style: The function 'clrscrvdc' is never used. [unusedFunction]

^
src/ucpp/hash.c:324:0: style: The function 'cmp_struct' is never used. [unusedFunction]

^
testsuite/Issue_1361_const.c:5:0: style: The function 'constructItems' is never used. [unusedFunction]

^
libsrc/math/cimpl/fromfix16.c:32:0: style: The function 'convert' is never used. [unusedFunction]

^
libsrc/math/cimpl/tofix16.c:49:0: style: The function 'convertu' is never used. [unusedFunction]

^
src/zcc/zcc.c:1896:0: style: The function 'copy_defc_file' is never used. [unusedFunction]

^
libsrc/target/c128/c128/copydspvdc.c:16:0: style: The function 'copydspvdc' is never used. [unusedFunction]

^
testsuite/mathops_ieee.c:32:0: style: The function 'cschar' is never used. [unusedFunction]

^
testsuite/mathops_ieee.c:34:0: style: The function 'csint' is never used. [unusedFunction]

^
testsuite/mathops_ieee.c:36:0: style: The function 'cslong' is never used. [unusedFunction]

^
testsuite/mathops_ieee.c:33:0: style: The function 'cuchar' is never used. [unusedFunction]

^
testsuite/mathops_ieee.c:35:0: style: The function 'cuint' is never used. [unusedFunction]

^
testsuite/mathops_ieee.c:37:0: style: The function 'culong' is never used. [unusedFunction]

^
src/z80asm/src/c/dbg.c:55:0: style: The function 'dbg_peek_int' is never used. [unusedFunction]

^
src/z80asm/src/c/dbg.c:56:0: style: The function 'dbg_peek_ptr' is never used. [unusedFunction]

^
src/ticks/debug.c:826:0: style: The function 'debug_resolve_source_forward' is never used. [unusedFunction]

^
libsrc/target/c128/c128/decodefileintpcx.c:22:0: style: The function 'decodefileintpcx' is never used. [unusedFunction]

^
libsrc/target/c128/c128/decodefilepcx.c:22:0: style: The function 'decodefilepcx' is never used. [unusedFunction]

^
src/z80asm/src/c/symtab1.c:155:0: style: The function 'define_static_def_sym' is never used. [unusedFunction]

^
src/ucpp/hash.c:200:0: style: The function 'delHT' is never used. [unusedFunction]

^
libsrc/target/z88/fcntl/deletedor.c:14:0: style: The function 'deletedor' is never used. [unusedFunction]

^
testsuite/Issue_98_check_int.c:21:0: style: The function 'div' is never used. [unusedFunction]

^
testsuite/Issue_98_check_int.c:29:0: style: The function 'div3' is never used. [unusedFunction]

^
support/sprites/sprite.c:1122:0: style: The function 'do_import_raw' is never used. [unusedFunction]

^
libsrc/target/c128/c128/donepcx.c:16:0: style: The function 'donepcx' is never used. [unusedFunction]

^
libsrc/lib3d/dot_v.c:56:0: style: The function 'dot_v' is never used. [unusedFunction]

^
testsuite/Issue_103_double_prepost.c:30:0: style: The function 'double_post_decrement' is never used. [unusedFunction]

^
testsuite/Issue_103_double_prepost.c:36:0: style: The function 'double_post_decrement_assign' is never used. [unusedFunction]

^
testsuite/Issue_103_double_prepost.c:1:0: style: The function 'double_post_increment' is never used. [unusedFunction]

^
testsuite/Issue_103_double_prepost.c:7:0: style: The function 'double_post_increment_assign' is never used. [unusedFunction]

^
testsuite/Issue_103_double_prepost.c:44:0: style: The function 'double_pre_decrement' is never used. [unusedFunction]

^
testsuite/Issue_103_double_prepost.c:51:0: style: The function 'double_pre_decrement_assign' is never used. [unusedFunction]

^
testsuite/Issue_103_double_prepost.c:15:0: style: The function 'double_pre_increment' is never used. [unusedFunction]

^
testsuite/Issue_103_double_prepost.c:22:0: style: The function 'double_pre_increment_assign' is never used. [unusedFunction]

^
libsrc/lib3d/ellipse.c:18:0: style: The function 'ellipse' is never used. [unusedFunction]

^
libsrc/target/c128/c128/ellipseivdc.c:17:0: style: The function 'ellipseivdc' is never used. [unusedFunction]

^
libsrc/target/c128/c128/ellipsevdc.c:16:0: style: The function 'ellipsevdc' is never used. [unusedFunction]

^
examples/sms/3dcity/engine/hack_manager.c:24:0: style: The function 'engine_hack_manager_resetX' is never used. [unusedFunction]

^
examples/sms/3dcity/tile/bottom_tile.c:105:0: style: The function 'engine_tile_bottom3_load_tiles' is never used. [unusedFunction]

^
testsuite/mathops_ieee.c:21:0: style: The function 'eq' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:50:0: style: The function 'eq_double' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:14:0: style: The function 'eq_double_c' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:30:0: style: The function 'eq_double_cr' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:66:0: style: The function 'eq_double_r' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:54:0: style: The function 'eq_float16' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:18:0: style: The function 'eq_float16_c' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:34:0: style: The function 'eq_float16_cr' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:70:0: style: The function 'eq_float16_r' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:42:0: style: The function 'eq_int' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:6:0: style: The function 'eq_int_c' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:22:0: style: The function 'eq_int_cr' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:58:0: style: The function 'eq_int_r' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:46:0: style: The function 'eq_long' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:10:0: style: The function 'eq_long_c' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:26:0: style: The function 'eq_long_cr' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:62:0: style: The function 'eq_long_r' is never used. [unusedFunction]

^
libsrc/target/z88/z88/exec_cli.c:15:0: style: The function 'exec_cli' is never used. [unusedFunction]

^
libsrc/target/cpm/fcntl/execv.c:20:0: style: The function 'execv' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/math16/c/exp10f16.c:68:0: style: The function 'exp10f16' is never used. [unusedFunction]

^
src/z80asm/src/cpp/utils.cpp:283:0: style: The function 'expand_glob' is never used. [unusedFunction]

^
src/appmake/ff.c:4479:0: style: The function 'f_closedir' is never used. [unusedFunction]

^
src/appmake/ff.c:4632:0: style: The function 'f_getfree' is never used. [unusedFunction]

^
src/appmake/ff.c:4252:0: style: The function 'f_lseek' is never used. [unusedFunction]

^
src/appmake/ff.c:4865:0: style: The function 'f_mkdir' is never used. [unusedFunction]

^
src/appmake/ff.c:4413:0: style: The function 'f_opendir' is never used. [unusedFunction]

^
src/appmake/ff.c:3735:0: style: The function 'f_read' is never used. [unusedFunction]

^
src/appmake/ff.c:4509:0: style: The function 'f_readdir' is never used. [unusedFunction]

^
src/appmake/ff.c:4949:0: style: The function 'f_rename' is never used. [unusedFunction]

^
src/appmake/ff.c:4597:0: style: The function 'f_stat' is never used. [unusedFunction]

^
src/appmake/ff.c:4721:0: style: The function 'f_truncate' is never used. [unusedFunction]

^
src/appmake/ff.c:4771:0: style: The function 'f_unlink' is never used. [unusedFunction]

^
testsuite/Issue_26_casting.c:3:0: style: The function 'far_pointer_cast' is never used. [unusedFunction]

^
testsuite/Issue_26_casting.c:11:0: style: The function 'far_pointer_cast2' is never used. [unusedFunction]

^
testsuite/Issue_26_casting.c:19:0: style: The function 'far_pointer_cast3' is never used. [unusedFunction]

^
libsrc/stdio/zsock/fgetc_net.c:14:0: style: The function 'fgetc_net' is never used. [unusedFunction]

^
libsrc/stdio/fgetpos.c:22:0: style: The function 'fgetpos' is never used. [unusedFunction]

^
libsrc/target/tvc/romgfx/fillb.c:29:0: style: The function 'fillb' is never used. [unusedFunction]

^
libsrc/target/srr/srr/fillcur.c:17:0: style: The function 'fillcur' is never used. [unusedFunction]

^
libsrc/target/srr/srr/fillplot.c:12:0: style: The function 'fillplot' is never used. [unusedFunction]

^
src/ticks/syms.c:238:0: style: The function 'find_symbol_byname' is never used. [unusedFunction]

^
libsrc/math/fix16/cimpl/fix16_acos.c:13:0: style: The function 'fix16_acos' is never used. [unusedFunction]

^
libsrc/math/fix16/cimpl/fix16_acosh.c:9:0: style: The function 'fix16_acosh' is never used. [unusedFunction]

^
libsrc/math/fix16/cimpl/fix16_asin.c:14:0: style: The function 'fix16_asin' is never used. [unusedFunction]

^
libsrc/math/fix16/cimpl/fix16_asinh.c:9:0: style: The function 'fix16_asinh' is never used. [unusedFunction]

^
libsrc/math/fix16/cimpl/fix16_cosh.c:8:0: style: The function 'fix16_cosh' is never used. [unusedFunction]

^
libsrc/math/fix16/cimpl/fix16_exp.c:5:0: style: The function 'fix16_exp' is never used. [unusedFunction]

^
libsrc/math/fix16/cimpl/fix16_pow.c:4:0: style: The function 'fix16_pow' is never used. [unusedFunction]

^
libsrc/math/fix16/cimpl/fix16_sinh.c:8:0: style: The function 'fix16_sinh' is never used. [unusedFunction]

^
libsrc/math/fix16/cimpl/fix16_tanh.c:8:0: style: The function 'fix16_tanh' is never used. [unusedFunction]

^
testsuite/Issue_482_optrule.c:10:0: style: The function 'foo2' is never used. [unusedFunction]

^
libsrc/stdio/zsock/fopen_zsock.c:19:0: style: The function 'fopen_zsock' is never used. [unusedFunction]

^
src/ucpp/hash.c:163:0: style: The function 'forceputHT' is never used. [unusedFunction]

^
libsrc/stdio/zsock/fputc_net.c:14:0: style: The function 'fputc_net' is never used. [unusedFunction]

^
libsrc/stdio/_freopen1.c:70:0: style: The function 'freopen1_cleanup_exit' is never used. [unusedFunction]

^
libsrc/math/cimpl/ftoa.c:13:0: style: The function 'ftoa' is never used. [unusedFunction]

^
libsrc/math/cimpl/ftoa_fudgeit.c:20:0: style: The function 'ftoa_fudgeit' is never used. [unusedFunction]

^
libsrc/math/math48/ftoa_impl.c:23:0: style: The function 'ftoa_impl' is never used. [unusedFunction]

^
libsrc/math/cimpl/ftoe.c:15:0: style: The function 'ftoe' is never used. [unusedFunction]

^
libsrc/math/math48/ftoe_impl.c:16:0: style: The function 'ftoe_impl' is never used. [unusedFunction]

^
testsuite/Issue_1623_stdcbench_issues.c:15:0: style: The function 'func0b' is never used. [unusedFunction]

^
testsuite/Issue_1133_bitfields.c:20:0: style: The function 'func1a' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16.c:15:0: style: The function 'func1a_OpenConstants' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16.c:12:0: style: The function 'func1a_TypedConstants' is never used. [unusedFunction]

^
testsuite/Issue_1133_bitfields.c:21:0: style: The function 'func1b' is never used. [unusedFunction]

^
testsuite/Issue_1133_bitfields.c:22:0: style: The function 'func1c' is never used. [unusedFunction]

^
testsuite/Issue_1167_sizeof.c:28:0: style: The function 'func1d' is never used. [unusedFunction]

^
testsuite/pointer_arith.c:16:0: style: The function 'func1e' is never used. [unusedFunction]

^
testsuite/Issue_608_Arrays.c:21:0: style: The function 'func2_b' is never used. [unusedFunction]

^
testsuite/Issue_1133_bitfields.c:32:0: style: The function 'func2a' is never used. [unusedFunction]

^
testsuite/Issue_1133_bitfields.c:33:0: style: The function 'func2b' is never used. [unusedFunction]

^
testsuite/Issue_1167_sizeof.c:41:0: style: The function 'func2c' is never used. [unusedFunction]

^
testsuite/Issue_1167_sizeof.c:44:0: style: The function 'func2d' is never used. [unusedFunction]

^
testsuite/pointer_arith.c:32:0: style: The function 'func2e' is never used. [unusedFunction]

^
testsuite/interrupt.c:8:0: style: The function 'func2im2' is never used. [unusedFunction]

^
testsuite/Issue_1133_bitfields.c:44:0: style: The function 'func3a' is never used. [unusedFunction]

^
testsuite/Issue_1133_bitfields.c:45:0: style: The function 'func3b' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16.c:31:0: style: The function 'func3c' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16.c:34:0: style: The function 'func3d' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16.c:38:0: style: The function 'func3e' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16.c:42:0: style: The function 'func3f' is never used. [unusedFunction]

^
testsuite/Issue_1133_bitfields.c:58:0: style: The function 'func4a' is never used. [unusedFunction]

^
testsuite/Issue_1133_bitfields.c:59:0: style: The function 'func4b' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16.c:45:0: style: The function 'func4c' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16.c:48:0: style: The function 'func4d' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16.c:51:0: style: The function 'func4e' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16.c:56:0: style: The function 'func5a' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16.c:60:0: style: The function 'func5b' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16.c:64:0: style: The function 'func5c' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16.c:68:0: style: The function 'func5d' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16.c:72:0: style: The function 'func5e' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16.c:76:0: style: The function 'func5f' is never used. [unusedFunction]

^
testsuite/Issue_452_far_pointers.c:38:0: style: The function 'func6' is never used. [unusedFunction]

^
testsuite/long_addition_opts.c:27:0: style: The function 'func65536' is never used. [unusedFunction]

^
testsuite/long_addition_opts.c:32:0: style: The function 'func65536_2' is never used. [unusedFunction]

^
testsuite/long_addition_opts.c:36:0: style: The function 'func65536_3' is never used. [unusedFunction]

^
testsuite/long_addition_opts.c:40:0: style: The function 'func65536_4' is never used. [unusedFunction]

^
testsuite/long_addition_opts.c:44:0: style: The function 'func65536_x' is never used. [unusedFunction]

^
testsuite/long_addition_opts.c:49:0: style: The function 'func65537' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16.c:81:0: style: The function 'func6a' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16.c:85:0: style: The function 'func6b' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16.c:89:0: style: The function 'func6c' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16.c:93:0: style: The function 'func6d' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16.c:97:0: style: The function 'func6e' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16.c:101:0: style: The function 'func6f' is never used. [unusedFunction]

^
testsuite/Issue_452_far_pointers.c:50:0: style: The function 'func7' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16.c:106:0: style: The function 'func7a' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16.c:110:0: style: The function 'func7b' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16.c:114:0: style: The function 'func7c' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16.c:118:0: style: The function 'func7d' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16.c:122:0: style: The function 'func8a' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16.c:126:0: style: The function 'func8b' is never used. [unusedFunction]

^
examples/banked/bank4.c:8:0: style: The function 'func_bank4' is never used. [unusedFunction]

^
testsuite/Issue_1132_struct_parameter.c:25:0: style: The function 'func_calling' is never used. [unusedFunction]

^
testsuite/Issue_452_unsigned.c:3:0: style: The function 'func_char' is never used. [unusedFunction]

^
testsuite/Issue_452_unsigned.c:11:0: style: The function 'func_char2' is never used. [unusedFunction]

^
testsuite/Issue_490_ptr_arithmetic.c:25:0: style: The function 'func_double' is never used. [unusedFunction]

^
testsuite/Issue_490_ptr_arithmetic.c:32:0: style: The function 'func_double_static' is never used. [unusedFunction]

^
testsuite/Issue_1132_struct_parameter.c:33:0: style: The function 'func_fptr' is never used. [unusedFunction]

^
testsuite/Issue_1132_struct_by_value.c:13:0: style: The function 'func_global_assign' is never used. [unusedFunction]

^
testsuite/Issue_1132_struct_by_value.c:23:0: style: The function 'func_global_assign_from_pointer' is never used. [unusedFunction]

^
testsuite/Issue_1132_struct_by_value.c:18:0: style: The function 'func_global_assign_to_pointer' is never used. [unusedFunction]

^
testsuite/Issue_452_unsigned.c:20:0: style: The function 'func_int' is never used. [unusedFunction]

^
testsuite/Issue_452_unsigned.c:28:0: style: The function 'func_int2' is never used. [unusedFunction]

^
testsuite/Issue_1132_struct_by_value.c:28:0: style: The function 'func_local_assign' is never used. [unusedFunction]

^
testsuite/Issue_1132_struct_by_value.c:45:0: style: The function 'func_local_assign_from_pointer' is never used. [unusedFunction]

^
testsuite/Issue_1132_struct_by_value.c:36:0: style: The function 'func_local_assign_to_pointer' is never used. [unusedFunction]

^
testsuite/Issue_490_ptr_arithmetic.c:18:0: style: The function 'func_long' is never used. [unusedFunction]

^
testsuite/mathops_ieee.c:8:0: style: The function 'funccall' is never used. [unusedFunction]

^
testsuite/long_addition_opts.c:55:0: style: The function 'funcm1' is never used. [unusedFunction]

^
testsuite/long_addition_opts.c:60:0: style: The function 'funcm2' is never used. [unusedFunction]

^
testsuite/long_addition_opts.c:65:0: style: The function 'funcm3' is never used. [unusedFunction]

^
testsuite/long_addition_opts.c:70:0: style: The function 'funcm4' is never used. [unusedFunction]

^
testsuite/long_addition_opts.c:79:0: style: The function 'funcm65536' is never used. [unusedFunction]

^
testsuite/long_addition_opts.c:84:0: style: The function 'funcm65536_2' is never used. [unusedFunction]

^
testsuite/long_addition_opts.c:88:0: style: The function 'funcm65536_3' is never used. [unusedFunction]

^
testsuite/long_addition_opts.c:92:0: style: The function 'funcm65536_4' is never used. [unusedFunction]

^
testsuite/long_addition_opts.c:96:0: style: The function 'funcm65536_x' is never used. [unusedFunction]

^
testsuite/long_addition_opts.c:75:0: style: The function 'funcmx' is never used. [unusedFunction]

^
testsuite/Issue_1141_Namespaces.c:15:0: style: The function 'function2' is never used. [unusedFunction]

^
testsuite/long_addition_opts.c:22:0: style: The function 'funcx' is never used. [unusedFunction]

^
testsuite/mathops_ieee.c:26:0: style: The function 'ge' is never used. [unusedFunction]

^
libsrc/target/trs80/fcntl/genspec.c:36:0: style: The function 'genspec' is never used. [unusedFunction]

^
src/ucpp/hash.c:180:0: style: The function 'getHT' is never used. [unusedFunction]

^
libsrc/target/cpm/fcntl/get_dir_name.c:14:0: style: The function 'get_dir_name' is never used. [unusedFunction]

^
src/z80asm/src/cpp/float.cpp:624:0: style: The function 'get_float_format_define' is never used. [unusedFunction]

^
src/z80asm/src/c/module1.c:123:0: style: The function 'get_last_module' is never used. [unusedFunction]

^
libsrc/target/c128/c128/getjoyscia.c:24:0: style: The function 'getjoyscia' is never used. [unusedFunction]

^
libsrc/target/c128/c128/getmousesid.c:29:0: style: The function 'getmousesid' is never used. [unusedFunction]

^
libsrc/target/z88/net/getnetbyname.c:11:0: style: The function 'getnetbyname' is never used. [unusedFunction]

^
libsrc/target/z88/net/getnetbynumber.c:11:0: style: The function 'getnetbynumber' is never used. [unusedFunction]

^
libsrc/target/c128/c128/getpotssid.c:27:0: style: The function 'getpotssid' is never used. [unusedFunction]

^
libsrc/target/z88/net/getprotobyname.c:11:0: style: The function 'getprotobyname' is never used. [unusedFunction]

^
libsrc/target/z88/net/getprotobynumber.c:11:0: style: The function 'getprotobynumber' is never used. [unusedFunction]

^
libsrc/target/z88/net/getservbyname.c:11:0: style: The function 'getservbyname' is never used. [unusedFunction]

^
libsrc/target/z88/net/getservbyport.c:11:0: style: The function 'getservbyport' is never used. [unusedFunction]

^
libsrc/target/z88/net/getservprotobyname.c:12:0: style: The function 'getservprotobyname' is never used. [unusedFunction]

^
libsrc/target/z88/net/getservprotobyport.c:11:0: style: The function 'getservprotobyport' is never used. [unusedFunction]

^
libsrc/target/c128/c128/gettimeracia.c:15:0: style: The function 'gettimeracia' is never used. [unusedFunction]

^
libsrc/target/c128/c128/gettimerbcia.c:15:0: style: The function 'gettimerbcia' is never used. [unusedFunction]

^
libsrc/target/c128/c128/gettodcia.c:15:0: style: The function 'gettodcia' is never used. [unusedFunction]

^
testsuite/rabbit/rabbit_optimisations.c:3:0: style: The function 'getviapointer' is never used. [unusedFunction]

^
libsrc/target/tvc/romgfx/getx.c:11:0: style: The function 'getx' is never used. [unusedFunction]

^
libsrc/target/tvc/romgfx/gety.c:11:0: style: The function 'gety' is never used. [unusedFunction]

^
testsuite/mathops_ieee.c:25:0: style: The function 'gt' is never used. [unusedFunction]

^
examples/z88/useless.c:63:0: style: The function 'handlecmds' is never used. [unusedFunction]

^
src/ucpp/hash.c:313:0: style: The function 'hash_struct' is never used. [unusedFunction]

^
libsrc/target/nabu/hcca/hcca.c:11:0: style: The function 'hcca_readInt16' is never used. [unusedFunction]

^
libsrc/target/nabu/hcca/hcca.c:63:0: style: The function 'hcca_writeInt16' is never used. [unusedFunction]

^
libsrc/target/nabu/hcca/hcca.c:69:0: style: The function 'hcca_writeString' is never used. [unusedFunction]

^
examples/g800/turtle.c:63:0: style: The function 'heading' is never used. [unusedFunction]

^
testsuite/shortcall.c:27:0: style: The function 'hlfunc1' is never used. [unusedFunction]

^
testsuite/shortcall.c:32:0: style: The function 'hlfunc2' is never used. [unusedFunction]

^
testsuite/shortcall.c:37:0: style: The function 'hlfunc3' is never used. [unusedFunction]

^
testsuite/shortcall.c:42:0: style: The function 'hlfunc4' is never used. [unusedFunction]

^
testsuite/Issue_1266_ranges.c:18:0: style: The function 'iand_test1' is never used. [unusedFunction]

^
testsuite/Issue_1266_ranges.c:22:0: style: The function 'iand_test2' is never used. [unusedFunction]

^
testsuite/Issue_1662_static_ptrs.c:29:0: style: The function 'idec' is never used. [unusedFunction]

^
testsuite/Issue_1662_static_ptrs.c:13:0: style: The function 'iinc' is never used. [unusedFunction]

^
src/ticks/debugger_gdb_packets.c:39:0: style: The function 'inbuf_reset' is never used. [unusedFunction]

^
libsrc/target/c128/c128/initpcx.c:22:0: style: The function 'initpcx' is never used. [unusedFunction]

^
src/sccz80/misc.c:36:0: style: The function 'initstack' is never used. [unusedFunction]

^
src/z80asm/src/c/array.c:17:0: style: The function 'intArray_pop' is never used. [unusedFunction]

^
src/z80asm/src/c/array.c:17:0: style: The function 'intArray_top' is never used. [unusedFunction]

^
testsuite/mathops_ieee.c:30:0: style: The function 'inverse' is never used. [unusedFunction]

^
libsrc/target/srr/srr/invid.c:13:0: style: The function 'invid' is never used. [unusedFunction]

^
examples/rcmx000/iolib.c:131:0: style: The function 'iolib_getbit' is never used. [unusedFunction]

^
examples/rcmx000/iolib.c:106:0: style: The function 'iolib_setbit' is never used. [unusedFunction]

^
libsrc/target/s1mp3/rs232/rs232_isr.c:9:0: style: The function 'irq_sci' is never used. [unusedFunction]

^
libsrc/target/c128/c128/is64kvdc.c:16:0: style: The function 'is64kvdc' is never used. [unusedFunction]

^
testsuite/Issue_480_asmfunc.c:33:0: style: The function 'isr1' is never used. [unusedFunction]

^
testsuite/Issue_480_asmfunc.c:38:0: style: The function 'isr2' is never used. [unusedFunction]

^
src/sccz80/preproc.c:227:0: style: The function 'keepch' is never used. [unusedFunction]

^
src/ucpp/hash.c:216:0: style: The function 'killHT' is never used. [unusedFunction]

^
libsrc/assert/assert.c:16:0: style: The function 'l_assert' is never used. [unusedFunction]

^
libsrc/setjmp/l_longjmp.c:12:0: style: The function 'l_longjmp' is never used. [unusedFunction]

^
libsrc/setjmp/l_setjmp.c:14:0: style: The function 'l_setjmp' is never used. [unusedFunction]

^
testsuite/Issue_1266_ranges.c:2:0: style: The function 'land_test1' is never used. [unusedFunction]

^
testsuite/Issue_1266_ranges.c:6:0: style: The function 'land_test2' is never used. [unusedFunction]

^
testsuite/Issue_1266_ranges.c:10:0: style: The function 'land_test3' is never used. [unusedFunction]

^
testsuite/Issue_1266_ranges.c:14:0: style: The function 'land_test4' is never used. [unusedFunction]

^
testsuite/Issue_1662_static_ptrs.c:34:0: style: The function 'ldec' is never used. [unusedFunction]

^
src/z80asm/src/c/modlink.c:185:0: style: The function 'library_file_append' is never used. [unusedFunction]

^
testsuite/Issue_1662_static_ptrs.c:17:0: style: The function 'linc' is never used. [unusedFunction]

^
libsrc/target/srr/srr/linefill.c:18:0: style: The function 'linefill' is never used. [unusedFunction]

^
libsrc/target/c128/c128/lineivdc.c:15:0: style: The function 'lineivdc' is never used. [unusedFunction]

^
src/ticks/linenoise.c:2470:0: style: The function 'linenoiseColumns' is never used. [unusedFunction]

^
src/ticks/linenoise.c:2688:0: style: The function 'linenoiseHistory' is never used. [unusedFunction]

^
src/ticks/linenoise.c:2580:0: style: The function 'linenoiseHistoryGetMaxLen' is never used. [unusedFunction]

^
src/ticks/linenoise.c:2584:0: style: The function 'linenoiseHistorySetMaxLen' is never used. [unusedFunction]

^
src/ticks/linenoise.c:1570:0: style: The function 'linenoiseSetFreeHintsCallback' is never used. [unusedFunction]

^
src/ticks/linenoise.c:1564:0: style: The function 'linenoiseSetHintsCallback' is never used. [unusedFunction]

^
src/ticks/linenoise.c:1637:0: style: The function 'linenoiseSetMultiLine' is never used. [unusedFunction]

^
libsrc/target/c128/c128/linevdc.c:15:0: style: The function 'linevdc' is never used. [unusedFunction]

^
testsuite/Issue_1662_static_ptrs.c:38:0: style: The function 'lldec' is never used. [unusedFunction]

^
testsuite/Issue_1662_static_ptrs.c:21:0: style: The function 'llinc' is never used. [unusedFunction]

^
src/z80asm/src/c/array.c:18:0: style: The function 'longArray_clone' is never used. [unusedFunction]

^
testsuite/rabbit/rabbit_optimisations.c:77:0: style: The function 'longadd' is never used. [unusedFunction]

^
testsuite/z80n/Issue_312_z80n_optimisations.c:40:0: style: The function 'longadd_negative' is never used. [unusedFunction]

^
testsuite/z80n/Issue_312_z80n_optimisations.c:54:0: style: The function 'longcall' is never used. [unusedFunction]

^
testsuite/rabbit/rabbit_optimisations.c:72:0: style: The function 'longops' is never used. [unusedFunction]

^
testsuite/z80n/Issue_312_z80n_optimisations.c:46:0: style: The function 'longsub' is never used. [unusedFunction]

^
testsuite/Issue_1266_ranges.c:27:0: style: The function 'lor_test1' is never used. [unusedFunction]

^
testsuite/Issue_1266_ranges.c:31:0: style: The function 'lor_test2' is never used. [unusedFunction]

^
testsuite/Issue_1266_ranges.c:35:0: style: The function 'lor_test3' is never used. [unusedFunction]

^
testsuite/Issue_1266_ranges.c:39:0: style: The function 'lor_test4' is never used. [unusedFunction]

^
testsuite/rabbit/rabbit_optimisations.c:40:0: style: The function 'lshift' is never used. [unusedFunction]

^
testsuite/rabbit/rabbit_optimisations.c:45:0: style: The function 'lshift_long' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:121:0: style: The function 'lt_double' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:85:0: style: The function 'lt_double_c' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:101:0: style: The function 'lt_double_cr' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:137:0: style: The function 'lt_double_r' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:125:0: style: The function 'lt_float16' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:89:0: style: The function 'lt_float16_c' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:105:0: style: The function 'lt_float16_cr' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:141:0: style: The function 'lt_float16_r' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:113:0: style: The function 'lt_int' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:77:0: style: The function 'lt_int_c' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:93:0: style: The function 'lt_int_cr' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:129:0: style: The function 'lt_int_r' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:117:0: style: The function 'lt_long' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:81:0: style: The function 'lt_long_c' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:97:0: style: The function 'lt_long_cr' is never used. [unusedFunction]

^
testsuite/Issue_1466_float16_compare.c:133:0: style: The function 'lt_long_r' is never used. [unusedFunction]

^
testsuite/Issue_1266_ranges.c:43:0: style: The function 'lxor_test1' is never used. [unusedFunction]

^
testsuite/Issue_1266_ranges.c:47:0: style: The function 'lxor_test2' is never used. [unusedFunction]

^
testsuite/Issue_1266_ranges.c:51:0: style: The function 'lxor_test3' is never used. [unusedFunction]

^
testsuite/Issue_1266_ranges.c:55:0: style: The function 'lxor_test4' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/math32/c/m32_acosf.c:4:0: style: The function 'm32_acosf' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/math32/c/m32_acoshf.c:7:0: style: The function 'm32_acoshf' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/math32/c/m32_asinf.c:4:0: style: The function 'm32_asinf' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/math32/c/m32_asinhf.c:7:0: style: The function 'm32_asinhf' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/math32/c/m32_atan2f.c:4:0: style: The function 'm32_atan2f' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/math32/c/m32_atanhf.c:7:0: style: The function 'm32_atanhf' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/math32/c/m32_coshf.c:4:0: style: The function 'm32_coshf' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/math32/c/m32_exp10f.c:69:0: style: The function 'm32_exp10f' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/math32/c/m32_exp2f.c:70:0: style: The function 'm32_exp2f' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/math32/c/m32_fmodf.c:11:0: style: The function 'm32_fmodf' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/math32/c/m32_log10f.c:55:0: style: The function 'm32_log10f' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/math32/c/m32_log2f.c:55:0: style: The function 'm32_log2f' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/math32/c/m32_modff.c:33:0: style: The function 'm32_modff' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/math32/c/m32_powf.c:34:0: style: The function 'm32_powf' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/math32/c/m32_roundf.c:15:0: style: The function 'm32_roundf' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/math32/c/m32_sinhf.c:4:0: style: The function 'm32_sinhf' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/math32/c/m32_tanf.c:4:0: style: The function 'm32_tanf' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/math32/c/m32_tanhf.c:4:0: style: The function 'm32_tanhf' is never used. [unusedFunction]

^
src/z80asm/src/c/alloc.c:261:0: style: The function 'm_calloc_compat' is never used. [unusedFunction]

^
src/z80asm/src/c/alloc.c:199:0: style: The function 'm_is_managed' is never used. [unusedFunction]

^
src/z80asm/src/c/alloc.c:251:0: style: The function 'm_malloc_compat' is never used. [unusedFunction]

^
src/z80asm/src/c/alloc.c:331:0: style: The function 'm_realloc_compat' is never used. [unusedFunction]

^
src/z80asm/src/c/alloc.c:271:0: style: The function 'm_strdup_compat' is never used. [unusedFunction]

^
src/copt/regex/engine.c:66:0: style: The function 'matcher' is never used. [unusedFunction]

^
src/appmake/appmake.c:2000:0: style: The function 'mb_print_info' is never used. [unusedFunction]

^
testsuite/Issue_188_builtins.c:44:0: style: The function 'memcpy1' is never used. [unusedFunction]

^
testsuite/Issue_188_builtins.c:49:0: style: The function 'memcpy2' is never used. [unusedFunction]

^
testsuite/Issue_188_builtins.c:54:0: style: The function 'memcpy3' is never used. [unusedFunction]

^
testsuite/Issue_188_builtins.c:15:0: style: The function 'memset1' is never used. [unusedFunction]

^
testsuite/Issue_188_builtins.c:20:0: style: The function 'memset2' is never used. [unusedFunction]

^
testsuite/Issue_188_builtins.c:24:0: style: The function 'memset3' is never used. [unusedFunction]

^
testsuite/Issue_188_builtins.c:28:0: style: The function 'memset4' is never used. [unusedFunction]

^
libsrc/target/c128/c128/memtobufvdc.c:17:0: style: The function 'memtobufvdc' is never used. [unusedFunction]

^
libsrc/target/s1mp3/isr/isr_initialise.c:159:0: style: The function 'misr' is never used. [unusedFunction]

^
libsrc/math/cimpl/modf.c:6:0: style: The function 'modf' is never used. [unusedFunction]

^
testsuite/Issue_693_missing_return.c:13:0: style: The function 'ms_statuschar' is never used. [unusedFunction]

^
libsrc/video/tms9918/msx_calculate_side.c:19:0: style: The function 'msx_calculate_side' is never used. [unusedFunction]

^
src/z80asm/src/c/minunit.c:167:0: style: The function 'mu_compare_ans' is never used. [unusedFunction]

^
src/z80asm/src/c/minunit.c:213:0: style: The function 'mu_fini_' is never used. [unusedFunction]

^
src/z80asm/src/c/minunit.c:83:0: style: The function 'mu_init_' is never used. [unusedFunction]

^
src/z80asm/src/c/minunit.c:125:0: style: The function 'mu_run_test_' is never used. [unusedFunction]

^
testsuite/Issue_98_check_int.c:3:0: style: The function 'mul' is never used. [unusedFunction]

^
testsuite/Issue_98_check_int.c:12:0: style: The function 'mul3' is never used. [unusedFunction]

^
testsuite/Issue_98_check_int.c:16:0: style: The function 'mul3_2' is never used. [unusedFunction]

^
testsuite/Issue_98_underlying.c:16:0: style: The function 'mul_assign_to_int' is never used. [unusedFunction]

^
testsuite/Issue_98_underlying.c:8:0: style: The function 'muli' is never used. [unusedFunction]

^
testsuite/Issue_98_underlying.c:12:0: style: The function 'muli2' is never used. [unusedFunction]

^
libsrc/lib3d/mult_v.c:57:0: style: The function 'mult_v' is never used. [unusedFunction]

^
testsuite/Issue_452_arrays.c:29:0: style: The function 'multi1' is never used. [unusedFunction]

^
testsuite/Issue_452_arrays.c:36:0: style: The function 'multi2' is never used. [unusedFunction]

^
src/common/die.c:73:0: style: The function 'must_calloc' is never used. [unusedFunction]

^
src/common/die.c:81:0: style: The function 'must_free' is never used. [unusedFunction]

^
src/sccz80/main.c:985:0: style: The function 'mymalloc' is never used. [unusedFunction]

^
libsrc/target/z88/z88/nameapp.c:8:0: style: The function 'nameapp' is never used. [unusedFunction]

^
testsuite/mathops_ieee.c:22:0: style: The function 'ne' is never used. [unusedFunction]

^
testsuite/rabbit/rabbit_optimisations.c:15:0: style: The function 'negate' is never used. [unusedFunction]

^
src/ucpp/hash.c:123:0: style: The function 'newHT' is never used. [unusedFunction]

^
libsrc/target/s1mp3/isr/isr_initialise.c:174:0: style: The function 'nmisr' is never used. [unusedFunction]

^
libsrc/target/z88/z88/opentitled.c:19:0: style: The function 'opentitled' is never used. [unusedFunction]

^
libsrc/target/z88/z88/openwindow.c:10:0: style: The function 'openwindow' is never used. [unusedFunction]

^
testsuite/rabbit/rabbit_optimisations.c:20:0: style: The function 'or' is never used. [unusedFunction]

^
libsrc/target/oz/oz/ozinput/ozeditline.c:35:0: style: The function 'ozeditline' is never used. [unusedFunction]

^
libsrc/lib3d/ozplotpointcam.c:12:0: style: The function 'ozplotpointcam' is never used. [unusedFunction]

^
libsrc/target/oz/oz/oztime/oztime.c:41:0: style: The function 'oztime' is never used. [unusedFunction]

^
libsrc/target/z88/unused/parsename.c:9:0: style: The function 'parsefile' is never used. [unusedFunction]

^
libsrc/target/z88/unused/parseseg.c:9:0: style: The function 'parseseg' is never used. [unusedFunction]

^
examples/g800/turtle.c:70:0: style: The function 'pendown' is never used. [unusedFunction]

^
examples/g800/turtle.c:67:0: style: The function 'penup' is never used. [unusedFunction]

^
src/sccz80/io.c:104:0: style: The function 'pl' is never used. [unusedFunction]

^
libsrc/lib3d/polygon.c:17:0: style: The function 'polygon' is never used. [unusedFunction]

^
src/z80asm/src/cpp/errors.cpp:92:0: style: The function 'pop_location' is never used. [unusedFunction]

^
src/ucpp/atest.c:91:0: style: The function 'print_int' is never used. [unusedFunction]

^
libsrc/target/c128/c128/printbmivdc.c:22:0: style: The function 'printbmivdc' is never used. [unusedFunction]

^
libsrc/target/c128/c128/printbmvdc.c:22:0: style: The function 'printbmvdc' is never used. [unusedFunction]

^
support/debugger/debugger.c:52:0: style: The function 'printhex' is never used. [unusedFunction]

^
libsrc/lib3d/projection_opengl_m.c:57:0: style: The function 'projection_opengl_m' is never used. [unusedFunction]

^
libsrc/lib3d/projection_w3woody_m.c:60:0: style: The function 'projection_w3woody_m' is never used. [unusedFunction]

^
libsrc/psg/ay/psg_noise.c:15:0: style: The function 'psg_noise' is never used. [unusedFunction]

^
libsrc/psg/ay/psg_noise_channels.c:15:0: style: The function 'psg_noise_channels' is never used. [unusedFunction]

^
libsrc/games/psg_play.c:24:0: style: The function 'psg_play' is never used. [unusedFunction]

^
libsrc/psg/ay/psg_tone_channels.c:15:0: style: The function 'psg_tone_channels' is never used. [unusedFunction]

^
testsuite/Issue_452_pointers.c:6:0: style: The function 'ptr_char' is never used. [unusedFunction]

^
testsuite/Issue_452_pointers.c:36:0: style: The function 'ptr_double' is never used. [unusedFunction]

^
testsuite/Issue_452_pointers.c:16:0: style: The function 'ptr_int' is never used. [unusedFunction]

^
testsuite/Issue_452_pointers.c:26:0: style: The function 'ptr_long' is never used. [unusedFunction]

^
testsuite/Issue_452_pointers.c:46:0: style: The function 'ptr_struct' is never used. [unusedFunction]

^
libsrc/target/c128/c128/pulsewavesid.c:15:0: style: The function 'pulsewavesid' is never used. [unusedFunction]

^
src/z80asm/src/cpp/errors.cpp:88:0: style: The function 'push_location' is never used. [unusedFunction]

^
testsuite/rabbit/rabbit_optimisations.c:85:0: style: The function 'pushinstr' is never used. [unusedFunction]

^
src/ucpp/hash.c:142:0: style: The function 'putHT' is never used. [unusedFunction]

^
libsrc/target/cpm/graphics/putc_gsx.c:26:0: style: The function 'putc_gsx' is never used. [unusedFunction]

^
test/machine/Z80/rcmx_io.c:97:0: style: The function 'rcmx_io_external_in' is never used. [unusedFunction]

^
test/machine/Z80/rcmx_io.c:125:0: style: The function 'rcmx_io_external_out' is never used. [unusedFunction]

^
test/machine/Z80/rcmx_io.c:35:0: style: The function 'rcmx_io_init' is never used. [unusedFunction]

^
test/machine/Z80/rcmx_io.c:47:0: style: The function 'rcmx_io_internal_in' is never used. [unusedFunction]

^
test/machine/Z80/rcmx_io.c:102:0: style: The function 'rcmx_io_internal_out' is never used. [unusedFunction]

^
examples/rcmx000/twinkle2000.c:38:0: style: The function 'read_rtc' is never used. [unusedFunction]

^
libsrc/regex/regexp.c:1018:0: style: The function 'regdump' is never used. [unusedFunction]

^
libsrc/regex/regsub.c:37:0: style: The function 'regsub' is never used. [unusedFunction]

^
libsrc/target/c128/c128/releasesid.c:15:0: style: The function 'releasesid' is never used. [unusedFunction]

^
src/z80asm/src/c/symtab1.c:283:0: style: The function 'remove_all_static_syms' is never used. [unusedFunction]

^
src/ticks/breakpoints.c:157:0: style: The function 'remove_temp_breakpoints' is never used. [unusedFunction]

^
src/ucpp/hash.c:247:0: style: The function 'restoreHT' is never used. [unusedFunction]

^
libsrc/target/c128/c128/restorevdc.c:18:0: style: The function 'restorevdc' is never used. [unusedFunction]

^
libsrc/target/nabu/retronet/rn_fileDelete.c:8:0: style: The function 'rn_fileDelete' is never used. [unusedFunction]

^
libsrc/target/nabu/retronet/rn_fileDetails.c:8:0: style: The function 'rn_fileDetails' is never used. [unusedFunction]

^
libsrc/target/nabu/retronet/rn_fileHandleCopy.c:8:0: style: The function 'rn_fileHandleCopy' is never used. [unusedFunction]

^
libsrc/target/nabu/retronet/rn_fileHandleDeleteRange.c:9:0: style: The function 'rn_fileHandleDeleteRange' is never used. [unusedFunction]

^
libsrc/target/nabu/retronet/rn_fileHandleMove.c:9:0: style: The function 'rn_fileHandleMove' is never used. [unusedFunction]

^
libsrc/target/nabu/retronet/rn_fileSize.c:9:0: style: The function 'rn_fileSize' is never used. [unusedFunction]

^
libsrc/lib3d/rotx_m.c:57:0: style: The function 'rotx_m' is never used. [unusedFunction]

^
libsrc/lib3d/roty_m.c:57:0: style: The function 'roty_m' is never used. [unusedFunction]

^
libsrc/lib3d/rotz_m.c:57:0: style: The function 'rotz_m' is never used. [unusedFunction]

^
examples/z88/rpn.c:143:0: style: The function 'rpn_handlecmds' is never used. [unusedFunction]

^
libsrc/target/lm80c/rs232/rs232_close.c:15:0: style: The function 'rs232_close' is never used. [unusedFunction]

^
libsrc/target/mtx/rs232/rs232_get.c:15:0: style: The function 'rs232_get' is never used. [unusedFunction]

^
libsrc/target/lm80c/rs232/rs232_init.c:15:0: style: The function 'rs232_init' is never used. [unusedFunction]

^
libsrc/target/lm80c/rs232/rs232_params.c:17:0: style: The function 'rs232_params' is never used. [unusedFunction]

^
libsrc/target/mtx/rs232/rs232_put.c:13:0: style: The function 'rs232_put' is never used. [unusedFunction]

^
testsuite/rabbit/rabbit_optimisations.c:36:0: style: The function 'rshift' is never used. [unusedFunction]

^
libsrc/target/srr/srr/rtape.c:13:0: style: The function 'rtape' is never used. [unusedFunction]

^
libsrc/target/srr/srr/rtapeg.c:13:0: style: The function 'rtapeg' is never used. [unusedFunction]

^
src/ucpp/hash.c:235:0: style: The function 'saveHT' is never used. [unusedFunction]

^
libsrc/target/c128/c128/savevdc.c:27:0: style: The function 'savevdc' is never used. [unusedFunction]

^
libsrc/lib3d/scale_m.c:56:0: style: The function 'scale_m' is never used. [unusedFunction]

^
libsrc/lib3d/scale_v.c:56:0: style: The function 'scale_v' is never used. [unusedFunction]

^
src/ucpp/hash.c:294:0: style: The function 'scanHT' is never used. [unusedFunction]

^
libsrc/target/c128/c128/scrolldownvdc.c:19:0: style: The function 'scrolldownvdc' is never used. [unusedFunction]

^
libsrc/target/c128/c128/scrollupvdc.c:19:0: style: The function 'scrollupvdc' is never used. [unusedFunction]

^
libsrc/target/nc100/fcntl/opendir.c:57:0: style: The function 'seekdir' is never used. [unusedFunction]

^
src/z80asm/src/c/symtab1.c:249:0: style: The function 'select_symbols' is never used. [unusedFunction]

^
libsrc/threading/preempt/sem_destroy.c:9:0: style: The function 'sem_destroy' is never used. [unusedFunction]

^
libsrc/threading/preempt/sem_getvalue.c:10:0: style: The function 'sem_getvalue' is never used. [unusedFunction]

^
testsuite/Issue_1126_opt_rule.c:12:0: style: The function 'sendJoinTeam' is never used. [unusedFunction]

^
libsrc/target/c128/c128/set80x50textvdc.c:15:0: style: The function 'set80x50textvdc' is never used. [unusedFunction]

^
src/common/t/test.c:12:0: style: The function 'setUp' is never used. [unusedFunction]

^
examples/wall.c:183:0: style: The function 'set_attr' is never used. [unusedFunction]

^
src/ucpp/lexer.c:406:0: style: The function 'set_identifier_char' is never used. [unusedFunction]

^
src/z80asm/src/c/codearea.c:684:0: style: The function 'set_origin_option' is never used. [unusedFunction]

^
libsrc/target/c128/c128/setcharvdc.c:14:0: style: The function 'setcharvdc' is never used. [unusedFunction]

^
libsrc/target/c128/c128/setcursorvdc.c:14:0: style: The function 'setcursorvdc' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/EXAMPLES/sms/BalubaBalok/src/game.c:233:0: style: The function 'settilexyb' is never used. [unusedFunction]

^
libsrc/target/c128/c128/settimerbcia.c:15:0: style: The function 'settimerbcia' is never used. [unusedFunction]

^
libsrc/target/c128/c128/settodcia.c:15:0: style: The function 'settodcia' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/game/game_setup.c:133:0: style: The function 'setup_gainLife' is never used. [unusedFunction]

^
libsrc/target/cpm/graphics/setxy.c:19:0: style: The function 'setxy' is never used. [unusedFunction]

^
src/z80asm/src/cpp/preproc.cpp:1362:0: style: The function 'sfile_getline' is never used. [unusedFunction]

^
libsrc/lib3d/shear_m.c:57:0: style: The function 'shear_m' is never used. [unusedFunction]

^
libsrc/target/z88/fcntl/sondor.c:17:0: style: The function 'sondor' is never used. [unusedFunction]

^
libsrc/lib3d/stencil_add_ellipse.c:19:0: style: The function 'stencil_add_ellipse' is never used. [unusedFunction]

^
testsuite/Issue_1662_static_ptrs.c:25:0: style: The function 'stinc' is never used. [unusedFunction]

^
src/ticks/sxmlc.c:2146:0: style: The function 'str_unescape' is never used. [unusedFunction]

^
testsuite/Issue_693_missing_return.c:8:0: style: The function 'str_word_wrap' is never used. [unusedFunction]

^
testsuite/Issue_188_builtins.c:5:0: style: The function 'strchr1' is never used. [unusedFunction]

^
testsuite/Issue_188_builtins.c:10:0: style: The function 'strchr2' is never used. [unusedFunction]

^
testsuite/Issue_188_builtins.c:33:0: style: The function 'strcpy1' is never used. [unusedFunction]

^
testsuite/Issue_188_builtins.c:38:0: style: The function 'strcpy2' is never used. [unusedFunction]

^
libsrc/alloc/farz88/strings/strdup_far.c:19:0: style: The function 'strdup_far' is never used. [unusedFunction]

^
src/ticks/sxmlc.c:2109:0: style: The function 'strip_spaces' is never used. [unusedFunction]

^
libsrc/target/z88/z88/strippath.c:10:0: style: The function 'strippath' is never used. [unusedFunction]

^
testsuite/Issue_26_casting.c:33:0: style: The function 'struct_cast' is never used. [unusedFunction]

^
testsuite/Issue_452_pointers.c:58:0: style: The function 'struct_offset1' is never used. [unusedFunction]

^
testsuite/Issue_452_pointers.c:66:0: style: The function 'struct_offset2' is never used. [unusedFunction]

^
testsuite/Issue_452_pointers.c:73:0: style: The function 'struct_offset3' is never used. [unusedFunction]

^
testsuite/Issue_98_check_int.c:55:0: style: The function 'sub2_1' is never used. [unusedFunction]

^
testsuite/Issue_98_check_int.c:59:0: style: The function 'sub3' is never used. [unusedFunction]

^
testsuite/Issue_98_check_int.c:47:0: style: The function 'sub_1' is never used. [unusedFunction]

^
libsrc/target/x1/x1/subcpu_reset.c:14:0: style: The function 'subcpu_reset' is never used. [unusedFunction]

^
testsuite/rabbit/rabbit_optimisations.c:62:0: style: The function 'subtract' is never used. [unusedFunction]

^
test/framework/test.c:128:0: style: The function 'suite_add_fixture' is never used. [unusedFunction]

^
test/framework/test.c:118:0: style: The function 'suite_add_test_real' is never used. [unusedFunction]

^
src/ticks/syms.c:81:0: style: The function 'symbol_compare' is never used. [unusedFunction]

^
libsrc/target/trs80/fcntl/syserrlist.c:85:0: style: The function 'syserrlist' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/math/float/math16/c/tanf16.c:4:0: style: The function 'tanf16' is never used. [unusedFunction]

^
libsrc/target/x1/x1/tape.c:21:0: style: The function 'tape' is never used. [unusedFunction]

^
libsrc/target/sos/tape/tape_load.c:13:0: style: The function 'tape_load' is never used. [unusedFunction]

^
libsrc/target/enterprise/tape/tape_load_block.c:18:0: style: The function 'tape_load_block' is never used. [unusedFunction]

^
libsrc/target/x1/x1/tape_status.c:21:0: style: The function 'tape_status' is never used. [unusedFunction]

^
src/common/t/test.c:13:0: style: The function 'tearDown' is never used. [unusedFunction]

^
libsrc/target/nc100/fcntl/opendir.c:69:0: style: The function 'telldir' is never used. [unusedFunction]

^
test/suites/sccz80/bitfields.c:498:0: style: The function 'testCS' is never used. [unusedFunction]

^
test/suites/ctype/test_isspace.c:1285:0: style: The function 'test_isspace' is never used. [unusedFunction]

^
test/suites/ctype/test_isupper.c:1285:0: style: The function 'test_isupper' is never used. [unusedFunction]

^
test/suites/ctype/test_isxdigit.c:1285:0: style: The function 'test_isxdigit' is never used. [unusedFunction]

^
testsuite/Issue_678_compound.c:15:0: style: The function 'test_or' is never used. [unusedFunction]

^
test/suites/stdio/scanf.c:10:0: style: The function 'test_scanf_d' is never used. [unusedFunction]

^
testsuite/Issue_678_compound.c:23:0: style: The function 'test_value' is never used. [unusedFunction]

^
testsuite/Issue_678_compound.c:31:0: style: The function 'test_value_and' is never used. [unusedFunction]

^
examples/spectrum/preempt.c:24:0: style: The function 'thread2' is never used. [unusedFunction]

^
libsrc/threading/preempt/thread_exit.c:10:0: style: The function 'thread_exit' is never used. [unusedFunction]

^
libsrc/threading/preempt/thread_manager_init_real.c:12:0: style: The function 'thread_manager_init_real' is never used. [unusedFunction]

^
libsrc/time/time_from_structtm.c:8:0: style: The function 'time_from_structtm' is never used. [unusedFunction]

^
libsrc/target/c128/c128/timervalcia.c:15:0: style: The function 'timervalcia' is never used. [unusedFunction]

^
libsrc/target/c128/c128/todstrcia.c:15:0: style: The function 'todstrcia' is never used. [unusedFunction]

^
src/z80asm/src/cpp/lex.cpp:1559:0: style: The function 'token_text' is never used. [unusedFunction]

^
examples/g800/turtle.c:58:0: style: The function 'towards' is never used. [unusedFunction]

^
libsrc/lib3d/translate_m.c:56:0: style: The function 'translate_m' is never used. [unusedFunction]

^
libsrc/target/tvc/tvc_fgets_cons.c:15:0: style: The function 'tvc_fgets_cons' is never used. [unusedFunction]

^
libsrc/target/tvc/tvc_get_border.c:5:0: style: The function 'tvc_get_border' is never used. [unusedFunction]

^
libsrc/target/tvc/tvc_mapin_vram.c:3:0: style: The function 'tvc_mapin_vram' is never used. [unusedFunction]

^
libsrc/target/tvc/tvc_mapout_vram.c:3:0: style: The function 'tvc_mapout_vram' is never used. [unusedFunction]

^
libsrc/target/tvc/tvc_set_border.c:5:0: style: The function 'tvc_set_border' is never used. [unusedFunction]

^
libsrc/target/tvc/tvc_set_paper.c:4:0: style: The function 'tvc_set_paper' is never used. [unusedFunction]

^
libsrc/target/tvc/sound/tvc_set_sound.c:10:0: style: The function 'tvc_set_sound' is never used. [unusedFunction]

^
libsrc/target/tvc/sound/tvc_tune_play.c:27:0: style: The function 'tvc_tune_play' is never used. [unusedFunction]

^
src/ucpp/hash.c:270:0: style: The function 'tweakHT' is never used. [unusedFunction]

^
libsrc/sprites/software/sp1/zx/examples/ex0.c:20:0: style: The function 'u_free' is never used. [unusedFunction]

^
libsrc/sprites/software/sp1/zx/examples/ex0.c:16:0: style: The function 'u_malloc' is never used. [unusedFunction]

^
libsrc/target/cpm/graphics/undrawto.c:19:0: style: The function 'undrawto' is never used. [unusedFunction]

^
libsrc/lib3d/unit_v.c:57:0: style: The function 'unit_v' is never used. [unusedFunction]

^
src/ucpp/lexer.c:415:0: style: The function 'unset_identifier_char' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/s8/metasprite.c:20:0: style: The function 'updateMetaSpritePos' is never used. [unusedFunction]

^
libsrc/_DEVELOPMENT/EXAMPLES/sms/SpaceHawks/s8/metasprite.c:38:0: style: The function 'updateMetaSpriteTile' is never used. [unusedFunction]

^
src/ticks/linenoise.c:513:0: style: The function 'utf8_strwidth' is never used. [unusedFunction]

^
src/common/zutils.c:118:0: style: The function 'utstr_fgets' is never used. [unusedFunction]

^
testsuite/Issue_2234_ternary.c:25:0: style: The function 'varassign_direct_const_false' is never used. [unusedFunction]

^
testsuite/Issue_2234_ternary.c:37:0: style: The function 'varassign_direct_const_non_false' is never used. [unusedFunction]

^
testsuite/Issue_2234_ternary.c:31:0: style: The function 'varassign_direct_const_non_true' is never used. [unusedFunction]

^
testsuite/Issue_2234_ternary.c:19:0: style: The function 'varassign_direct_const_true' is never used. [unusedFunction]

^
testsuite/Issue_2234_ternary.c:7:0: style: The function 'varassign_direct_nonconst' is never used. [unusedFunction]

^
testsuite/Issue_2234_ternary.c:13:0: style: The function 'varassign_direct_nonconst2' is never used. [unusedFunction]

^
testsuite/Issue_2234_ternary.c:62:0: style: The function 'varassign_indirect_const_false' is never used. [unusedFunction]

^
testsuite/Issue_2234_ternary.c:54:0: style: The function 'varassign_indirect_const_true' is never used. [unusedFunction]

^
examples/sms/test.c:22:0: style: The function 'vbl_handler' is never used. [unusedFunction]

^
libsrc/video/tms9918/vdp_blit.c:20:0: style: The function 'vdp_blit' is never used. [unusedFunction]

^
libsrc/video/tms9918/vdp_execute_cmd.c:6:0: style: The function 'vdp_cmd_execute' is never used. [unusedFunction]

^
libsrc/video/tms9918/vdp_vfill_v.c:20:0: style: The function 'vdp_vfill_v' is never used. [unusedFunction]

^
libsrc/lib3d/vector_add.c:17:0: style: The function 'vector_add' is never used. [unusedFunction]

^
libsrc/lib3d/vector_distance.c:16:0: style: The function 'vector_distance' is never used. [unusedFunction]

^
libsrc/lib3d/vector_scalar.c:16:0: style: The function 'vector_scalar' is never used. [unusedFunction]

^
libsrc/target/z88/z88/wcnext.c:9:0: style: The function 'wcnext' is never used. [unusedFunction]

^
libsrc/gfx/x11/win_move.c:13:0: style: The function 'win_move' is never used. [unusedFunction]

^
libsrc/target/c128/c128/winvdc.c:20:0: style: The function 'winvdc' is never used. [unusedFunction]

^
examples/sound/arkos/arkos_interrupt.c:27:0: style: The function 'wrapper' is never used. [unusedFunction]

^
libsrc/stdio/fputc_callee.c:22:0: style: The function 'wrapper_fputc_callee' is never used. [unusedFunction]

^
libsrc/stdio/fputc_callee.c:166:0: style: The function 'wrapper_fputc_callee_8080' is never used. [unusedFunction]

^
libsrc/stdio/fputc_callee.c:56:0: style: The function 'wrapper_fputc_callee_z80' is never used. [unusedFunction]

^
src/ticks/debugger_gdb_packets.c:138:0: style: The function 'write_binary_packet' is never used. [unusedFunction]

^
src/zpragma/zpragma.c:160:0: style: The function 'write_need' is never used. [unusedFunction]

^
src/appmake/appmake.c:707:0: style: The function 'writelong_b' is never used. [unusedFunction]

^
src/appmake/appmake.c:757:0: style: The function 'writestring_pk' is never used. [unusedFunction]

^
libsrc/target/srr/srr/wtape.c:13:0: style: The function 'wtape' is never used. [unusedFunction]

^
libsrc/target/cpm/graphics/xorclga.c:19:0: style: The function 'xorclga' is never used. [unusedFunction]

^
libsrc/target/cpm/graphics/xordraw.c:19:0: style: The function 'xordraw' is never used. [unusedFunction]

^
libsrc/target/cpm/graphics/xordrawto.c:19:0: style: The function 'xordrawto' is never used. [unusedFunction]

^
examples/graphics/proportional.c:258:0: style: The function 'xputc' is never used. [unusedFunction]

^
nofile:0:0: information: Cppcheck cannot find all the include files (use --check-config for details) [missingInclude]

